<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>axios 数据请求</title>
    <url>/2020/04/10/axios/</url>
    <content><![CDATA[<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get请求</span></span><br><span class="line"><span class="comment">// 用法1</span></span><br><span class="line"><span class="comment">// axios.get(url,&#123;params&#125;) url是后端接口, params是携带参数的选项</span></span><br><span class="line"><span class="comment">// axios.get(&#x27;http://59.110.226.77:3000/api/list/hot&#x27;, &#123;</span></span><br><span class="line"><span class="comment">//     params: &#123;</span></span><br><span class="line"><span class="comment">//         cid: 17</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">//     .then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         console.log(&#x27;res&#x27;, res)</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="comment">//     .catch(error =&gt; Promise.reject(error))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法2</span></span><br><span class="line"><span class="comment">// axios(requestConfig)</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://59.110.226.77:3000/api/list/hot&#x27;</span>,</span><br><span class="line">    <span class="comment">// method: &#x27;get&#x27;, 默认get</span></span><br><span class="line">    params: &#123;</span><br><span class="line">        cid: <span class="number">16</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;res&#x27;</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">Promise</span>.reject(error))</span><br></pre></td></tr></table></figure>

<h3 id="Post-json请求"><a href="#Post-json请求" class="headerlink" title="Post-json请求"></a>Post-json请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// post-json请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://59.110.226.77:3000/api/user/login&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data: &#123; <span class="comment">// post请求在data中发送</span></span><br><span class="line">        username: <span class="built_in">this</span>.username,</span><br><span class="line">        password: <span class="built_in">this</span>.pass</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;res&#x27;</span>, res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">Promise</span>.reject(error))</span><br></pre></td></tr></table></figure>

<h3 id="Post-form请求"><a href="#Post-form请求" class="headerlink" title="Post-form请求"></a>Post-form请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// post-form请求</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> URLSearchParams <span class="comment">// 新建URL实例</span></span><br><span class="line">p.append(<span class="string">&quot;username&quot;</span>, <span class="built_in">this</span>.username) <span class="comment">// 增加</span></span><br><span class="line">p.append(<span class="string">&quot;password&quot;</span>, <span class="built_in">this</span>.pass) <span class="comment">// 增加</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://59.110.226.77:3000/api/user/login&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data: p <span class="comment">// 实例写在data中</span></span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;res&#x27;</span>, res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">Promise</span>.reject(error))</span><br></pre></td></tr></table></figure>

<h3 id="Post-file请求"><a href="#Post-file请求" class="headerlink" title="Post-file请求"></a>Post-file请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> FormData() <span class="comment">// 图片必须以二进制才能传递给后端</span></span><br><span class="line">    p.append(<span class="string">&#x27;file&#x27;</span>, e.target.files[<span class="number">0</span>]) <span class="comment">// 通过事件对象e来得到图片的实例</span></span><br><span class="line">    axios(&#123;</span><br><span class="line">        url: <span class="string">&#x27;https://elm.cangdu.org/v1/addimg/shop&#x27;</span>,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        data: p</span><br><span class="line">    &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;res&#x27;</span>, res)</span><br><span class="line">            <span class="built_in">this</span>.pic = <span class="string">&#x27;https://elm.cangdu.org/img/&#x27;</span> + res.data.image_path</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">Promise</span>.reject(error))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="axios自定义请求实例"><a href="#axios自定义请求实例" class="headerlink" title="axios自定义请求实例"></a>axios自定义请求实例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建自定义请求实例</span></span><br><span class="line"><span class="keyword">const</span> ins = axios.create(&#123;</span><br><span class="line">    <span class="comment">// 超时自动取消请求</span></span><br><span class="line">    timeout: <span class="number">20000</span>,</span><br><span class="line">    <span class="comment">// 统一设置数据请求基准地址</span></span><br><span class="line">    baseURL: <span class="string">&#x27;http://59.110.226.77:3000/api&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ins.get(<span class="string">&#x27;/list/sell&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        cid: <span class="number">17</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;res&#x27;</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">Promise</span>.reject(error))</span><br></pre></td></tr></table></figure>

<h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><blockquote>
<p>axios的拦截器是用于拦截请求和响应的，也就是在数据请求前做点事，在数据请求到之后做点事</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建自定义请求实例</span></span><br><span class="line"><span class="keyword">const</span> ins = axios.create(&#123;</span><br><span class="line">    <span class="comment">// 超时自动取消请求</span></span><br><span class="line">    timeout: <span class="number">20000</span>,</span><br><span class="line">    <span class="comment">// 统一设置数据请求基准地址</span></span><br><span class="line">    baseURL: <span class="string">&#x27;http://59.110.226.77:3000/api&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">ins.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 发生请求前的处理</span></span><br><span class="line">    <span class="comment">// token</span></span><br><span class="line">    <span class="comment">// config.headers.common[&#x27;自定义&#x27;] = cookie.get(&#x27;token&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;,<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 请求错误处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">ins.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 假设后端给你的不是你想要的，你怎么办</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据格式化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;,<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 响应错误处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">    axios.get(<span class="string">&#x27;http://59.110.226.77:3000/api/list/hot&#x27;</span>,&#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        cid: <span class="number">17</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    axios.get(<span class="string">&#x27;http://59.110.226.77:3000/api/list/price&#x27;</span>,&#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        cid: <span class="number">17</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;res1&#x27;</span>, res1)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;res2&#x27;</span>, res2)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基础命令</title>
    <url>/2020/06/13/gitbash/</url>
    <content><![CDATA[<h1 id="Git入门"><a href="#Git入门" class="headerlink" title="Git入门"></a>Git入门</h1><p>Git是目前世界上最先进的分布式版本控制系统。</p>
<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建本地仓库</span></span><br><span class="line">$ git init</span><br><span class="line">$ ls -ah <span class="comment"># 查看隐藏的.git文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到暂存区</span></span><br><span class="line">$ git add &lt;fileName&gt;</span><br><span class="line">$ git add . <span class="comment"># 添加全部</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到仓库</span></span><br><span class="line">$ git commit -m <span class="string">&quot;描述内容&quot;</span> <span class="comment">#将暂存区的内容一次性提交到仓库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看仓库当前状态</span></span><br><span class="line">$ git status</span><br></pre></td></tr></table></figure>

<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建SSH Key</span></span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;邮箱地址&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地关联远程库</span></span><br><span class="line">$ git remote add origin 远程库地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地内容推送到远程库</span></span><br><span class="line">$ git push -u origin master <span class="comment"># 第一次推送要加-u 参数 推荐已存在项目上传</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆远程库到本地</span></span><br><span class="line">$ git <span class="built_in">clone</span> 远程库地址 <span class="comment"># 推荐新建项目，每人拉取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程库</span></span><br><span class="line">$ git remote </span><br><span class="line"><span class="comment"># 或者 $ git remote -v </span></span><br><span class="line"><span class="comment"># 查看更详细信息</span></span><br></pre></td></tr></table></figure>

<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新标签</span></span><br><span class="line">$ git tag &lt;name&gt; <span class="comment"># 默认新建在最新提交的commit上</span></span><br><span class="line">$ git tag &lt;name&gt; <span class="comment"># 或对制定版本号打标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有标签</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定标签信息</span></span><br><span class="line">$ git show &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除标签</span></span><br><span class="line">$ git tag -d &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签推送到远程</span></span><br><span class="line">$ git push origin &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送全部标签</span></span><br><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure>

<h3 id="版本回退与管理"><a href="#版本回退与管理" class="headerlink" title="版本回退与管理"></a>版本回退与管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看修改的内容</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看历史版本</span></span><br><span class="line">$ git <span class="built_in">log</span> </span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline <span class="comment"># 只看版本号和描述内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退到上个版本</span></span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退上上个版本</span></span><br><span class="line">$ git reset --hard HEAD^^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退上N个版本</span></span><br><span class="line">$ git reset --hard HEAD-N</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退或前进到指定版本</span></span><br><span class="line">$ git reset --hard xxxx(<span class="built_in">hash</span>前6位)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看之前的命令</span></span><br><span class="line">$ git reflog <span class="comment"># 可查看回退之后找不到的版本号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢弃工作区的修改</span></span><br><span class="line">$ git checkout -- &lt;fileName&gt; </span><br><span class="line"><span class="comment"># 若没放到暂存区，现在，撤销到和版本库一样</span></span><br><span class="line"><span class="comment"># 若已添加到暂存区，撤销到和咱去存一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定删除文件</span></span><br><span class="line">$ git rm &lt;fileName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复删除文件</span></span><br><span class="line">$ git checkout -- &lt;fileName&gt;</span><br></pre></td></tr></table></figure>

<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">$ git branch 分支名</span><br><span class="line"><span class="comment"># $ git checkout -b 相当于创建并切换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">$ git branch <span class="comment"># 当前分支前面会加上*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支合并</span></span><br><span class="line">$ git merge 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 冲突解决</span></span><br><span class="line"><span class="comment"># 手动修改保存后再提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分支合并图</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消快进模式</span></span><br><span class="line">$ git merge --no-ff -m <span class="string">&quot;描述信息&quot;</span> dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储当前内容</span></span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复存储</span></span><br><span class="line">$ git stash pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送分支</span></span><br><span class="line">$ git push origin 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建远程分支到本地</span></span><br><span class="line">$ git checkout -b 分支名 origin/分支名</span><br></pre></td></tr></table></figure>

<h3 id="奇怪但有用的命令"><a href="#奇怪但有用的命令" class="headerlink" title="奇怪但有用的命令"></a>奇怪但有用的命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript 学习笔记</title>
    <url>/2020/04/08/ts1/</url>
    <content><![CDATA[<h3 id="js-的原生类型"><a href="#js-的原生类型" class="headerlink" title="js 的原生类型"></a>js 的原生类型</h3><ol>
<li>基本数据类型<ol>
<li>string number undefined null boolean</li>
</ol>
</li>
<li>复杂【引用】数据类型<ol>
<li>object</li>
</ol>
</li>
<li>缺点： 弱类型     数据类型可以更改    安全性低   </li>
</ol>
<h3 id="ts-类型系统-强类型-数据类型是定死的-安全性更高"><a href="#ts-类型系统-强类型-数据类型是定死的-安全性更高" class="headerlink" title="ts 类型系统   强类型   数据类型是定死的   安全性更高"></a>ts 类型系统   强类型   数据类型是定死的   安全性更高</h3><blockquote>
<p>编译代码时即可以发现错误</p>
</blockquote>
<ol>
<li>基本数据类型<ol>
<li>string number undefined null boolean</li>
</ol>
</li>
<li>复杂【引用】数据类型<ol>
<li>object</li>
</ol>
</li>
<li>其他数据类型<ol>
<li>内置对象类型</li>
<li>元组  </li>
<li>枚举</li>
<li>接口</li>
<li>。。。</li>
</ol>
</li>
</ol>
<h3 id="为什么要提供类型系统？-为什么现在要用ts"><a href="#为什么要提供类型系统？-为什么现在要用ts" class="headerlink" title="为什么要提供类型系统？ 为什么现在要用ts"></a>为什么要提供类型系统？ 为什么现在要用ts</h3><ol>
<li>ts是强类型，安全度更高</li>
<li>ts编译既可以发现错误，可以减少debug时间  </li>
<li>提供更多的代码提示</li>
</ol>
<h3 id="ts缺点"><a href="#ts缺点" class="headerlink" title="ts缺点"></a>ts缺点</h3><p>代码量增加了 </p>
<h3 id="第一个ts案例"><a href="#第一个ts案例" class="headerlink" title="第一个ts案例"></a>第一个ts案例</h3><ol>
<li>ts不能直接在浏览器使用，需要编译成js</li>
<li>tsc在编译时，还会将高版本的es语法转成es5</li>
</ol>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>let/const 变量名:数据类型 = 值</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">let</span> m: <span class="built_in">number</span> = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> s: <span class="built_in">string</span> = <span class="string">&#x27;Hello ts&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">let</span> und: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// null </span></span><br><span class="line"><span class="keyword">let</span> nul: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>ts给了简写：类型推论(根据值来根据值来定义变量的数据类型)</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">1000</span>; <span class="comment">// 1000是numble，所以推论n的类型是numble类型</span></span><br><span class="line">n = <span class="string">&#x27;string&#x27;</span>; <span class="comment">// 就会报错</span></span><br></pre></td></tr></table></figure>

<h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常见的对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   id: <span class="number">1</span>,</span><br><span class="line">   name: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">   age: <span class="number">18</span>,</span><br><span class="line">   sex: <span class="string">&#x27;nan&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line"><span class="keyword">const</span> obj: ObjType = &#123; <span class="comment">// obj后面跟接口名</span></span><br><span class="line">   id: <span class="number">1</span>,</span><br><span class="line">   name: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">   age: <span class="number">18</span>,</span><br><span class="line">   sex: <span class="string">&#x27;nan&#x27;</span>,</span><br><span class="line">   color: <span class="string">&#x27;yellow&#x27;</span> <span class="comment">// 可能有可能没有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj对象可能会增加一些属性</span></span><br><span class="line"><span class="comment">// obj.aa = 1000;</span></span><br><span class="line"><span class="comment">// obj.bb = 1000;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ts 提供两种自定义类型的方式：interface/type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// interface 接口名称[大驼峰] &#123;&#125;</span></span><br><span class="line"><span class="comment">// 必须和和接口的形状保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ObjType &#123;</span><br><span class="line">   <span class="keyword">readonly</span> id: <span class="built_in">number</span>, <span class="comment">// 只读属性</span></span><br><span class="line">   name: <span class="built_in">string</span>,</span><br><span class="line">   age: <span class="built_in">number</span>,</span><br><span class="line">   sex: <span class="built_in">string</span>,</span><br><span class="line">   color?: <span class="built_in">string</span>, <span class="comment">// 可选属性</span></span><br><span class="line">   [propName:<span class="built_in">string</span>]: <span class="built_in">any</span> <span class="comment">// 任意属性 obj对象可增加任何属性，这一行谨慎使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者可以采用type 方法类似上面</span></span><br><span class="line"><span class="comment">// type 接口名称[大驼峰] = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ObjType = &#123;</span><br><span class="line">   <span class="keyword">readonly</span> id: <span class="built_in">number</span>, <span class="comment">// 只读属性</span></span><br><span class="line">   name: <span class="built_in">string</span>,</span><br><span class="line">   age: <span class="built_in">number</span>,</span><br><span class="line">   sex: <span class="built_in">string</span>,</span><br><span class="line">   color?: <span class="built_in">string</span>, <span class="comment">// 可选属性</span></span><br><span class="line">   [propName:<span class="built_in">string</span>]: <span class="built_in">any</span> <span class="comment">// 任意属性 obj对象可增加任何属性，这一行谨慎使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结: </p>
<ol>
<li>赋值的时候，变量的形状必须和接口的形状保持一致。</li>
<li>可选属性的含义是该属性可以不存在。 ?:</li>
<li>未定义的属性用任意属性 [propName: string]: any</li>
<li>只读属性 readonly</li>
</ol>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>ts定类型：参数和返回值</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一些常用的函数ts写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn2 = (n: <span class="built_in">string</span>, <span class="attr">m</span>:<span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n + m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn3: <span class="function">(<span class="params">n: <span class="built_in">string</span>, m:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span> = <span class="function">(<span class="params">n, m</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n + m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn4</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">boolean</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">   <span class="comment">// void 表示空类型 函数没有返回值</span></span><br><span class="line">   <span class="comment">// a,b做了一些逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用接口定义函数的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn5: FnType = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> FnType &#123;</span><br><span class="line">   (a: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// number[]</span></span><br><span class="line"><span class="comment">// 定义了一个元素只能是number类型的数组</span></span><br><span class="line"><span class="keyword">const</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">const</span> arr2: <span class="built_in">string</span>[] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;v&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">const</span> arr3: (<span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span>)[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="literal">true</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// json 类型数组</span></span><br><span class="line"><span class="keyword">const</span> arr4: ArrType[] = [&#123;</span><br><span class="line">   id: <span class="number">1</span>,</span><br><span class="line">   name: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">   age: <span class="number">18</span>,</span><br><span class="line">   sex: <span class="string">&#x27;nan&#x27;</span>,</span><br><span class="line">   color: <span class="string">&#x27;yellow&#x27;</span> <span class="comment">// 可能有可能没有</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也是创建一个interface接口 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h4><p>元组： 是一种规定了数组长度以及每一个元素的数据类型的特殊数组</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义了一个长度为2的数组</span></span><br><span class="line"><span class="comment">// 2. 这个数组中第一个元素是number,第二个是string</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举类型：自动添加计数</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123; Red = <span class="number">1</span>,Green,Yellow &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Color.Green); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(Color.Yellow); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(Color[<span class="number">1</span>]); <span class="comment">// Red</span></span><br></pre></td></tr></table></figure>

<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型：给未知数据定义类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Handler</span>&lt;<span class="title">T</span>&gt; (<span class="params"> a: T </span>):<span class="title">number</span> </span>&#123; <span class="comment">// T在定义时是不确定类型的</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Handler(<span class="number">10</span>); <span class="comment">// 调用时我们知道了T是number类型</span></span><br><span class="line">Handler(<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="class-类"><a href="#class-类" class="headerlink" title="class (类)"></a>class (类)</h4><p>问题： 类中可以写什么? </p>
<ol>
<li>实例成员: 实例化类之后得到一个实例，这个实例身上的东西<ol>
<li>实例属性     [public] count = 1</li>
<li>实例方法     [public] fn () {}</li>
</ol>
</li>
<li>静态成员   类身上的东西<ol>
<li>静态属性    static color = ‘red’ </li>
<li>静态方法    static handler () {}</li>
</ol>
</li>
<li>私有成员   类内部使用的属性和方法<ol>
<li>私有属性    private msg = ‘hello’ </li>
<li>私有方法    private func () {}</li>
</ol>
</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类实现接口【多个】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">implements</span> <span class="title">AppType</span>,<span class="title">HelloType</span> </span>&#123;</span><br><span class="line">  count = <span class="number">1</span></span><br><span class="line">  color = <span class="string">&#x27;yello&#x27;</span></span><br><span class="line">  fn = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  username = <span class="string">&#x27;lakers&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> color:<span class="built_in">string</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> handler (n:<span class="built_in">string</span>,<span class="attr">m</span>:<span class="built_in">string</span>):<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n + m </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> msg:<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  <span class="keyword">private</span> func (n:<span class="built_in">string</span>,<span class="attr">m</span>:<span class="built_in">string</span>):<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n + m </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> AppType &#123; <span class="comment">//约定了实例成员的类型</span></span><br><span class="line">  count: <span class="built_in">number</span>,</span><br><span class="line">  color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> HelloType&#123;</span><br><span class="line">  username: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h4><p>问题： ts中引入其他js插件，会发生什么</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span> <span class="comment">// 问题： 引入时就报错 </span></span><br></pre></td></tr></table></figure>
<p>$.  js提示代码一个都没有了</p>
<p>类型声明： xxx.d.ts  类型声明文件</p>
<p>类型声明文件  @types 社区</p>
<p>输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cnpm i @types/jquery -S</span><br></pre></td></tr></table></figure>
<p>xxx.d.ts  类型声明文件中</p>
<p>declare  可以为js来声明类型<br>///   三斜杠语法  声明文件的引入</p>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>Css 弹性盒子</title>
    <url>/2020/02/01/css/flex/</url>
    <content><![CDATA[<h2 id="FLEX布局"><a href="#FLEX布局" class="headerlink" title="FLEX布局"></a>FLEX布局</h2><blockquote>
<p>  css3引入一种新的布局模式——Flexible Box布局，即伸缩布局盒模型（弹性盒布局），用来提供一个更有效的方式制定、调整和分布一个容器里的项目布局，即使他们的大小是未知或者动态的。<br>  主要思想是让容器有能力让其子项目能够改变其宽度、高度（甚至顺序），以最佳的方式填充可用空间（主要是为了适应所有类型的显示设备和屏幕大小）,flex容器会使子项目扩展来填充可用空间，或缩小他们以防止溢出容器,最重要的是，flex布局反向不可预知。</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Flex容器：采用 Flex 布局的元素的父元素；</span><br><span class="line">Flex项目：采用 Flex 布局的元素的父元素的子元素；</span><br><span class="line">容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。</span><br><span class="line">主轴的开始位置（与边框的交叉点）叫做main start；</span><br><span class="line">主轴的开始位置结束位置叫做main end；</span><br><span class="line">交叉轴的开始位置叫做cross start；</span><br><span class="line">交叉轴的结束位置叫做cross end；</span><br><span class="line">项目默认沿主轴排列；</span><br></pre></td></tr></table></figure>

<h4 id="flex容器属性"><a href="#flex容器属性" class="headerlink" title="flex容器属性"></a>flex容器属性</h4><p>​    1、display:flex、inline-flex</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">设置元素盒模型改成弹性盒模型</span><br><span class="line">注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</span><br></pre></td></tr></table></figure>

<p>​    2、flex-direction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-direction:属性规定灵活项目的方向（主轴方向）。</span><br><span class="line">    row:默认值。灵活的项目将水平显示，正如一个行一样。</span><br><span class="line">    row-reverse:与row相同，但是以相反的顺序。</span><br><span class="line">    column:灵活的项目将垂直显示，正如一个列一样。</span><br><span class="line">    column-reverse:与column相同，但是以相反的顺序。</span><br></pre></td></tr></table></figure>

<p>​    3、flex-wrap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-wrap: 用于设置伸缩项目在主轴上的换行方式</span><br><span class="line">    nowrap:默认值。规定灵活的项目不拆行或不拆列。</span><br><span class="line">    wrap:规定灵活的项目在必要的时候拆行或拆列。</span><br><span class="line">    wrap-reverse:规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。</span><br></pre></td></tr></table></figure>

<p>​    4、 flex-flow </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap;-简化代码</span><br></pre></td></tr></table></figure>

<p>​    5、 justify-content</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">justify-content：用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。</span><br><span class="line">    flex-start:默认值。项目位于容器的开头。	</span><br><span class="line">    flex-end:项目位于容器的结尾。	</span><br><span class="line">    center:项目位于容器的中心。	</span><br><span class="line">    space-between:项目位于各行之间留有空白的容器内。</span><br><span class="line">    space-around:项目位于各行之前、之间、之后都留有空白的容器内。</span><br></pre></td></tr></table></figure>

<p>​    6、align-items</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-items:定义flex子项目在flex容器的侧轴（纵轴）方向上的对齐方式。</span><br><span class="line"></span><br><span class="line">  stretch:默认值。元素被拉伸以适应容器。</span><br><span class="line">  如果指定侧轴大小的属性值为&#39;auto&#39;，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照&#39;min&#x2F;max-width&#x2F;height&#39;属性的限制。</span><br><span class="line">  center:元素位于容器的中心。</span><br><span class="line">  flex-start:元素位于容器的开头。</span><br><span class="line">  flex-end:元素位于容器的结尾。</span><br><span class="line">  baseline:元素位于容器的基线上。</span><br></pre></td></tr></table></figure>

<p>​    7、align-content</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-content：用于设置多行子元素在容器侧轴上的对齐方式(多行时才有效)；</span><br><span class="line"></span><br><span class="line">   stretch:默认值。元素被拉伸以适应容器。各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于&#39;flex-start&#39;。在其它情况下，剩余空间被所有行平分，以扩大它们的侧轴尺寸。</span><br><span class="line">   center:元素位于容器的中心。</span><br><span class="line">   flex-start:元素位于容器的开头。</span><br><span class="line">   flex-end:元素位于容器的结尾。</span><br><span class="line">   space-between:元素位于各行之间留有空白的容器内。</span><br><span class="line">   space-around:元素位于各行之前、之间、之后都留有空白的容器内。</span><br><span class="line">   说明：</span><br><span class="line">   align-content在侧轴上执行样式的时候，会把默认的间距给合并。对于单行子元素，该属性不起作用</span><br></pre></td></tr></table></figure>

<h4 id="flex项目属性"><a href="#flex项目属性" class="headerlink" title="flex项目属性"></a>flex项目属性</h4><p>1、align-self属性</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">align-self：属性定义flex子项单独在侧轴（纵轴）方向上的对齐方式</span><br><span class="line">	注意：align-self 属性可重写灵活容器的 align-items 属性。</span><br><span class="line">		</span><br><span class="line">		auto:默认值。元素继承了它的父容器的align-items属性。如果没有父容器则为 &quot;stretch&quot;。	</span><br><span class="line">        stretch:元素被拉伸以适应容器。</span><br><span class="line">        center:元素位于容器的中心。</span><br><span class="line">        flex-start:元素位于容器的开头。</span><br><span class="line">        flex-end:元素位于容器的结尾。</span><br><span class="line">        baseline:元素位于容器的基线上。</span><br></pre></td></tr></table></figure>

<p>2、flex-xxx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-grow：用于设置或检索弹性盒子项目的扩展比率；      </span><br><span class="line">      </span><br><span class="line">      number:规定项目将相对于其他灵活的项目进行扩展的量。默认值是 0。</span><br><span class="line">     即当容器空间大于内部元素空间之和时，剩余部分将根据各元素指定的flex-grow按比例分配，使各子元素增大；默认值为0，表示剩余空间不分配。</span><br><span class="line">	</span><br><span class="line">flex-shrink：设置弹性盒的伸缩项目的收缩比率；</span><br><span class="line">     </span><br><span class="line">     number:规定项目将相对于其他灵活的项目进行收缩的量。默认值是 1。</span><br><span class="line">    Flex子元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值；默认值为1，表示溢出时等比例缩小；</span><br><span class="line">    </span><br><span class="line">   算法-公式：</span><br><span class="line">    超出空间的像素数：1000-(900+200)&#x3D;-100px; </span><br><span class="line">    加权总和：&#x3D;(第一个子元素的宽度)*(shrink)+（第二个子元素的宽度）*   (shrink)+....; </span><br><span class="line">    A收缩的像素数：(Awidth*shrink)&#x2F;加权综合)*超出空间 &#x3D;收缩的像素数   </span><br><span class="line">    </span><br><span class="line">flex-basis:设置弹性盒伸缩基准值（指定flex-item在主轴上的初始大小）</span><br><span class="line">       </span><br><span class="line">       number:规定灵活项目的初始长度。</span><br><span class="line">       auto：默认值。长度等于灵活项目的长度。如果该项目未指定长度，则长度将根据内容决定。</span><br><span class="line"></span><br><span class="line">order：属性设置或检索弹性盒模型对象的子元素出现的順序。</span><br><span class="line">        number:值越小排列越靠前，值越大顺序越靠后</span><br><span class="line"></span><br><span class="line">6）flex：</span><br><span class="line"></span><br><span class="line">（1）flex 属性用于设置弹性盒模型对象的子元素如何分配父元素的空间。</span><br><span class="line">（2）flex 属性是 flex-grow、flex-shrink 和 flex-basis 属性的简写属性。</span><br><span class="line">   </span><br><span class="line">    auto&#x3D;1 1 auto</span><br><span class="line">    none&#x3D; 0 0 auto</span><br><span class="line">    1&#x3D; 1 1 auto</span><br></pre></td></tr></table></figure>



<h3 id="xx"><a href="#xx" class="headerlink" title="xx"></a>xx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 居中：给弹性项目设置margin:auto，自动获取弹性容器中剩余的空间。可以使弹性子元素在弹性容器的两轴方向都完全居中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 设置了 margin-right&#x2F;left&#x2F;bottom&#x2F;top: auto; 它将剩余的空间放置在元素的某侧；</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Css 媒体查询 移动端适配</title>
    <url>/2020/08/08/css/media/</url>
    <content><![CDATA[<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><blockquote>
<p>媒体查询可以根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">媒体查询包含一个可选的媒体类型和零个或多个满足CSS3规范的表达式. </span><br><span class="line"></span><br><span class="line">@media mediatype and|not|only  (media feature) &#123;CSS-Code;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">媒体设备类型：</span><br><span class="line"></span><br><span class="line">    all:用于所有设备--默认值</span><br><span class="line">    print:用于打印机和打印预览</span><br><span class="line">    screen:用于电脑屏幕，平板电脑，智能手机等(前端写这个就好了)</span><br><span class="line">    speech:应用于屏幕阅读器等发声设备</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">媒体属性：</span><br><span class="line">    max-height:定义输出设备中的页面最大可见区域高度。</span><br><span class="line">    max-width:定义输出设备中的页面最大可见区域宽度。</span><br><span class="line">    min-height:定义输出设备中的页面最小可见区域高度。</span><br><span class="line">    min-width:定义输出设备中的页面最小可见区域宽度。</span><br><span class="line">    width:定义输出设备中的页面可见区域宽度。</span><br><span class="line">    height:定义输出设备中的页面可见区域高度。</span><br><span class="line">    orientation:定义输出设备中的页面是横屏还是竖屏。 </span><br><span class="line">        landscape横屏 portrait竖屏</span><br><span class="line">    max-device-height:定义输出设备的屏幕可见的最大高度。</span><br><span class="line">    max-device-width:定义输出设备的屏幕最大可见宽度。</span><br><span class="line">    min-device-width:定义输出设备的屏幕最小可见宽度。</span><br><span class="line">    min-device-height:定义输出设备的屏幕的最小可见高度。</span><br><span class="line">    device-height:定义输出设备的屏幕可见高度。</span><br><span class="line">    device-width:定义输出设备的屏幕可见宽度。</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">操作符not、and、only和逗号(,)可以用来构建复杂的媒体查询</span><br><span class="line"></span><br><span class="line">（1）and 关键字用来把多个媒体属性和媒体类型组合成一条媒体查询，只有当每个属性都为真时，结果才为真。   </span><br><span class="line">    @media  all and (min-width: 700px) and (orientation: landscape) &#123; ... &#125;</span><br><span class="line">在可视区域宽度不小于700像素并在在横屏时有效</span><br><span class="line"></span><br><span class="line">（2）逗号： 媒体查询中使用逗号分隔，效果等同于 or 逻辑操作符，使用逗号分隔的媒体查询，任何一个媒体查询返回真，样式就是有效的。逗号分隔的列表中每个查询都是独立的，一个查询中的操作符并不影响其它的媒体查询。</span><br><span class="line">    @media all and (min-width: 700px),handheld and (orientation: landscape) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">（3）not 关键字用来对一条媒体查询的结果进行取反，在媒体查询为假时返回真,在逗号媒体查询列表中 not 仅会否定它应用到的媒体查询上而不影响其它的媒体查询</span><br><span class="line">    例如：</span><br><span class="line">    @media not screen and (color), print and (color)</span><br><span class="line">    等价于：</span><br><span class="line">    @media (not (screen and (color))), print and (color) </span><br><span class="line"></span><br><span class="line">（4）only关键字用来排除不支持css3媒体查询的浏览器。</span><br><span class="line">     对于支持Media Queries的设备来说，存在only关键字，移动设备的 Web 浏览器会忽略only关键字并直接根据后面的表达式应用样式文件。对于不支持Media Queries的设备但能够读取Media Type类型的Web浏览器，遇到only关键字时会忽略这个样式文件</span><br><span class="line">     所以，在使用媒体查询时，only最好不要忽略</span><br><span class="line"></span><br><span class="line">css2，css3的版本媒体查询的区别：</span><br><span class="line">    一般认为媒体查询是CSS3的新增内容，实际上CSS2已经存在了，CSS3新增了媒体属性和使用场景(IE8-浏览器不支持)</span><br><span class="line">     在CSS2中，媒体查询只使用于&lt;style&gt;和&lt;link&gt;标签中，以media属性存在media属性用于为不同的媒介类型规定不同的样式，媒体属性是CSS3新增的内容；</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/wide.css&quot; media=&quot;screen &quot; /&gt;</span><br><span class="line">     &lt;link rel=&quot;stylesheet&quot; href=&quot;css/mobile.css&quot; media=&quot;screen and (min-width:320px) and (max-width:640px)&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="常见适配范围"><a href="#常见适配范围" class="headerlink" title="常见适配范围"></a>常见适配范围</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/* 手机等小屏幕手持设备 */</span><br><span class="line">		@media screen and (min-width: 320px) and (max-width: 480px) &#123;&#125;</span><br><span class="line">/* 平板之类的宽度 1024 以下设备 */</span><br><span class="line">		@media only screen and (min-width: 321px) and (max-width: 1024px) &#123;&#125;</span><br><span class="line">/* PC客户端或大屏幕设备: 1028px 至更大 */</span><br><span class="line">		@media only screen and (min-width: 1029px) &#123;&#125;</span><br><span class="line">/* 竖屏 */</span><br><span class="line">		@media screen and (orientation:portrait) &#123;对应样式&#125;</span><br><span class="line">/* 横屏 */</span><br><span class="line">		@media screen and (orientation:landscape)&#123;对应样式&#125;</span><br></pre></td></tr></table></figure>

<h3 id="视口-viewport"><a href="#视口-viewport" class="headerlink" title="视口-viewport"></a>视口-viewport</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">许多智能手机都使用了一个比实际屏幕尺寸大很多的虚拟可视区域(980px)，主要目的就是让pc页面在智能手机端阅读时不会因为实际可视区域变形。所以你看到的页面还是普通样式，即一个全局缩小后的页面。为了让智能手机能根据媒体查询匹配对应样式，让页面在智能手机中正常显示，特意添加了一个meta标签。这个标签的主要作用就是让智能手机浏览页面时能进行优化，并且可以自定义界面可视区域的尺寸和缩放级别。</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">&lt;meta name&#x3D;&quot;viewport&quot;  content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;no&quot;&gt;</span><br><span class="line">属性值：</span><br><span class="line">    width:可视区域的宽度,值可为数字或关键词device-width；</span><br><span class="line">    height:可视区域的高度,值可为数字或关键词device-height；</span><br><span class="line">    initial-scale:页面首次被显示时的缩放级别（0-10.0），取值为1时页面按实际尺寸显示，无任何缩放</span><br><span class="line">    minimum-scale:设定最小缩小比例（0-10.0），取值为1时将禁止用户缩小至实际尺寸之下</span><br><span class="line">    maximum-scale:设定最大放大比例（0-10.0），取值为1时将禁止用户放大至实际尺寸之上</span><br><span class="line">    user-scalable:设定用户是否可以缩放（yes&#x2F;no）</span><br><span class="line"></span><br><span class="line">含义为：宽为手机移动设备默认宽度，初始缩放比例为1.0，最大缩放比例为原始像素大小，不允许用户放大或者缩小;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CSS3单位"><a href="#CSS3单位" class="headerlink" title="CSS3单位"></a>CSS3单位</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">相对单位：</span><br><span class="line">em：表示相对于应用在当前元素的字体尺寸；</span><br><span class="line">ex: 表示英文字母小x的高度</span><br><span class="line">ch: 数字0的宽度	</span><br><span class="line">rem: 根元素（html）的font-size</span><br><span class="line">vw: viewpoint width，视窗宽度，1vw&#x3D;视窗宽度的1%</span><br><span class="line">vh: viewpoint height，视窗高度，1vh&#x3D;视窗高度的1%</span><br><span class="line">vmin: vw和vh中较小的那个。	</span><br><span class="line">vmax: vw和vh中较大的那个。</span><br><span class="line">px: 编程中使用的开发单位；</span><br><span class="line"></span><br><span class="line">绝对单位：cm mm in pt pc px</span><br></pre></td></tr></table></figure>

<h4 id="分辨率，PPi-DPI-DPR-物理像素，逻辑像素区别"><a href="#分辨率，PPi-DPI-DPR-物理像素，逻辑像素区别" class="headerlink" title="分辨率，PPi,DPI,DPR,物理像素，逻辑像素区别"></a>分辨率，PPi,DPI,DPR,物理像素，逻辑像素区别</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1、屏幕尺寸：指的是屏幕对角线的长度(1英寸 = 2.54 厘米)</span><br><span class="line"></span><br><span class="line">2、分辨率：是指宽度上和高度上最多能显示的物理像素点个数</span><br><span class="line"></span><br><span class="line">3、点距：像素与像素之间的距离，点距和屏幕尺寸决定了分辨率大小</span><br><span class="line"></span><br><span class="line">4、PPI:屏幕像素密度，即每英寸(1英寸=2.54厘米)聚集的像素点个数，这里的一英寸还是对角线长度；</span><br><span class="line">   手机屏幕距离你的眼睛10-12英寸(约25-30厘米)时,它的分辨率只要达到300PPI这个神奇数字(每英寸300个像素点)以上,你的视网膜就无法分辨出像素点了,这样的屏幕被称为“视网膜屏幕”-Retina</span><br><span class="line"></span><br><span class="line">5、DPI:每英寸像素点，印刷行业术语。对于电脑屏幕而言和PPI是一个意思</span><br><span class="line"></span><br><span class="line">6、设备像素(又称为物理像素): 指设备能控制显示的最小物理单位，意指显示器上一个个的点。</span><br><span class="line"></span><br><span class="line">7、设备独立像素(也叫密度无关像素或逻辑像素)：可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，这个点是没有固定大小的，然后由相关系统转换为物理像素。</span><br><span class="line"></span><br><span class="line">8、DPR(设备像素比)：设备像素比 = 设备像素 / 逻辑像素。(在Retina屏的iphone上，DPR为2，1个css像素相当于2个物理像素)</span><br><span class="line">     window.devicePixelRatio </span><br></pre></td></tr></table></figure>

<h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">忽略Android平台中对邮箱地址的识别</span><br><span class="line">&lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;email&#x3D;no&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">iPhone会将看起来像电话号码的数字添加电话连接，应当关闭(可选yes no)</span><br><span class="line">&lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari</span><br><span class="line">&lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">在web app应用下状态条（屏幕顶部条）的颜色；</span><br><span class="line">&lt;meta name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;black&quot; &#x2F;&gt;</span><br><span class="line">  默认值：default（白色）</span><br><span class="line">         black（黑色）</span><br><span class="line">         black-translucent（灰色半透明）。</span><br><span class="line"></span><br><span class="line">网站开启对web app程序的支持</span><br><span class="line">&lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">添加到主屏幕后，全屏显示 </span><br><span class="line">&lt;meta name&#x3D;&quot;apple-touch-fullscreen&quot; content&#x3D;&quot;yes&quot;&gt;</span><br><span class="line"></span><br><span class="line">就是删除默认的苹果工具栏和菜单栏</span><br><span class="line">&lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;</span><br><span class="line">content有两个值”yes”和”no”,当需要显示工具栏和菜单栏时，这个行meta就不用加了，默认就是显示。</span><br><span class="line"></span><br><span class="line">应用信息，保留系统历史记录，运动效果</span><br><span class="line">&lt;meta name&#x3D;”App-Config” content&#x3D;”fullscreen&#x3D;yes,useHistoryState&#x3D;yes,transition&#x3D;yes”&#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="xx"><a href="#xx" class="headerlink" title="xx"></a>xx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. pt 即 point：有两个含义：</span><br><span class="line"></span><br><span class="line">  一是印刷行业常用单位，是一个标准长度单位，绝对大小，1pt &#x3D; 1&#x2F;72 英寸 &#x3D; 0.35mm；</span><br><span class="line"></span><br><span class="line">  二是 iOS 开发用的基本单位；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. dp (也称 dip)</span><br><span class="line"></span><br><span class="line">   dp 是安卓开发用的基准单位，在 dpi (屏幕像素密度，即每英寸包含的像素点) 为 160 的屏幕为上，1dp &#x3D; 1px。为了简单起见，Android 把屏幕密度分为了 5 种：mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. sp (可缩放独立像素)</span><br><span class="line"></span><br><span class="line">   在安卓系统里，sp 与 dp 类似，不同的是 sp 可以根据用户的字体大小首选项进行缩放，而 dp 则不会。 尽量使用 dp 作为空间大小单位，sp 作为文字相关大小单位。</span><br></pre></td></tr></table></figure>

<h3 id="媒体查询-1"><a href="#媒体查询-1" class="headerlink" title="媒体查询"></a>媒体查询</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">42.66666666px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">360px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">48px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">375px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">384px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">51.2px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">53.33333334px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">414px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">55.2px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">424px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">56.53333334px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">480px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">64px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">540px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">76px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">720px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">96px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">750px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="js动态改变html的font-size"><a href="#js动态改变html的font-size" class="headerlink" title="js动态改变html的font-size"></a>js动态改变html的font-size</h3><blockquote>
<p>除了媒体查询，还可以用js来改变html根元素的font-size，下面写了rem.js逻辑，需要全局引用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rem.js</span></span><br><span class="line"><span class="comment">//todo 配置移动端自适应</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">font</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.fontSize =</span><br><span class="line">    <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">3.75</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">font();</span><br><span class="line"></span><br><span class="line"><span class="comment">//todo 当我们浏览器的窗口发生改变时，重新计算尺寸</span></span><br><span class="line"><span class="built_in">window</span>.onresize = font;</span><br></pre></td></tr></table></figure>

<h3 id="移动端常用meta标签"><a href="#移动端常用meta标签" class="headerlink" title="移动端常用meta标签"></a>移动端常用meta标签</h3><p><a href="https://blog.csdn.net/yc123h/article/details/51356143">参考的博客链接</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, user-scalable=no&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-capable&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class="attr">content</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span><span class="attr">content</span>=<span class="string">&quot;telephone=no, email=no&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, user-scalable=no&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-capable&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span><span class="comment">&lt;!-- 删除苹果默认的工具栏和菜单栏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class="attr">content</span>=<span class="string">&quot;black&quot;</span> /&gt;</span><span class="comment">&lt;!-- 设置苹果工具栏颜色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> <span class="attr">content</span>=<span class="string">&quot;telphone=no, email=no&quot;</span> /&gt;</span><span class="comment">&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webkit&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 避免IE使用兼容模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;HandheldFriendly&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 微软的老式浏览器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;MobileOptimized&quot;</span> <span class="attr">content</span>=<span class="string">&quot;320&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- uc强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;screen-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UC强制全屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;full-screen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ强制全屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-fullscreen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UC应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;browsermode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;application&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-page-mode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- windows phone 点击无高光 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;msapplication-tap-highlight&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 适应移动端end --&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>JS SPA单页面应用(原理)</title>
    <url>/2020/04/08/js/SPA/</url>
    <content><![CDATA[<h1 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h1><p>单页面应用</p>
<ol>
<li>网易云音乐</li>
<li>饿了吗</li>
<li>美团</li>
</ol>
<hr>
<p>构建基本的页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/index&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/my&quot;</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/music&quot;</span>&gt;</span>音乐<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/user&quot;</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/news&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>SPA不用因为用户的操作而进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，从而实现UI与用户的交互</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hashchange 锚点改变 事件</span></span><br><span class="line"><span class="comment">// VUE.js 路由原理</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> main = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (location.hash) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#/index&#x27;</span>:</span><br><span class="line">            main.innerHTML = <span class="string">&#x27;首页&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#/my&#x27;</span>:</span><br><span class="line">            main.innerHTML = <span class="string">&#x27;我的&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#/music&#x27;</span>:</span><br><span class="line">            main.innerHTML = <span class="string">&#x27;音乐&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#/user&#x27;</span>:</span><br><span class="line">            main.innerHTML = <span class="string">&#x27;用户&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#/news&#x27;</span>:</span><br><span class="line">            main.innerHTML = <span class="string">&#x27;新闻&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS cookie的封装</title>
    <url>/2020/04/06/js/cookie/</url>
    <content><![CDATA[<h2 id="封装了一个cookie"><a href="#封装了一个cookie" class="headerlink" title="封装了一个cookie"></a>封装了一个cookie</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cookie = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">document</span>.cookie) &#123;</span><br><span class="line">          <span class="keyword">let</span> cookies = <span class="built_in">document</span>.cookie.split(<span class="string">&#x27;; &#x27;</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> cookies) &#123;</span><br><span class="line">              <span class="keyword">let</span> item = cookies[i].split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">              <span class="keyword">if</span> (item[<span class="number">0</span>] === key) &#123; <span class="keyword">return</span> item[<span class="number">1</span>]; &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>; <span class="comment">// 遍历结束没有cookie 返回空字符串</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">key, value, day</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> day === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">          d.setDate(d.getDate() + day);</span><br><span class="line">          <span class="built_in">document</span>.cookie = <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>;path=/;expires=<span class="subst">$&#123;d&#125;</span>`</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">document</span>.cookie = <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>;path=/`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.set(key, <span class="string">&#x27;&#x27;</span>, -<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 防抖和节流</title>
    <url>/2020/04/07/js/debounce/</url>
    <content><![CDATA[<h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><blockquote>
<p>短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</p>
</blockquote>
<ol>
<li>在事件触发时，开始计时，</li>
<li>在规定的时间（delay）内，若再次触发事件，将上一次计时（timer）清空，然后重新开始计时。</li>
<li>保证只有在规定时间内没有再次触发事件之后，再去执行这个事件。 </li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防抖(非立即执行)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            callback.apply(_this, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防抖(立即执行)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            callback.apply(_this, args)</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; flag = <span class="literal">true</span> &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><blockquote>
<p>指定时间间隔内，若事件被多次触发，只会执行一次</p>
</blockquote>
<ol>
<li>在事件触发之后，开始计时，</li>
<li>在规定的时间（delay）内，若再次触发事件，不对此事件做任何处理。</li>
<li>保证在规定时间内只执行一次事件.</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流(非立即执行)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                callback.apply(_this, args)</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流(立即执行)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            callback.apply(_this, args)</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Js 继承</title>
    <url>/2020/08/15/js/extand/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>从其他的对象上获得属性或方法<br>JavaScript中class是构造函数的语法糖</p>
</blockquote>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123; <span class="comment">// 构造函数作用是用于创建对象</span></span><br><span class="line">    <span class="comment">// 在构造函数中 this指向新创建的对象</span></span><br><span class="line">    <span class="comment">// this上绑定属性为 对象的私有属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Father(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f); <span class="comment">// Father&#123; name: &quot;zhangsan&quot;, age: 50 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 让子类的实例继承父类的属性</span></span><br><span class="line">    <span class="comment">// 在子类调用父类构造函数</span></span><br><span class="line">    <span class="comment">// this.father = Father;</span></span><br><span class="line">    <span class="comment">// this.father(name, age);</span></span><br><span class="line">    <span class="comment">// delete this.father</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类的构造函数，将this指向子类的实例</span></span><br><span class="line">    Father.call(<span class="built_in">this</span>, ...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Son(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">20</span>)); <span class="comment">// Son&#123; name: &quot;xiaoming&quot;, age: 20 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">123456</span>;</span><br><span class="line">    <span class="built_in">this</span>.fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将A的实例设置成B的原型</span></span><br><span class="line"><span class="comment">// 通过原型继承 私有属性和方法</span></span><br><span class="line">B.prototype = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">b.fn(); <span class="comment">// 123456</span></span><br></pre></td></tr></table></figure>

<h3 id="混合继承"><a href="#混合继承" class="headerlink" title="混合继承"></a>混合继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在子类中调用父类构造函数</span></span><br><span class="line">    <span class="comment">// 继承私有属性和方法</span></span><br><span class="line">    Father.call(<span class="built_in">this</span>, ...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类的公有方法</span></span><br><span class="line"><span class="comment">// 将父类的原型设置成子类的原型</span></span><br><span class="line">Son.prototype = Father.prototype;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Son(<span class="string">&#x27;lisi&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Son&#123;&#125;</span></span><br><span class="line">s.sayName(); <span class="comment">// lisi</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS jsonp--一种跨域解决方式</title>
    <url>/2020/04/06/js/jsonp/</url>
    <content><![CDATA[<h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><blockquote>
<p>JSONP请求的原理是动态创建script 使用src发送请求<br>JSONP的请求必须是绝对路径</p>
</blockquote>
<ol>
<li>创建script元素 document.createElement(‘script’)</li>
<li>将请求路径写在src属性上 script.src = url?key=value</li>
<li>设置一个全局函数</li>
<li>创建的script放入页面然后删除</li>
</ol>
<h3 id="案例1-读取本地文件"><a href="#案例1-读取本地文件" class="headerlink" title="案例1 读取本地文件"></a>案例1 读取本地文件</h3><ol>
<li>在本地文件夹随便创建一个txt文件 里面写一些数据<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">// abcd.txt</span><br><span class="line">let a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">console.log(a+b);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.src = <span class="string">&#x27;http://127.0.0.1:5501/test/abcd.txt&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.append(script);</span><br><span class="line">    <span class="built_in">document</span>.body.remove(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/jsonp-1.png" alt="avatar"></li>
</ol>
<p>可以看出jsonp可以读取文件，并作为js执行</p>
<h3 id="案例2-百度搜索框"><a href="#案例2-百度搜索框" class="headerlink" title="案例2 百度搜索框"></a>案例2 百度搜索框</h3><ol>
<li>html代码<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>js代码<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> search = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#search&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    search.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="string">&#x27;https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=33358,33260,33272,31660,33595,33570,33265&amp;wd=&#x27;</span>+<span class="built_in">this</span>.value+<span class="string">&#x27;&amp;req=2&amp;csor=3&amp;pwd=12&amp;cb=callback&#x27;</span>;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.src = url;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#list&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> li = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    data.g.forEach(<span class="function"><span class="params">elm</span>=&gt;</span>&#123;</span><br><span class="line">        li+=<span class="string">&#x27;&lt;li&gt;&lt;a href=&quot;https://www.baidu.com/s?ie=utf-8&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=&#x27;</span>+elm.q+<span class="string">&#x27;&amp;fenlei=256&amp;rsv_pq=a7bace480006dcea&amp;rsv_t=0d1dm1CIZNLanurak4R4iHbfMmdZzR4u0j1brhpapidjuEeNl%2B8F%2Fcd2YD4&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=ts_0&amp;rsv_sug3=6&amp;rsv_sug1=5&amp;rsv_sug7=101&amp;rsv_sug2=1&amp;rsv_btype=i&amp;prefixsug=12%2526lt%253B06&amp;rsp=0&amp;inputT=444380&amp;rsv_sug4=444380&quot;&gt;&#x27;</span>+elm.q+<span class="string">&#x27;&lt;/a&gt;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    list.innerHTML = li;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>jsonp的原理很简单，就是动态的创造script标签，然后利用script的src 不受同源策略约束来跨域获取数据。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 项目快速构建 - Cli</title>
    <url>/2021/03/14/vue3/cli/</url>
    <content><![CDATA[<h2 id="Vue3-项目快速构建-Cli"><a href="#Vue3-项目快速构建-Cli" class="headerlink" title="Vue3 项目快速构建 - Cli"></a>Vue3 项目快速构建 - Cli</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cnpm i @vue/cli -g</span><br></pre></td></tr></table></figure>

<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vue create 项目名</span><br></pre></td></tr></table></figure>
<p><img src="/img/1-item.png" alt="avatar"><br><img src="/img/2-item.png" alt="avatar"><br><img src="/img/3-item.png" alt="avatar"><br><img src="/img/4-item.png" alt="avatar"></p>
<blockquote>
<p>这里我遇到一个问题：如何更改安装时的包管理器为yarn或npm？</p>
</blockquote>
<p>执行vue create project 之后如果显示npm run serve 则表示你使用的是npm创建的项目</p>
<p>如果显示yarn serve则表示yarn创建</p>
<blockquote>
<p>如何切换包管理器？</p>
</blockquote>
<p>~/.vuerc</p>
<p>windows环境则存在在C:/user/administrator/ 下<br>打开此文件手动更改配置内容npm为yarn 或者直接删除.vuerc 重新创建项目</p>
<h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><ol>
<li>安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cnpm i yarn -g</span><br></pre></td></tr></table></figure></li>
<li>项目的操作命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn serve <span class="comment"># 开发环境下启动项目</span></span><br><span class="line">$ yarn build <span class="comment"># 生产环境压缩打包项目，供项目上线</span></span><br><span class="line">$ yarn lint <span class="comment"># 检测js语法规范</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ol>
<li>dist  生产环境打包后的资源存放目录</li>
<li>node_modules  这里放置的都是项目的插件【第三方依赖【库】】</li>
<li>public  静态资源<ol>
<li>favicon.ico 网页的标题的logo</li>
<li>index.html  项目的模板<ol>
<li>提供vue的实例作用的范围容器</li>
<li>引入一些资源</li>
<li>建议： 不要去操作</li>
</ol>
</li>
</ol>
</li>
<li>src   源代码开发目录[ 程序员主要工作目录 ] <ol>
<li>assets  静态资源【图片、字体文件】</li>
<li>components  公共组件目录<ol>
<li>xxx.vue </li>
</ol>
</li>
<li>App.vue    App组件【一个vue文件就是一个组件】</li>
<li>main.ts  项目入口文件</li>
<li>shims-vue.d.ts  类型声明文件</li>
<li>.borwserslistrc<ol>
<li>浏览器支持度说明文件</li>
</ol>
</li>
<li>.eslintrc.js   eslint语法规范配置文件</li>
<li>.gitignore    git上传代码托管平台的配置文件</li>
<li>babel.config.js  优雅降级配置文件 </li>
<li>package.json  项目的记录文件，用于记录<ol>
<li> 项目版本</li>
<li> 项目是否私有</li>
<li> 项目装了哪些插件</li>
</ol>
</li>
<li>README.md  项目的说明书</li>
<li>tsconfig.json ts的配置文件</li>
<li>yarn.lock 项目中插件的版本锁定文件</li>
</ol>
</li>
</ol>
<h3 id="node-modules的安装和删除"><a href="#node-modules的安装和删除" class="headerlink" title="node_modules的安装和删除"></a>node_modules的安装和删除</h3><ol>
<li>安装: yarn</li>
<li>删除: rm -rf node_modules</li>
</ol>
<h3 id="阅读项目"><a href="#阅读项目" class="headerlink" title="阅读项目"></a>阅读项目</h3><h4 id="main-ts"><a href="#main-ts" class="headerlink" title="main.ts"></a>main.ts</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> <span class="comment">// 采用 es6模块化</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>es6 导出<ol>
<li>export default xxx 默认导出一个</li>
<li>export xxx 批量导出，可以导出多个</li>
</ol>
</li>
<li>es6 导入<ol>
<li>import xxx from ‘xxx’ 默认导入</li>
<li>批量导入<ol>
<li>import {} from ‘xxx’</li>
<li>import * as feom ‘xxx’</li>
<li>import { obj as o } from ‘xxx’  // as 表示别名</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="APP-Vue"><a href="#APP-Vue" class="headerlink" title="APP.Vue"></a>APP.Vue</h4><ol>
<li>.Vue结尾的文件，称为SFC(单文件组件)</li>
<li>SFC构成(?表示可有可无)<ol>
<li>template<ol>
<li>jsx</li>
</ol>
</li>
<li>script?<ol>
<li>组件是通过defineComponent(options)</li>
<li><a href="/2021/03/03/vue3/component/">options就是之前的组件用法</a></li>
</ol>
</li>
<li>style?<ol>
<li>css预处理器: stylus/less/sass</li>
<li>两个属性<ol>
<li>lang 表示选择哪个css语法</li>
<li>scoped<ol>
<li>有 局部样式【只在当前组件生效】</li>
<li>无 全局样式</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h4><ol>
<li>vue.config.js 是项目的配置文件(建立在根目录下)</li>
<li>可以配置: 跨域，路径别名，服务器配置，项目优化型的配置</li>
<li>vue.config.js中实质上书写的是webpack</li>
<li>webpack底层使用Node.js实现的</li>
<li>Node.js 的模块化: Common.js</li>
<li>每次修改项目配置文件，项目需要重启才能生效</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    lintOnsave: <span class="literal">false</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        overlay: &#123; <span class="comment">// eslint 关闭</span></span><br><span class="line">            warnings: <span class="literal">false</span>,</span><br><span class="line">            errors: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        port: <span class="number">9000</span>, <span class="comment">// 服务器端口修改</span></span><br><span class="line">        proxy: &#123; <span class="comment">// 反向代理</span></span><br><span class="line">            <span class="comment">// 标识符: 反向代理的配置选项</span></span><br><span class="line">            <span class="comment">// 标识符我们选择接口中统一存在的路径，一般基本上都是域名后的第一个路径</span></span><br><span class="line">            <span class="comment">// 例如请求https://m.maoyan.com/ajax/movieOnInfoList </span></span><br><span class="line">            <span class="string">&#x27;/ajax&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&#x27;https://m.maoyan.com&#x27;</span>, <span class="comment">// 目标源</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>, <span class="comment">// 使用我们的源</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs mysql实现用户注册登录</title>
    <url>/2020/07/13/nodejs/mysql/</url>
    <content><![CDATA[<h2 id="Nodejs之mysql连接池"><a href="#Nodejs之mysql连接池" class="headerlink" title="Nodejs之mysql连接池"></a>Nodejs之mysql连接池</h2><h3 id="利用express脚手架打造一个服务器-没有安装脚手架的参考express官网"><a href="#利用express脚手架打造一个服务器-没有安装脚手架的参考express官网" class="headerlink" title="利用express脚手架打造一个服务器(没有安装脚手架的参考express官网)"></a>利用express脚手架打造一个服务器(没有安装脚手架的参考express官网)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ express app <span class="comment"># app只是项目名，可以随意更改名字</span></span><br></pre></td></tr></table></figure>
<p>再进入app文件夹，安装项目依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> app</span><br><span class="line"></span><br><span class="line">$ npm i</span><br><span class="line"></span><br><span class="line">$ npm start     <span class="comment"># 成功则可以在localhost:3000访问</span></span><br></pre></td></tr></table></figure>

<h3 id="引入npm中mysql第三方插件"><a href="#引入npm中mysql第三方插件" class="headerlink" title="引入npm中mysql第三方插件"></a>引入npm中mysql第三方插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i mysql -S</span><br></pre></td></tr></table></figure>

<p>在app项目里新建db文件夹，里面放入index.js 用于存放mysql连接池</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>); <span class="comment">// 引入第三方插件mysql</span></span><br><span class="line"><span class="keyword">var</span> pool = mysql.createPool(&#123;</span><br><span class="line">    connectionLimit: <span class="number">10</span>, <span class="comment">// 最大连接数</span></span><br><span class="line">    host: <span class="string">&#x27;localhost&#x27;</span>, <span class="comment">// 数据库地址</span></span><br><span class="line">    user: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 数据库用户名</span></span><br><span class="line">    password: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 数据库密码</span></span><br><span class="line">    database: <span class="string">&#x27;&#x27;</span> <span class="comment">// 数据库名</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = pool; <span class="comment">// 将连接池输出</span></span><br></pre></td></tr></table></figure>

<h3 id="在routes文件夹中新建login-js-用来书写登陆逻辑"><a href="#在routes文件夹中新建login-js-用来书写登陆逻辑" class="headerlink" title="在routes文件夹中新建login.js, 用来书写登陆逻辑"></a>在routes文件夹中新建login.js, 用来书写登陆逻辑</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// login.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); <span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;../db&#x27;</span>); <span class="comment">// 引入刚才书写的index.js nodejs默认进入index命名的文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = express.Router(); <span class="comment">// 打造express路由</span></span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123; <span class="comment">// login为二级url</span></span><br><span class="line">    <span class="comment">// 解构</span></span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = req.body; <span class="comment">// 从前端(req.body)接收数据 如果是get请求就是req.query</span></span><br><span class="line">    <span class="keyword">const</span> sql = <span class="string">`select * from users where username = &#x27;<span class="subst">$&#123;username&#125;</span>&#x27; and password = &#x27;<span class="subst">$&#123;password&#125;</span>&#x27;`</span>; <span class="comment">// 书写sql语句</span></span><br><span class="line">    mysql.query(sql, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123; <span class="comment">// 第一个参数sql语句,第二个是回调函数,错误优先</span></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (data.length) &#123; <span class="comment">// data.length = 0 即为false</span></span><br><span class="line">            res.send(<span class="string">&#x27;&#123;&quot;msg&quot;:&quot;用户名已存在&quot;&#125;&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.send(<span class="string">&#x27;&#123;&quot;msg&quot;:&quot;用户名可以使用&quot;&#125;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router; <span class="comment">// 将路由输出</span></span><br></pre></td></tr></table></figure>

<h3 id="在根目录app-js中增加下面两条语句配置路由"><a href="#在根目录app-js中增加下面两条语句配置路由" class="headerlink" title="在根目录app.js中增加下面两条语句配置路由"></a>在根目录app.js中增加下面两条语句配置路由</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">var</span> loginRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/login&#x27;</span>); <span class="comment">// 引入刚才打造好并输出的路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/api&#x27;</span>, loginRouter); <span class="comment">// 使用中间件  api为base url</span></span><br></pre></td></tr></table></figure>
<p>这样我们就做好登陆的接口: localhost:3000/api/login</p>
<h3 id="在routes文件夹中新建register-js-用来书写注册逻辑"><a href="#在routes文件夹中新建register-js-用来书写注册逻辑" class="headerlink" title="在routes文件夹中新建register.js, 用来书写注册逻辑"></a>在routes文件夹中新建register.js, 用来书写注册逻辑</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// register.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;../db&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/register&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password, sex, phone, email, address, age &#125; = req.body;</span><br><span class="line">    <span class="keyword">const</span> sql = <span class="string">`insert into users(username,password,sex,phone,email,address,age) values (?,?,?,?,?,?,?)`</span>; <span class="comment">// ？是占位符</span></span><br><span class="line">    mysql.query(sql, [username, password, sex, phone, email, address, age], <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123; <span class="comment">// []是刚才占位符中所要填写的数据，这些数据来源于上方的解构</span></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data.affectedRows == <span class="number">1</span>) &#123; <span class="comment">// data.affectedRows 可以判断是否注册成功</span></span><br><span class="line">            res.send(<span class="string">&#x27;新加板块成功!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>

<h3 id="在根目录app-js中增加下面两条语句配置路由-1"><a href="#在根目录app-js中增加下面两条语句配置路由-1" class="headerlink" title="在根目录app.js中增加下面两条语句配置路由"></a>在根目录app.js中增加下面两条语句配置路由</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">var</span> registerRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/register&#x27;</span>); <span class="comment">// 引入刚才打造好并输出的路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/api&#x27;</span>, registerRouter); <span class="comment">// 使用中间件  api为base url</span></span><br></pre></td></tr></table></figure>

<p>这样我们就做好注册的接口: localhost:3000/api/register</p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 组件通信</title>
    <url>/2021/03/04/vue3/tongxin/</url>
    <content><![CDATA[<h2 id="Vue组件通信"><a href="#Vue组件通信" class="headerlink" title="Vue组件通信"></a>Vue组件通信</h2><ol>
<li>父-&gt;子</li>
<li>子-&gt;父</li>
<li>非父子</li>
<li>跨组件通信</li>
</ol>
<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><ol>
<li>父组件传递给子组件money数据</li>
<li>html: 父组件中的子组件绑定自定义属性 :money=”money”</li>
<li>js: 子组件用props属性接收</li>
<li>html: 子组件就可以使用父组件的money数据</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Father</span>&gt;</span><span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son</span> <span class="attr">:money</span>=<span class="string">&quot;money&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        son &#123;&#123; money &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Father&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#father&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                money: <span class="number">2000</span>,</span><br><span class="line">                phone: <span class="number">13</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Son&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#son&#x27;</span>,</span><br><span class="line">        props: [<span class="string">&#x27;money&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>tips: 属性校验</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// props用法</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">props: [&#x27;money&#x27;] // 只接收不校验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">props: &#123;</span></span><br><span class="line"><span class="comment">    money: Number // 表示我接收到的数据必须是一个Number类型</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">props: &#123;</span></span><br><span class="line"><span class="comment">    money: &#123;</span></span><br><span class="line"><span class="comment">        validator(val) &#123; // 校验函数, validator这个名称是死的</span></span><br><span class="line"><span class="comment">            if (val &lt; 3000) alert(&#x27;钱太少了&#x27;)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="子父组件通信"><a href="#子父组件通信" class="headerlink" title="子父组件通信"></a>子父组件通信</h3><ol>
<li>子组件传递给父组件数据，父组件来接收</li>
<li>html: 父组件中的子组件使用自定义事件【事件名自定义】形式(@get=”setXjk”)，讲父组件方法传递给子组件</li>
<li>js: 子组件设置一个方法(give)执行父组件传递过来的那个自定义事件 </li>
<li>Vue提供了一个 $emit // this.$emit(自定义事件名称,参数)</li>
<li>html: 给子组件按钮绑定这个方法(@click=”give”)</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Father</span>&gt;</span><span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son</span> @<span class="attr">get</span>=<span class="string">&quot;setXjk&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; xjk  &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;give&quot;</span>&gt;</span>发红包<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Father&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#father&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                xjk: <span class="number">500</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">setXjk</span>(<span class="params">hongBao</span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.xjk += hongBao</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Son&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#son&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                hongBao: <span class="number">8888</span>,</span><br><span class="line">                count: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">give</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="comment">// 执行父组件传递过来的那个自定义事件 </span></span><br><span class="line">                <span class="comment">// Vue提供了一个  $emit  </span></span><br><span class="line">                <span class="comment">// this.$emit(自定义事件名称,参数)</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    alert(<span class="string">&#x27;只执行一次，没钱了&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.$emit(<span class="string">&#x27;get&#x27;</span>, <span class="built_in">this</span>.hongBao)</span><br><span class="line">                <span class="built_in">this</span>.count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h3><ol>
<li>案例: 姐姐揍弟弟，弟弟哭</li>
<li>弟弟有一个数据cryFlag和方法setCryFlag</li>
<li>姐姐想要使用弟弟的方法来控制弟弟给的数据</li>
<li>通过共同的父组件，其中父组件的son组件中打一个ref标记，用于父组件获取son组件的方法(ref=”son”)</li>
<li>父组件设置一个kick方法 里面的this.$refs包含son组件的方法(console.log(this.$refs))</li>
<li>父组件的sister组件中绑定自定义属性 :kick=”kick”, sister组件通过props接收</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Father</span>&gt;</span><span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Sister</span> <span class="attr">:kick</span>=<span class="string">&quot;kick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Sister</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son</span> <span class="attr">ref</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;cryFlag&quot;</span>&gt;</span> 呜呜呜 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;sister&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;kick&quot;</span>&gt;</span>揍弟弟<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Father&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#father&#x27;</span>,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">kick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="comment">// console.log(this.$refs);</span></span><br><span class="line">                <span class="built_in">this</span>.$refs.son.setCryFlag()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Son&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#son&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                cryFlag: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">setCryFlag</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.cryFlag = !<span class="built_in">this</span>.cryFlag</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Sister&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#sister&#x27;</span>,</span><br><span class="line">        props: [<span class="string">&#x27;kick&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="跨组件通信"><a href="#跨组件通信" class="headerlink" title="跨组件通信"></a>跨组件通信</h3><ol>
<li>父组件里面有个属性 provide，在里面写数据</li>
<li>子孙组件有个属性 inject ，注入上面给的数据</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Hello</span>&gt;</span><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Father</span>&gt;</span><span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">grand-son</span>&gt;</span><span class="tag">&lt;/<span class="name">grand-son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;grand-son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123; money &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Hello&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#hello&#x27;</span>,</span><br><span class="line">        provide: &#123;</span><br><span class="line">            money: <span class="number">10000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Father&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#father&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Son&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#son&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .component(<span class="string">&#x27;grand-son&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#grand-son&#x27;</span>,</span><br><span class="line">        inject: [<span class="string">&#x27;money&#x27;</span>], <span class="comment">// 注入</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 vue-router</title>
    <url>/2021/03/16/vue3/router/</url>
    <content><![CDATA[<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add vue-router@4</span><br></pre></td></tr></table></figure>

<h3 id="打造路由实例"><a href="#打造路由实例" class="headerlink" title="打造路由实例"></a>打造路由实例</h3><ol>
<li>在src目录下新建router,再新建index.ts</li>
<li>router/index.ts (step 1)<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 1</span></span><br><span class="line"><span class="comment">// 引入createRouter</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li>
<li>在main.ts中引入<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line">createApp(App)</span><br><span class="line">    .use(router)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>在src目录下新建pages文件夹，再新建一些即将打造的路由(home,application,cate,about,list,not-found),里面写组件</li>
<li>createRouter() 中有两个参数<ol>
<li>history  用于选择路由模式<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">路由模式</span><br><span class="line">1. hash模式        比如：  #/home     </span><br><span class="line">    - 兼容性强，ie/其他浏览器</span><br><span class="line">    - 写法很别扭</span><br><span class="line">2. history模式     比如：  /home</span><br><span class="line">    - 新出的，基于html5做出来的，功能强大</span><br><span class="line">    - 缺点</span><br><span class="line">       - 看起来太像后端接口，所以一旦使用history模式就必须和后端配合使用</span><br><span class="line">       - 这家伙看起来也像反向代理标识符，所以切记不能和反向代理标识符一致 </span><br><span class="line">       - 不兼容ie6-8</span><br></pre></td></tr></table></figure></li>
<li>routes   路由表<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">    用于确定一个路由对应一个组件</span><br><span class="line">&#123;</span><br><span class="line">  path: 路由路径    比如： /home</span><br><span class="line">  component：路由渲染的组件</span><br><span class="line">  meta  元数据 用于携带数据，比如做类似： 权限的功能</span><br><span class="line">  redirect  重定向</span><br><span class="line">  alias   别名【小名】</span><br><span class="line">  children   子路由表   /home/hot </span><br><span class="line">  beforeEnter   路由独享守卫，用于判断你是否有权限进入当前路由</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">component后面跟着的组件要使用路由懒加载</span><br><span class="line">1. 写法 </span><br><span class="line">    1. （）=&gt; import()  vue的异步组件</span><br><span class="line">    2. /*webpackChunkName:&#x27;chunkName&#x27;*/ // webpack的代码分割功能</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>router/index.ts  (step 2)<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="comment">// step 2</span></span><br><span class="line"><span class="comment">// 引入createWebHistory</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">    history: createWebHistory(),</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            redirect: <span class="string">&#x27;/home&#x27;</span> <span class="comment">// 重定向到home</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;home&quot; */</span> <span class="string">&#x27;../pages/home/index.vue&#x27;</span>),</span><br><span class="line">            name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;/home/father&#x27;</span>,</span><br><span class="line">                    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;home&quot; */</span> <span class="string">&#x27;../pages/home/far.vue&#x27;</span>),</span><br><span class="line">                    name: <span class="string">&#x27;father&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;/home/son&#x27;</span>,</span><br><span class="line">                    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;home&quot; */</span> <span class="string">&#x27;../pages/home/son.vue&#x27;</span>),</span><br><span class="line">                    name: <span class="string">&#x27;son&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/app&#x27;</span>,</span><br><span class="line">            component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;app1&quot; */</span> <span class="string">&#x27;../pages/application/index.vue&#x27;</span>),</span><br><span class="line">            name: <span class="string">&#x27;app&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/cate&#x27;</span>,</span><br><span class="line">            component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;cate&quot; */</span> <span class="string">&#x27;../pages/cate/index.vue&#x27;</span>),</span><br><span class="line">            name: <span class="string">&#x27;cate&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">            component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;about&quot; */</span> <span class="string">&#x27;../pages/about/index.vue&#x27;</span>),</span><br><span class="line">            name: <span class="string">&#x27;about&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">            component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;list&quot; */</span> <span class="string">&#x27;../pages/list/index.vue&#x27;</span>),</span><br><span class="line">            name: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/:pathMatch(.*)*&#x27;</span>,</span><br><span class="line">            component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;not-found&quot; */</span> <span class="string">&#x27;../pages/not-found/index.vue&#x27;</span>),</span><br><span class="line">            name: <span class="string">&#x27;not-found&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<h4 id="错误路由书写"><a href="#错误路由书写" class="headerlink" title="错误路由书写"></a>错误路由书写</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/:pathMatch(.*)*&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;not-found&quot; */</span> <span class="string">&#x27;../pages/not-found/index.vue&#x27;</span>),</span><br><span class="line">    name: <span class="string">&#x27;not-found&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="一级路由和路由嵌套"><a href="#一级路由和路由嵌套" class="headerlink" title="一级路由和路由嵌套"></a>一级路由和路由嵌套</h3><h4 id="一级路由"><a href="#一级路由" class="headerlink" title="一级路由"></a>一级路由</h4><ol>
<li>在App.vue中</li>
<li>使用router-link(这是导航)</li>
<li>to(声明式跳转链接)</li>
<li>使用router-view(这是视图)<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导航 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;app-nav-list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span> home <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/app&quot;</span>&gt;</span> app <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/cate&quot;</span>&gt;</span> cate <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span> about <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/asd&quot;</span>&gt;</span> 404 <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 视图 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span>&gt;</span></span><br><span class="line">.app-nav-list</span><br><span class="line"><span class="css">  <span class="attribute">display</span> <span class="attribute">flex</span></span></span><br><span class="line"><span class="css">  <span class="attribute">justify-content</span> space-evenly</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span> <span class="number">500px</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><ol>
<li>在src/pages/home/index.vue中</li>
<li>路由表即router文件夹index.ts中 路由要写children等数据<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>home<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    &lt;router-link</span><br><span class="line">      :to=&quot;&#123;</span><br><span class="line">        name: &#x27;father&#x27;,</span><br><span class="line">      &#125;&quot;</span><br><span class="line">      &gt;father&lt;/router-link</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    &lt;router-link</span><br><span class="line">      :to=&quot;&#123;</span><br><span class="line">        name: &#x27;son&#x27;,</span><br><span class="line">      &#125;&quot;</span><br><span class="line">      &gt;son&lt;/router-link</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="路由监听"><a href="#路由监听" class="headerlink" title="路由监听"></a>路由监听</h3></li>
<li>小案例 404的时候上方导航不见</li>
<li>通过navFlag控制导航的销毁与创建</li>
<li>引入useRoute并实例化 const route = useRoute()</li>
<li>watch(()=&gt;route.path,()=&gt;{对应的操作}) 来实现监听路由<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, watch, reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      navFlag: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> route = useRoute();</span><br><span class="line">    watch(</span><br><span class="line">      () =&gt; route.path,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (route.matched[<span class="number">0</span>].path === <span class="string">&quot;/:pathMatch(.*)*&quot;</span>) &#123;</span><br><span class="line">          state.navFlag = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          state.navFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...toRefs(state),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="激活路由"><a href="#激活路由" class="headerlink" title="激活路由"></a>激活路由</h3><ol>
<li>在router-link标签中加active-class属性</li>
<li>切换的时候动态切换类名实现效果<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span> home <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ol>
<li><p>什么是动态路由？</p>
<ol>
<li>url是变化的，但是呢组件用的是同一个，这就是动态路由</li>
</ol>
</li>
<li><p>动态传参</p>
<ol>
<li>我们从一个组件中将数据携带在url上传递到另一个组件中去</li>
</ol>
</li>
<li><p>动态接参</p>
<ol>
<li>我们从url中获取参数，然后拿到参数之后进行使用【作为请求的参数】</li>
</ol>
</li>
<li><p>/about/index.vue中to属性书写对象，name,params,query属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /about/index.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>about<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &lt;router-link</span><br><span class="line">      :to=&quot;&#123;</span><br><span class="line">        name: &#x27;list&#x27;,</span><br><span class="line">        params: &#123;</span><br><span class="line">          id: 1,</span><br><span class="line">        &#125;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          a: 1,</span><br><span class="line">          b: 1,</span><br><span class="line">          title: &#x27;嘻嘻&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;&quot;</span><br><span class="line">      &gt;List&lt;/router-link</span><br><span class="line">    &gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>to中加了params中的id属性，所以要在router文件夹的index中编辑</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/list/:id&#x27;</span>, <span class="comment">// 在list中加/:id </span></span><br><span class="line">  component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;list&quot; */</span> <span class="string">&#x27;../pages/list/index.vue&#x27;</span>),</span><br><span class="line">  name: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>在pages/list/index.vue接收传过来的参数</p>
</li>
<li><p>从vue-router中引入useRouter 并在setup中实例化</p>
</li>
<li><p>创建一个reactive数据接收参数</p>
</li>
<li><p>在挂载阶段，从route.params或者route.query中拿取数据赋值给reactive数据</p>
</li>
<li><p>return</p>
</li>
<li><p>在template中使用数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>list<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; id &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; a &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; b &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; defineComponent, onMounted, reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> route = useRoute();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(route.params.id);</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> state = reactive(&#123;</span></span><br><span class="line"><span class="javascript">      id: <span class="string">&quot;0&quot;</span>,</span></span><br><span class="line"><span class="javascript">      a: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      b: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      title: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="javascript">    onMounted(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line">      state.id = route.params.id;</span><br><span class="line">      state.a = route.query.a;</span><br><span class="line">      state.b = route.query.b;</span><br><span class="line">      state.title = route.query.title;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      ...toRefs(state),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="命令式跳转页面"><a href="#命令式跳转页面" class="headerlink" title="命令式跳转页面"></a>命令式跳转页面</h3><ol>
<li>从vue-router中引入useRouter</li>
<li>router实例中有push/replace方法 里面写路径<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>cate<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toAbout&quot;</span>&gt;</span>命令式toabout<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> router = useRouter();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> toAbout = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      router.push(<span class="string">&quot;/about&quot;</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      toAbout,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="路由的追加、删除、路由是否存在的判断"><a href="#路由的追加、删除、路由是否存在的判断" class="headerlink" title="路由的追加、删除、路由是否存在的判断"></a>路由的追加、删除、路由是否存在的判断</h3><h4 id="路由追加"><a href="#路由追加" class="headerlink" title="路由追加"></a>路由追加</h4><ol>
<li>引入useRouter</li>
<li>使用实例router.addRoute() 里面接收对象，之前怎么写路由就怎么写<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>app<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>路由追加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toNew&quot;</span>&gt;</span>toNew<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> router = useRouter();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(router);</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      router.addRoute(&#123; <span class="comment">// 路由增加</span></span></span><br><span class="line"><span class="javascript">        path: <span class="string">&quot;/new&quot;</span>,</span></span><br><span class="line"><span class="javascript">        component: <span class="function">() =&gt;</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;new&quot; */</span> <span class="string">&quot;../new/index.vue&quot;</span>),</span></span><br><span class="line"><span class="javascript">        name: <span class="string">&quot;new&quot;</span>,</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> toNew = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      router.push(<span class="string">&quot;/new&quot;</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      add,</span><br><span class="line">      toNew,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="路由删除，路由判断"><a href="#路由删除，路由判断" class="headerlink" title="路由删除，路由判断"></a>路由删除，路由判断</h4><ol>
<li>router.removeRoute(‘RouterName’)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.removeRoute(<span class="string">&#x27;new&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>router.hasRoute(‘RouterName’)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.hasRoute(<span class="string">&#x27;new&#x27;</span>) <span class="comment">// 返回布尔值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>app<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>路由追加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toNew&quot;</span>&gt;</span>toNew<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;rm&quot;</span>&gt;</span>删除new<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;has&quot;</span>&gt;</span>判断是否有new<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> router = useRouter();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(router);</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line">      router.addRoute(&#123;</span><br><span class="line"><span class="javascript">        path: <span class="string">&quot;/new&quot;</span>,</span></span><br><span class="line"><span class="javascript">        component: <span class="function">() =&gt;</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;new&quot; */</span> <span class="string">&quot;../new/index.vue&quot;</span>),</span></span><br><span class="line"><span class="javascript">        name: <span class="string">&quot;new&quot;</span>,</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> toNew = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      router.push(<span class="string">&quot;/new&quot;</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> rm = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      router.removeRoute(<span class="string">&quot;new&quot;</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> has = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      router.hasRoute(<span class="string">&quot;new&quot;</span>) ? alert(<span class="string">&quot;yes&quot;</span>) : alert(<span class="string">&quot;no&quot;</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      add,</span><br><span class="line">      toNew,</span><br><span class="line">      rm,</span><br><span class="line">      has,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h3><ol>
<li>安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn add animate.css</span><br></pre></td></tr></table></figure></li>
<li>全局引入,在main.ts书写<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;animate.css&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>进入App.vue</li>
<li>把之前的router-view组件用transtion组件包裹起来</li>
<li>transtion有三个属性    1. mode    2. enter-active-class    3. leave-active-class<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line">&lt;transition</span><br><span class="line">  mode=&quot;out-in&quot;</span><br><span class="line">  enter-active-class=&quot;animate__animated animate__fadeInLeft&quot;</span><br><span class="line">  leave-active-class=&quot;animate__animated animate__fadeOutLeft&quot;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="路由元数据"><a href="#路由元数据" class="headerlink" title="路由元数据"></a>路由元数据</h3><ul>
<li>我们可以在routes中通过meta选项来携带一个数据，这个数据可以用来做很多事情，比如<ul>
<li>头部内容的变化</li>
<li>面包屑导航</li>
</ul>
</li>
</ul>
<ol>
<li>在router文件夹中修改about路由添加meta属性<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;about&quot; */</span> <span class="string">&#x27;../pages/about/index.vue&#x27;</span>),</span><br><span class="line">    name: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    meta: &#123; <span class="comment">// 这是新增的</span></span><br><span class="line">        title: <span class="string">&#x27;这是关于页面&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>进入about组件</li>
<li>引入useroute</li>
<li>route.meta.title使用<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>about<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> </span><br><span class="line">    &lt;router-link</span><br><span class="line">      :to=&quot;&#123;</span><br><span class="line">        name: &#x27;list&#x27;,</span><br><span class="line">        params: &#123;</span><br><span class="line">          id: 1,</span><br><span class="line">        &#125;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          a: 1,</span><br><span class="line">          b: 1,</span><br><span class="line">          title: &#x27;嘻嘻&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;&quot;</span><br><span class="line">      &gt;List&lt;/router-link</span><br><span class="line">    &gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> route = useRoute();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      title: route.meta.title,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="vue-router中小tips"><a href="#vue-router中小tips" class="headerlink" title="vue-router中小tips"></a>vue-router中小tips</h3><ol>
<li>useRoute: 使用数据的时候用它</li>
<li>useRouter: 使用方法的时候用它</li>
<li>createRoute: 创建路由的时候用它</li>
</ol>
<h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><ol>
<li><p>什么是导航守卫</p>
<ol>
<li>导航守卫是vue提供的用于拦截路由的一种方式</li>
<li>类比： 停车场的那个起落杆/保安</li>
</ol>
</li>
<li><p>导航守卫的类型</p>
<ol>
<li>全局导航守卫【3】<ol>
<li>全局前置守卫  beforeEach</li>
<li>全局解析守卫【用法类似全局前置守卫】 beforeResolve</li>
<li>全局后置守卫  afterEach</li>
</ol>
</li>
<li>路由独享守卫【1】 beforeEnter</li>
<li>组件级守卫【3】<ol>
<li>组件内前置守卫  beforeRouteEnter</li>
<li>组件内更新守卫  beforeRouteUpdate</li>
<li>组件内后置守卫  beforeRouteLeave</li>
</ol>
</li>
</ol>
</li>
<li><p>令牌： token</p>
<ol>
<li>token的产生： 登录完成之后，后端会返回给我们</li>
</ol>
</li>
<li><p>提供模拟数据的平台</p>
<ul>
<li><a href="https://www.fastmock.site/#/">fastmock</a></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 vuex</title>
    <url>/2021/03/15/vue3/vuex/</url>
    <content><![CDATA[<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><blockquote>
<p>vuex是vue项目的状态[数据]管理工具，用于获取、存储、操作数据</p>
</blockquote>
<h3 id="vuex构成部分"><a href="#vuex构成部分" class="headerlink" title="vuex构成部分"></a>vuex构成部分</h3><pre><code>1. state 状态
2. actions 动作
3. mutations 动作的下一步，用于修改数据
4. getters 几乎不使用
</code></pre>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>安装 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add vuex@next</span><br></pre></td></tr></table></figure></li>
<li>在src目录下建立store文件夹再创建index.ts</li>
<li>注册store<br> src/main.ts中 use(store)</li>
<li>单独数据块<br> 在store文件夹下创建<ol>
<li>namespaced</li>
<li>state</li>
<li>actions</li>
<li>mutations</li>
</ol>
</li>
<li>src/App.vue<ol>
<li>引入并实例化</li>
<li>获得数据用计算属性，使用方法store.dispatch({type,data})</li>
</ol>
</li>
</ol>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol>
<li><p>store的入口文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> homeStore <span class="keyword">from</span> <span class="string">&#x27;./homeStore&#x27;</span> <span class="comment">// 接下来创建homeStore这个数据块</span></span><br></pre></td></tr></table></figure></li>
<li><p>数据块</p>
<blockquote>
<p>在store文件夹下创建homeStore.ts</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> homeStore = &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>, <span class="comment">// 是否使用命名空间，如果使用的话调用数据前加上仓库名</span></span><br><span class="line">        <span class="comment">// 例:   homeStore/getList</span></span><br><span class="line">    state: &#123; <span class="comment">// 用于存放数据</span></span><br><span class="line">        <span class="comment">// 数据</span></span><br><span class="line">        list: []</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123; <span class="comment">// 给组件提供方法调用</span></span><br><span class="line">        <span class="comment">// 例:</span></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">getList</span>(<span class="params">&#123;commit&#125;,&#123;val&#125;</span>)</span>&#123; </span><br><span class="line">            <span class="comment">// commit为仓库里解构出来的方法，用于将action发送给mutations</span></span><br><span class="line">            <span class="comment">// val为前端组件store.dispatch(&#123;type,data&#125;)的data中解构出来的 </span></span><br><span class="line">            <span class="comment">// 内部书写逻辑</span></span><br><span class="line">            <span class="keyword">const</span> r = <span class="keyword">await</span> api.abcdReq(); <span class="comment">// 假设发个请求</span></span><br><span class="line">            <span class="keyword">if</span>(r) &#123;</span><br><span class="line">                commit(&#123;</span><br><span class="line">                    <span class="keyword">type</span>: <span class="string">&#x27;GET_LIST&#x27;</span>, <span class="comment">// type 书写常量，也是下面mutations中方法的调用名</span></span><br><span class="line">                    payload: r.data <span class="comment">// data随意书写的，主要将r接收来的数据放在负载的payload中</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">GET_LIST</span>(<span class="params">state, &#123; payload &#125;</span>)</span> &#123; </span><br><span class="line">            <span class="comment">// state 为该仓库中的state数据</span></span><br><span class="line">            <span class="comment">// &#123; payload &#125;为上面actions中传递下来的payload并解构</span></span><br><span class="line">            state.list = payload <span class="comment">// 将仓库数据的list修改为payload负载中的值</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> homeStore;</span><br></pre></td></tr></table></figure></li>
<li><p>App.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span> <span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">const</span> store = useStore()  <span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">const</span> list = computed(<span class="function">()=&gt;</span>store.state.homeStore.list) <span class="comment">// 计算属性获取方法</span></span><br><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(&#123;</span><br><span class="line">        type: <span class="string">&#x27;homeStore/getlist&#x27;</span>, <span class="comment">// 如果没用命名空间则不需要homeStore 但不利于管理</span></span><br><span class="line">        val: <span class="string">&#x27;asda&#x27;</span> <span class="comment">// val可以取名</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">//.... 记得return 如果用了script标签setup语法糖则不需要</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 组件笔记</title>
    <url>/2021/03/03/vue3/component/</url>
    <content><![CDATA[<h2 id="VUE组件"><a href="#VUE组件" class="headerlink" title="VUE组件"></a>VUE组件</h2><ol>
<li>了解组件化</li>
<li>了解什么是组件</li>
<li>vue是如何注册组件的</li>
<li>vue组件的嵌套和组合如何实现</li>
<li>v-is</li>
<li>通信</li>
<li>组件过渡动效</li>
<li>组件生命周期</li>
</ol>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>html部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-banner</span>&gt;</span><span class="tag">&lt;/<span class="name">my-banner</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        banner</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;</span><br><span class="line">    components: &#123; <span class="comment">// 使用components进行局部注册</span></span><br><span class="line">        <span class="comment">// 组件名: 组件选项</span></span><br><span class="line">        <span class="string">&#x27;my-banner&#x27;</span>: &#123;</span><br><span class="line">            template: <span class="string">&#x27;#banner&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;my-banner&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#banner&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="vue2和vue3的不同点，"><a href="#vue2和vue3的不同点，" class="headerlink" title="vue2和vue3的不同点，"></a>vue2和vue3的不同点，</h4><pre><code>1. vue3中发现template中可以直接写多个元素 | vue2 中template下的直接子元素有且仅有一个
2. vue3中销毁阶段的钩子函数为beforeUnmount和Unmount | vue2中是beforeDestroy和destroyed
</code></pre>
<h3 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h3><blockquote>
<p>组件嵌套就是将子组件以标签的形式放到父组件template中</p>
</blockquote>
<p>html部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lay-out</span>&gt;</span><span class="tag">&lt;/<span class="name">lay-out</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;lay-out&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        我在上面</span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在lay-out组件中插入lay-inside标签 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lay-inside</span>&gt;</span><span class="tag">&lt;/<span class="name">lay-inside</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;lay-inside&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        我在下面</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="组件嵌套-局部"><a href="#组件嵌套-局部" class="headerlink" title="组件嵌套-局部"></a>组件嵌套-局部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">&#x27;lay-out&#x27;</span>: &#123;</span><br><span class="line">            template: <span class="string">&#x27;#lay-out&#x27;</span>,</span><br><span class="line">            components: &#123;</span><br><span class="line">                <span class="string">&#x27;lay-inside&#x27;</span>: &#123;</span><br><span class="line">                    template: <span class="string">&#x27;#lay-inside&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="组件嵌套-全局"><a href="#组件嵌套-全局" class="headerlink" title="组件嵌套-全局"></a>组件嵌套-全局</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;lay-out&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#lay-out&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .component(<span class="string">&#x27;lay-inside&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#lay-inside&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="组件-组合-插槽"><a href="#组件-组合-插槽" class="headerlink" title="组件-组合-插槽"></a>组件-组合-插槽</h3><h4 id="插槽的基本使用"><a href="#插槽的基本使用" class="headerlink" title="插槽的基本使用"></a>插槽的基本使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lay-out</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- lay-inside组件是作为lay-out组件内容呈现的 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 问题: lay-inside组件显示不出来 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 解决方案: slot插槽 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lay-inside</span>&gt;</span><span class="tag">&lt;/<span class="name">lay-inside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lay-out</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;lay-out&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        我在上面</span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- vue内置组件，用于放置组件的内容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;lay-inside&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        我在下面</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    Vue.createApp(&#123;&#125;)</span><br><span class="line"><span class="javascript">        .component(<span class="string">&#x27;lay-out&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">            template: <span class="string">&#x27;#lay-out&#x27;</span></span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        .component(<span class="string">&#x27;lay-inside&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">            template: <span class="string">&#x27;#lay-inside&#x27;</span></span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        .mount(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><ol>
<li>在#app内的组件中创建template标签 并给它设置指令v-slot:nameVal</li>
<li>在下面template中内部插槽slot 中设置name=”nameVal”</li>
<li>具名插槽是一对一的 上方#app内的标签顺序颠倒都没事</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-txt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是尾部<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是身体<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是头部<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">my-txt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;my-txt&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 插槽的一对一 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    Vue.createApp(&#123;&#125;)</span><br><span class="line"><span class="javascript">        .component(<span class="string">&#x27;my-txt&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">            template: <span class="string">&#x27;#my-txt&#x27;</span></span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        .mount(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><ol>
<li>组件是一个独立的聚合体，那么组件的数据应该由自己来定义，组件内通过data来定义</li>
<li>单向数据绑定，将数据绑定给slot</li>
<li>设置v-slot:nameVal=”scoped”  // scoped是自定义的</li>
<li>渲染数据</li>
</ol>
<p>js部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;my-txt&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#my-txt&#x27;</span>,</span><br><span class="line">        <span class="comment">// 第一步，定义data</span></span><br><span class="line">        data () &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                msg: <span class="string">&#x27;Hello Vue3&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>html部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-txt</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第三步 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;scoped&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 第四步 数据渲染 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; scoped.msg &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">my-txt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;my-txt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第二布: 单向数据绑定，将数据绑定给slot --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="组件的几个常用选项-案例-反向数据"><a href="#组件的几个常用选项-案例-反向数据" class="headerlink" title="组件的几个常用选项(案例:反向数据)"></a>组件的几个常用选项(案例:反向数据)</h4><p>js部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;my-txt&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#my-txt&#x27;</span>,</span><br><span class="line">        data () &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                msg: <span class="string">&#x27;Hello Vue3&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">reverseMsg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.msg = <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            <span class="function"><span class="title">newMsg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                alert(<span class="string">&#x27;数据改变了&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>html部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-txt</span>&gt;</span><span class="tag">&lt;/<span class="name">my-txt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;my-txt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;reverseMsg&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; msg &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; newMsg &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-is"><a href="#v-is" class="headerlink" title="v-is"></a>v-is</h3><h4 id="组件v-is"><a href="#组件v-is" class="headerlink" title="组件v-is"></a>组件v-is</h4><ol>
<li>组件不能违背html基本规则</li>
<li>v-is=”‘’”  (双引号里面接单引号)</li>
</ol>
<p>表格案例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;Hello&gt;&lt;/Hello&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 问题： Hello被踢出去了 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 解决 v-is --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  不正确的：  &lt;tr v-is=&quot;Hello&quot;&gt;&lt;/tr&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-is</span>=<span class="string">&quot;&#x27;my-txt&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;my-txt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>js部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;my-txt&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#my-txt&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="v-is-案例"><a href="#v-is-案例" class="headerlink" title="v-is 案例"></a>v-is 案例</h4><p>做一个用户密码或者手机号验证码的登陆页面</p>
<p>js部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            type: <span class="string">&#x27;user-login&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="built_in">this</span>.type == <span class="string">&#x27;user-login&#x27;</span> ? <span class="string">&#x27;phone-login&#x27;</span> : <span class="string">&#x27;user-login&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;user-login&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#user-login&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .component(<span class="string">&#x27;phone-login&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#phone-login&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>html部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 登陆选择 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- vue提供了一个内置组件component,实现组件的切换 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 他叫动态组件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当我们频繁的切换按钮时，组件在频繁的创建和销毁 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 提高组件的切换速率，我们可以将组件放入缓存 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- vue提供一个内置 keep-alive --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 它可以写两个api</span></span><br><span class="line"><span class="comment">        不写则全部包括</span></span><br><span class="line"><span class="comment">        include 包含</span></span><br><span class="line"><span class="comment">        exclude 排除</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以写成 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;type&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;user-login&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是用户名登陆页<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;phone-login&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是手机号登陆页<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p><a href="/2021/03/04/vue3/tongxin/">组件通信</a></p>
<h3 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h3><ol>
<li>vue提供了一个内置组件: transition</li>
<li>属性mode 表示transition组件的过度的顺序 out-in(一般用这个)/in-out</li>
<li>属性enter-active-class 表示的是过度进入时的过渡效果</li>
<li>属性leave-active-class 表示的是过渡离开的过渡效果</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  mode=&quot;in-out&quot;</span><br><span class="line">  enter-active-class=&quot;animate__animated animate__backInLeft&quot;</span><br><span class="line">  leave-active-class=&quot;animate__animated animate__backOutLeft&quot;</span><br><span class="line">&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/img/lifecycle.png" alt="avatar"></p>
<h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><blockquote>
<p>虚拟DOM在created – beforeMount生成，真实DOM在mounted拿到</p>
</blockquote>
<ol>
<li>beforeCreate()<ol>
<li>该钩子函数表示组件创建前。</li>
<li>初始化事件和生命周期钩子函数</li>
</ol>
</li>
<li>created()<ol>
<li>该钩子函数表示创建结束，</li>
<li>这里我们有了组件。初始化注入【option】并且数据响应式【数据改变，界面改变】处理</li>
</ol>
</li>
<li>beforeMount()<br> 判断组件是否有template选项？<ol>
<li>yes  使用render函数来编译 template 得到虚拟DOM对象模型</li>
<li>no   使用el.innerHTML来代替模板</li>
</ol>
</li>
<li>mounted() <ol>
<li>创建app.$el来代替el 渲染虚拟DOM为真实DOM</li>
</ol>
</li>
<li>mounted案例<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Hello</span>&gt;</span><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里的标签我们称之为  jsx[javascript+xml]  是VDOM的一种简化型写法 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- jsx是对js语法的一种扩展，有了他我们就可以在标签中书写js了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 123 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line">app.component(<span class="string">&#x27;Hello&#x27;</span>,&#123;</span><br><span class="line">  template: <span class="string">&#x27;#hello&#x27;</span>,</span><br><span class="line">  beforeCreate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;挂载-beforeCreate&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;挂载-created&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;挂载-beforeMount&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;挂载-mounted&#x27;</span>)</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>).style.background = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><blockquote>
<p>触发要求: 1. 数据要改变 2. 数据得使用 可以触发多次。updated可以做真实DOM操作</p>
</blockquote>
<ol>
<li>beforeUpdate()<ol>
<li>它表示组件更新前</li>
<li>任务: 用来监听数据改变的</li>
</ol>
</li>
<li>updated()<ol>
<li>它表示组件更新结束了</li>
<li>任务：虚拟DOM渲染生成，并且通过diff算法比对新旧的虚拟DOM,得到一个patch补丁对象【虚拟DOM】，重新将patch补丁对象渲染到页面，也就是说我们又一次可以得到了真实DOM</li>
</ol>
</li>
<li>案例<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Hello</span>&gt;</span><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; count &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Hello&#x27;</span>, &#123;</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                count: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        template: <span class="string">&#x27;#hello&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 上面写了一个方法</span></span><br><span class="line">            <span class="comment">// 点击按钮就数据自增</span></span><br><span class="line">            <span class="comment">// 每次数据改变时触发updated()钩子函数，发送请求</span></span><br><span class="line">            axios(<span class="string">&#x27;http://59.110.226.77:3000/api/category&#x27;</span>)</span><br><span class="line">                .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;res&#x27;</span>, res);</span><br><span class="line">                &#125;)</span><br><span class="line">                .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">Promise</span>.reject(error))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><blockquote>
<p>任选其一beforeUnmount或unmounted，他会自动删除组件的事件、指令、computed、watch，但需要手动删除计时器/定时器、window/document身上事件，清楚第三方实例，释放内存</p>
</blockquote>
<ol>
<li>beforeUnmount()<ol>
<li>它表示组件销毁前</li>
<li>自动销毁组件定义methods/指令/computed/watch</li>
<li>手动操作：<ol>
<li>清除计时器和定时器</li>
<li>清除绑定在window/document身上的事件</li>
<li>清除第三方实例</li>
</ol>
</li>
</ol>
</li>
<li>unmounted() 同上</li>
<li>案例<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;setFlag&quot;</span>&gt;</span>切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Hello</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.createApp(&#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            flag: <span class="literal">true</span> <span class="comment">// v-if可以来控制组件的销毁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">setFlag</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.flag = !<span class="built_in">this</span>.flag</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Hello&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#hello&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 在组件挂载后</span></span><br><span class="line">            <span class="comment">// 设置第三方实例</span></span><br><span class="line">            <span class="comment">// 设置计时器</span></span><br><span class="line">            <span class="comment">// 设置window身上事件resize</span></span><br><span class="line">            <span class="built_in">this</span>.people = <span class="keyword">new</span> People(<span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line">            <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;计时器&#x27;</span>, <span class="built_in">this</span>.people);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;监听浏览器可视窗口尺寸&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">unmounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(&#x27;销毁&#x27;);</span></span><br><span class="line">            <span class="comment">// 销毁后不会清楚第三方实例，计时器，window身上事件</span></span><br><span class="line">            <span class="comment">// 必须手动消除</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.people</span><br><span class="line">            <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer)</span><br><span class="line">            <span class="built_in">window</span>.onresize = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="缓存阶段"><a href="#缓存阶段" class="headerlink" title="缓存阶段"></a>缓存阶段</h4><blockquote>
<p>触发条件: keep-alive[缓存组件] 如果缓存时间过久，可以自动去清楚缓存在deactivated()中设置</p>
</blockquote>
<ol>
<li>activated()<ol>
<li>表示你正在前台显示</li>
</ol>
</li>
<li>deactivated()<ol start="2">
<li>表示你正在后台缓存</li>
</ol>
</li>
<li>案例<br>等待补充…</li>
</ol>
<h4 id="错误处理阶段"><a href="#错误处理阶段" class="headerlink" title="错误处理阶段"></a>错误处理阶段</h4><blockquote>
<p>任务： 父组件捕获子组件的错误，使用另外一个界面来代替错误的子组件，而这个界面我们称呼为 回退UI。 errorCaptured 写在父组件中</p>
</blockquote>
<ol>
<li>errorCaptured(error, instance, info){}<ol>
<li>error 错误 instance 组件 info 具体信息</li>
</ol>
</li>
<li>案例<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Father</span>&gt;</span><span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span> 回退UI -- 您的网络有延迟，请重试 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        son</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Father&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#father&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                flag: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">errorCaptured</span>(<span class="params">error, instance, info</span>)</span> &#123; </span><br><span class="line">            <span class="comment">// 写在父组件中</span></span><br><span class="line">            <span class="comment">// 如果子组件抛出错误会触发</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;触发&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (error) &#123; <span class="comment">// 如果错误存在的话</span></span><br><span class="line">                <span class="built_in">this</span>.flag = <span class="literal">true</span> <span class="comment">// 改变flag从而改变页面</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Son&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#son&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>) <span class="comment">// 在挂载阶段仍出个自定义错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="虚拟DOM跟踪阶段"><a href="#虚拟DOM跟踪阶段" class="headerlink" title="虚拟DOM跟踪阶段"></a>虚拟DOM跟踪阶段</h4><ol>
<li>renderTracked()<ol>
<li>触发的操作是get</li>
<li>挂载的虚拟DOM和更新阶段虚拟DOM都会被追踪到</li>
</ol>
</li>
<li>renderTriggered()<ol>
<li>触发的操作是set</li>
<li>更新阶段虚拟DOM都会被追踪到</li>
</ol>
</li>
<li>案例<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Hello</span>&gt;</span><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; count &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.createApp(&#123;&#125;)</span><br><span class="line">    .component(<span class="string">&#x27;Hello&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;#hello&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                count: <span class="number">1</span>,</span><br><span class="line">                list: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.count++ <span class="comment">// 这将导致renderTriggered调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">renderTracked</span>(<span class="params">&#123; key, target, type &#125;</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;key&#x27;</span>, key);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;target&#x27;</span>, target);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;type&#x27;</span>, type);</span><br><span class="line">            <span class="comment">// 当组件第一次渲染时，这将被记录下来</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">renderTriggered</span>(<span class="params">&#123; key, target, type &#125;</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;key&#x27;</span>, key);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;target&#x27;</span>, target);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;type&#x27;</span>, type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Web 前端面试总结</title>
    <url>/2021/04/01/webfrontend/</url>
    <content><![CDATA[<h3 id="注册登录是怎么实现的"><a href="#注册登录是怎么实现的" class="headerlink" title="注册登录是怎么实现的"></a>注册登录是怎么实现的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.登陆注册要做成受控组件，组件定义state，和表单绑定</span><br><span class="line">	</span><br><span class="line">2.redux-saga调用数据请求，发送action修改数据，</span><br><span class="line">  useEffect中dispatch发送数据请求，后端比对用户名是否重复，返回state</span><br><span class="line"></span><br><span class="line">3.前端根据返回的信息成功跳转登陆页</span><br><span class="line"></span><br><span class="line">4.登陆发送数据请求，数据库对比用户名密码是否正确, 根据后端返回的结果进入首页</span><br><span class="line"></span><br><span class="line">5.setCookie将用户登录名密码token存cookie中   通过JWT(Json web token)</span><br><span class="line"></span><br><span class="line">6.免密登陆  getCookie获取token    发给后端对比    根据返回结果是否自动登陆</span><br><span class="line"></span><br><span class="line">7.注册通过Ant  Design ，validator中进行表单正则的验证</span><br><span class="line"></span><br><span class="line">8.用户体验  注册的时候跳转其他页面的时候给用户提示是否需要跳转，避免因为跳转后导致注册信息没有了   </span><br><span class="line">  用组件内后置守卫做</span><br><span class="line">  如果输入框都没有填信息,不拦截跳转如果用户输入信息,弹窗提示,点确定,跳转,点取消,不跳转</span><br></pre></td></tr></table></figure>

<h3 id="项目中遇到什么困难-怎么解决的"><a href="#项目中遇到什么困难-怎么解决的" class="headerlink" title="项目中遇到什么困难,怎么解决的?"></a>项目中遇到什么困难,怎么解决的?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.react中配置二级路由   地址变化  但是界面不更新    </span><br><span class="line">	使用dva&#x2F;router中的withRouter高阶组件解决的</span><br><span class="line">	</span><br><span class="line">2.图表联动怎么实现</span><br><span class="line">	我们只需要把当前被选中图表的事件，直接发给其他图表即可，然后判断被选中的图表是哪个作为区分</span><br><span class="line">	onTouchEvent(event)普通事件传递</span><br><span class="line">	  </span><br><span class="line">3.产品经理要求智能匹配产品 </span><br><span class="line">	找网上类似功能的网站  查看源码  和主管讨论</span><br><span class="line">	需要一个设计一个投资习惯和风险承受能力测试,</span><br><span class="line">	从后端获取这个客户测试的结果   以及客户平常投资的习惯   生成不同的关键字</span><br><span class="line">	根据关键字从数据库中匹配产品   展示界面</span><br><span class="line"></span><br><span class="line">4.后台管理系统遇到遇到什么奇葩的需求</span><br></pre></td></tr></table></figure>

<h3 id="后台管理系统和普通App面向用户的区别"><a href="#后台管理系统和普通App面向用户的区别" class="headerlink" title="后台管理系统和普通App面向用户的区别"></a>后台管理系统和普通App面向用户的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toB和toC的项目</span><br><span class="line"></span><br><span class="line">面向企业内部和面向用户的项目的区别</span><br><span class="line"></span><br><span class="line">后台管理系统权限比较细   App高并发比较多  做性能优化</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\d 匹配数字  \D 匹配非数字  \w 匹配数字字母下划线 \W 匹配非数字字母下划线  </span><br><span class="line">\n 匹配一个换行符 \s 匹配任何不可见字符包括空格、制表符、换页符等等  \S 匹配任何可见字符</span><br><span class="line">^ 匹配输入字行首   $匹配输入行尾 *(0到多次)匹配前面的子表达式任意次   </span><br><span class="line">+(1到多) 匹配前面的子表达式一次或多次(大于等于1次）</span><br><span class="line">?(0或1)匹配前面的子表达式零次或一次 </span><br><span class="line">&#123;n&#125;n是一个非负整数，匹配确定的n次</span><br><span class="line">&#123;n,&#125;n是一个非负整数。至少匹配n次</span><br></pre></td></tr></table></figure>

<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</span><br><span class="line">创建步骤：创建xhr对象-&gt;配置Ajax请求地址通过open方法-&gt;发送请求通过send方法-&gt;监听请求，接收响应</span><br><span class="line">&#x2F;&#x2F;1：创建Ajax对象</span><br><span class="line">var xhr &#x3D; window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);&#x2F;&#x2F; 兼容IE6及以下版本</span><br><span class="line">&#x2F;&#x2F;2：配置 Ajax请求地址</span><br><span class="line">xhr.open(&#39;get&#39;,&#39;index.xml&#39;,true);</span><br><span class="line">&#x2F;&#x2F;3：发送请求</span><br><span class="line">xhr.send(null); &#x2F;&#x2F; 严谨写法</span><br><span class="line">&#x2F;&#x2F;4:监听请求，接受响应</span><br><span class="line">xhr.onreadysatechange&#x3D;function()&#123;</span><br><span class="line">     if(xhr.readySate&#x3D;&#x3D;4&amp;&amp;xhr.status&#x3D;&#x3D;200 || xhr.status&#x3D;&#x3D;304)</span><br><span class="line">          console.log(xhr.responseXML)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="js-延迟加载的方式"><a href="#js-延迟加载的方式" class="headerlink" title="js 延迟加载的方式"></a>js 延迟加载的方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class="line">我了解到的几种方式是：</span><br><span class="line"></span><br><span class="line">1、将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class="line">2、给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class="line">3、给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class="line">4、动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure>

<h3 id="模块化开发的理解"><a href="#模块化开发的理解" class="headerlink" title="模块化开发的理解"></a>模块化开发的理解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，</span><br><span class="line">所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class="line"></span><br><span class="line">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，</span><br><span class="line">但是这种方式容易造成全局变量的污染，并且模块间没有联系。</span><br><span class="line"></span><br><span class="line">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，</span><br><span class="line">但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class="line"></span><br><span class="line">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure>

<h3 id="js-的几种模块规范"><a href="#js-的几种模块规范" class="headerlink" title="js 的几种模块规范"></a>js 的几种模块规范</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js 中现在比较成熟的有四种模块加载方案：</span><br><span class="line"></span><br><span class="line">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class="line"></span><br><span class="line">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class="line"></span><br><span class="line">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class="line"></span><br><span class="line">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</span><br></pre></td></tr></table></figure>

<h3 id="AMD和CMD规范的区别？"><a href="#AMD和CMD规范的区别？" class="headerlink" title="AMD和CMD规范的区别？"></a>AMD和CMD规范的区别？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">它们之间的主要区别有两个方面。</span><br><span class="line">第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</span><br><span class="line">第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句</span><br><span class="line">的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</span><br></pre></td></tr></table></figure>

<h3 id="ES6模块与CommonJS-模块、AMD、CMD的差异"><a href="#ES6模块与CommonJS-模块、AMD、CMD的差异" class="headerlink" title="ES6模块与CommonJS 模块、AMD、CMD的差异"></a>ES6模块与CommonJS 模块、AMD、CMD的差异</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.CommonJS 模块输出的是一个值的拷贝，</span><br><span class="line">ES6 模块输出的是值的引用。</span><br><span class="line">CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</span><br><span class="line">ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</span><br><span class="line">2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</span><br><span class="line">而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</span><br></pre></td></tr></table></figure>

<h3 id="requireJS的核心原理"><a href="#requireJS的核心原理" class="headerlink" title="requireJS的核心原理"></a>requireJS的核心原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数</span><br></pre></td></tr></table></figure>

<h3 id="js的原理-运行机制"><a href="#js的原理-运行机制" class="headerlink" title="js的原理(运行机制)"></a>js的原理(运行机制)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先js是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</span><br><span class="line">在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</span><br><span class="line"></span><br><span class="line">所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</span><br><span class="line">同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</span><br><span class="line">异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有等主线程任务执行完毕，&quot;任务队列&quot;开始通知主线程，请求执行任务，该任务才会进入主线程执行。</span><br><span class="line"></span><br><span class="line">当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</span><br><span class="line">任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</span><br><span class="line">当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</span><br><span class="line"></span><br><span class="line">异步运行机制如下：</span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。</span><br><span class="line">	只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。</span><br><span class="line">	那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br></pre></td></tr></table></figure>

<h3 id="arguments-的对象"><a href="#arguments-的对象" class="headerlink" title="arguments 的对象"></a>arguments 的对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，</span><br><span class="line">我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，</span><br><span class="line">如：forEach、reduce、filter和map。</span><br><span class="line"></span><br><span class="line">我们可以使用Array.prototype.slice将arguments对象转换成一个数组。</span><br><span class="line"></span><br><span class="line">Array.prototype.slice.call(arguments)     </span><br></pre></td></tr></table></figure>

<h3 id="V8-引擎的垃圾回收机制"><a href="#V8-引擎的垃圾回收机制" class="headerlink" title="V8 引擎的垃圾回收机制"></a>V8 引擎的垃圾回收机制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v8的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class="line">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class="line">新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge(斯盖V橘) 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class="line">（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</span><br><span class="line">（2）如果对象不存活，则释放对象的空间。</span><br><span class="line">（3）最后将 From 空间和 To 空间角色进行交换。</span><br><span class="line">新生代对象晋升到老生代有两个条件：</span><br><span class="line">（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</span><br><span class="line">（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</span><br><span class="line"></span><br><span class="line">老生代采用了标记清除法和标记压缩法。</span><br><span class="line">标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class="line">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收机制的两种方法"><a href="#垃圾回收机制的两种方法" class="headerlink" title="垃圾回收机制的两种方法"></a>垃圾回收机制的两种方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。</span><br><span class="line"></span><br><span class="line">1、标记清除</span><br><span class="line">　　这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</span><br><span class="line">　　垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</span><br><span class="line"></span><br><span class="line">2、引用计数</span><br><span class="line">　　另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</span><br></pre></td></tr></table></figure>

<h3 id="会造成内存泄漏的操作"><a href="#会造成内存泄漏的操作" class="headerlink" title="会造成内存泄漏的操作"></a>会造成内存泄漏的操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.意外的全局变量</span><br><span class="line">2.被遗忘的计时器或回调函数</span><br><span class="line">3.脱离 DOM 的引用</span><br><span class="line">4.闭包</span><br><span class="line"></span><br><span class="line">第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class="line">第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</span><br><span class="line">第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</span><br><span class="line">第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</span><br></pre></td></tr></table></figure>

<h3 id="ECMAScript-ES"><a href="#ECMAScript-ES" class="headerlink" title="ECMAScript(ES)"></a>ECMAScript(ES)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ECMAScript 是编写脚本语言的标准，ECMA（European Computer Manufacturers Association）规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。</span><br><span class="line">javaScript &#x3D; ECMAScript + DOM + BOM</span><br></pre></td></tr></table></figure>

<h3 id="ES2015-ES6-新特性"><a href="#ES2015-ES6-新特性" class="headerlink" title="ES2015(ES6)新特性"></a>ES2015(ES6)新特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">块作用域</span><br><span class="line">类</span><br><span class="line">箭头函数</span><br><span class="line">模板字符串</span><br><span class="line">对象解构</span><br><span class="line">Promise</span><br><span class="line">模块</span><br><span class="line">Symbol</span><br><span class="line">代理（proxy）Set</span><br><span class="line">函数默认参数</span><br><span class="line">rest</span><br><span class="line">扩展运算符</span><br><span class="line">数组和对象的扩展</span><br></pre></td></tr></table></figure>

<h3 id="ES2016-ES7-新特性"><a href="#ES2016-ES7-新特性" class="headerlink" title="ES2016(ES7)新特性"></a>ES2016(ES7)新特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">求幂运算符（**）</span><br><span class="line">                (因颗录此)</span><br><span class="line">Array.prototype.includes()方法</span><br><span class="line">	数组原型的方法,查找一个数值是否在数组中，只能判断一些简单类型的数据，对于复杂类型的数据无法判断。</span><br><span class="line">	该方法接受两个参数，分别是查询的数据和初始的查询索引值。</span><br></pre></td></tr></table></figure>

<h3 id="ES2017-ES8-新特性"><a href="#ES2017-ES8-新特性" class="headerlink" title="ES2017(ES8)新特性"></a>ES2017(ES8)新特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async  await</span><br><span class="line"></span><br><span class="line">函数参数列表结尾允许逗号</span><br><span class="line">	es2017允许函数对象的定义调用时参数可以加入尾逗号，以及json对象array对象都允许</span><br><span class="line">	</span><br><span class="line">Object.values()</span><br><span class="line">	values: [obj]，返回obj自身可枚举属性的属性值的集合</span><br><span class="line">	   (安吹斯)</span><br><span class="line">Object.entries()</span><br><span class="line">	entries：[obj], 与values类似，返回的一个2元素的数组</span><br><span class="line">	   </span><br><span class="line">Object.getOwnPropertyDescriptors()</span><br><span class="line">	getOwnpropertyDescriptors: [obj]，返回obj对象的属性描述符</span><br><span class="line">	(get 哦 泼破踢 迪斯亏不踢斯)</span><br><span class="line">String padding: </span><br><span class="line">	padStart()和padEnd()，填充字符串达到当前长度</span><br><span class="line">	在字符串首位开始添加string直到满足length为止并返回新的字符串</span><br><span class="line">	</span><br><span class="line">ShareArrayBuffer和Atomics对象，用于从共享内存位置读取和写入</span><br><span class="line">(夏尔 啊锐 八法儿)	 (啊偷没此)</span><br></pre></td></tr></table></figure>

<h3 id="ES2018-ES9-新特性"><a href="#ES2018-ES9-新特性" class="headerlink" title="ES2018(ES9)新特性"></a>ES2018(ES9)新特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">异步迭代</span><br><span class="line">Promise.finally()</span><br><span class="line">		(饭的嘞)</span><br><span class="line">Rest&#x2F;Spread 属性</span><br><span class="line">(锐斯特)(斯破锐的)</span><br><span class="line">正则表达式命名捕获组（Regular Expression Named Capture Groups）</span><br><span class="line">正则表达式反向断言（lookbehind）</span><br><span class="line">正则表达式dotAll模式 </span><br><span class="line">正则表达式 Unicode 转义  </span><br><span class="line">		 (右内扣的)</span><br><span class="line">非转义序列的模板字符串</span><br></pre></td></tr></table></figure>

<h3 id="ES2019-ES10-新特性"><a href="#ES2019-ES10-新特性" class="headerlink" title="ES2019(ES10)新特性"></a>ES2019(ES10)新特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</span><br><span class="line">更加友好的JSON.stringify</span><br><span class="line">新增了Array的flat()方法和flatMap()方法</span><br><span class="line">新增了String的trimStart()方法和trimEnd()方法</span><br><span class="line">Object.fromEntries()</span><br><span class="line">Symbol.prototype.description</span><br><span class="line">String.prototype.matchAll</span><br><span class="line">Function.prototype.toString()现在返回精确字符，包括空格和注释</span><br><span class="line">简化try&#123;&#125; catch&#123;&#125;,修改catch绑定</span><br><span class="line">新的基本数据类型BigInt</span><br><span class="line">globalThis</span><br><span class="line">import()</span><br><span class="line">Legacy RegEx</span><br><span class="line">私有的实例方法和访问器</span><br></pre></td></tr></table></figure>

<h3 id="ES2020-ES11-新特性"><a href="#ES2020-ES11-新特性" class="headerlink" title="ES2020(ES11)新特性"></a>ES2020(ES11)新特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">私有变量</span><br><span class="line">	ES11在类中新增私有变量控制符#，在内部变量或者函数前添加一个hash符号#，</span><br><span class="line">	可以将它们设置为私有属性，只能在类的内部可以使用。</span><br><span class="line">空值合并运算符</span><br><span class="line">	空值合并操作符就是 ?? :如果左侧的值为null或者undefined就返回左侧的值，如果没有就返回右侧的值</span><br><span class="line">可选链操作符</span><br><span class="line">	可选链操作符 (?.) :如果左侧表达式有值，就会继续访问右侧的字段</span><br><span class="line">BigInt</span><br><span class="line">	使用BigInt的方式有两种：</span><br><span class="line">		1.在数字后面加n</span><br><span class="line">		2.使用BigInt函数</span><br><span class="line">动态导入</span><br><span class="line"></span><br><span class="line">globalThis</span><br><span class="line">	提供一种标准化的方式去访问全局对象，可以在任意上下文中获取全局对象自身，并且不用担心环境的问题</span><br><span class="line">Promise.all缺陷与Promise.allSettled</span><br><span class="line">	promise.all可以并发执行异步任务,如果其中某个任务执行出现了异常，所有任务都会over，Promise会直接进入reject状态</span><br><span class="line">	使用Promise.allSettled，它会创建一个新的promise，在所有promise完成后返回一个包含每个promise结果的数组</span><br></pre></td></tr></table></figure>

<h3 id="var-let和const的区别"><a href="#var-let和const的区别" class="headerlink" title="var,let和const的区别"></a>var,let和const的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.var声明的变量会挂载在window上，而let和const声明的变量不会：</span><br><span class="line">2.var声明变量存在变量提升，let和const不存在变量提升</span><br><span class="line">3.let和const声明形成块作用域</span><br><span class="line">4.同一作用域下let和const不能声明同名变量，而var可以</span><br><span class="line"></span><br><span class="line">const  </span><br><span class="line">	一旦声明必须赋值,不能使用null占位。</span><br><span class="line">	声明后不能再修改</span><br><span class="line">	如果声明的是复合类型数据，可以修改其属性</span><br><span class="line"></span><br><span class="line">暂存死区</span><br><span class="line">var a &#x3D; 100;</span><br><span class="line">if(1)&#123;</span><br><span class="line">    a &#x3D; 10;</span><br><span class="line">    &#x2F;&#x2F;在当前块作用域中存在a使用let&#x2F;const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class="line">    &#x2F;&#x2F; 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class="line">    let a &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="var和let在for循环的一些不同表现"><a href="#var和let在for循环的一些不同表现" class="headerlink" title="var和let在for循环的一些不同表现"></a>var和let在for循环的一些不同表现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在var中执行的时候：	</span><br><span class="line">	因为var是没有块级作用域的，所以在for循环中声明的i会存在于test()函数作用域中。</span><br><span class="line">	每一次for循环就会声明一次i，但后面声明的变量会覆盖前面声明的变量。</span><br><span class="line">在let中执行的时候：</span><br><span class="line">	因为块级作用域的原因，let声明的i都会存在于for块级作用域中，每一次for循环都会生成一个块级作用域。</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">箭头函数表达式的语法比函数表达式更简洁</span><br><span class="line"></span><br><span class="line">箭头函数没有自己的this值。箭头函数里的this指向的是父级的this. </span><br><span class="line"></span><br><span class="line">箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</span><br><span class="line"></span><br><span class="line">在箭头函数版本中，当只有一个表达式或值需要返回，我们只需要()括号，</span><br><span class="line">不需要 return 语句，箭头函数就会有一个隐式的返回。</span><br><span class="line"></span><br><span class="line">如果我们在一个箭头函数中有一个参数，则可以省略括号。</span><br><span class="line"></span><br><span class="line">箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。</span><br><span class="line">相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。</span><br></pre></td></tr></table></figure>

<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。</span><br><span class="line"></span><br><span class="line">在ES5版本中，我们需要添加\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。</span><br><span class="line"></span><br><span class="line">在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用&#96;+&#96;运算符。</span><br><span class="line">在模板字符串s中，我们可以使用$&#123;expr&#125;嵌入一个表达式，这使其比 ES5 版本更整洁。</span><br></pre></td></tr></table></figure>

<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象解构是从对象或数组中获取或提取值的一种新的、更简洁的方法</span><br><span class="line">我们还可以为属性取别名</span><br><span class="line">let &#123; firstName: fName, position &#125; &#x3D; employee;</span><br><span class="line">当然如果属性值为 undefined 时，我们还可以指定默认值</span><br><span class="line">let &#123; firstName &#x3D; &quot;Mark&quot; &#125; &#x3D; employee;</span><br></pre></td></tr></table></figure>

<h3 id="Set及应用场景"><a href="#Set及应用场景" class="headerlink" title="Set及应用场景"></a>Set及应用场景</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、创建Set对象实例</span><br><span class="line">Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用</span><br><span class="line">1.构造函数	 	   (伊特波)</span><br><span class="line">	语法：new Set([iterable])</span><br><span class="line">	参数：iterable 如果传递一个可迭代对象，它的所有元素将被添加到新的Set中；</span><br><span class="line">		 如果不指定此参数或其值为null，则新的 Set为空</span><br><span class="line"></span><br><span class="line">二、Set实例属性</span><br><span class="line">	size属性将会返回Set对象中元素的个数</span><br><span class="line"></span><br><span class="line">三、Set实例方法</span><br><span class="line">1.add() 方法用来向一个 Set 对象的末尾添加一个指定的值</span><br><span class="line">	语法：mySet.add(value)</span><br><span class="line">	参数：value 必需，需要添加到 Set 对象的元素的值</span><br><span class="line">2.delete() 方法可以从一个 Set 对象中删除指定的元素</span><br><span class="line">	语法：mySet.delete(value)</span><br><span class="line">	参数：value 将要删除的元素</span><br><span class="line">	返回值：成功删除返回 true，否则返回 false</span><br><span class="line">3.clear() 方法用来清空一个 Set 对象中的所有元素</span><br><span class="line">	语法：mySet.clear()</span><br><span class="line">4.has() 方法返回一个布尔值来指示对应的值value是否存在Set对象中</span><br><span class="line">	语法：mySet.has(value)</span><br><span class="line">	参数：value 必须，是否存在于Set的值</span><br><span class="line">	返回值：如果指定的值（value）存在于Set对象当中，返回true; 否则返回 false</span><br><span class="line">5.entries() (安吹斯)</span><br><span class="line">	语法：mySet.entries()</span><br><span class="line">	返回值：一个新的包含 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，</span><br><span class="line">		  迭代器 对象元素的顺序即集合对象中元素插入的顺序</span><br><span class="line">6.values()</span><br><span class="line">	语法：mySet.values() 或者 mySet.keys()</span><br><span class="line">	返回值：返回一个 Iterator(因特瑞特) 对象，这个对象以插入Set对象的顺序包含了原 Set 对象里的每个元素</span><br><span class="line">7.forEach()</span><br><span class="line">	语法：mySet.forEach(callback[, thisArg]) (this傲歌)</span><br><span class="line">	参数：callback 每个元素都会执行的函数</span><br><span class="line">     	 thisArg 当执行callback函数时候，可以当作this来使用</span><br><span class="line">5、什么是WeakSet()？</span><br><span class="line">和Set结构类似，也是不重复的值的集合，但WeakSet的成员只能是对象(null 除外)。</span><br><span class="line">而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</span><br><span class="line"></span><br><span class="line">应用场景:</span><br><span class="line">1、简单数组去重</span><br><span class="line">2、JSON数组去重</span><br><span class="line">	JSON数组是比较常见的一种数据结构，形如[&#123;…&#125;,…&#123;…&#125;]</span><br><span class="line">	假如你需要统计某个属性中不同的值。</span><br><span class="line">	step1:先使用.map将JSON数组变成简单数组，然后用set执行去重</span><br><span class="line">	step2: 由于生成的Set属于可迭代对象，所以可以使用数组解构符进行解构</span><br><span class="line">3、二维数组去重</span><br><span class="line">	我们可以将Set用作存储每项的唯一值，结合reduce进行对比，得出无重复的项目。</span><br><span class="line">	当然，上面的代码缺点还是不少的。因为只是简单地将其转变成字符串作为对比的键，</span><br><span class="line">	所以不能区分[1,2]、[‘1’ ,‘2’]、[‘1,2’]等子数组。</span><br><span class="line">4、数组之间的对比</span><br><span class="line">	Set的特性不单单可以可以用于单数组，对于数组之间的比较也是十分在行。</span><br><span class="line"></span><br><span class="line">什么是WeakSet()？</span><br><span class="line">	和Set结构类似，也是不重复的值的集合，但WeakSet的成员只能是对象。</span><br><span class="line"></span><br><span class="line">WeakSet的API：</span><br><span class="line">	add() 	 &#x2F;&#x2F;增</span><br><span class="line">	delete() &#x2F;&#x2F;删</span><br><span class="line">	has() 	 &#x2F;&#x2F;是否存在</span><br><span class="line">	</span><br><span class="line">为什么WeakSet不可遍历？</span><br><span class="line">	因为WeakSet的成员都是弱引用，随时可能消失，成员是不稳定的。</span><br><span class="line"></span><br><span class="line">WeakSet的用处：</span><br><span class="line">	使用ws储存DOM节点，就不用担心节点从文档移除时，会引发内存泄漏(即在被移除的节点上绑定的click等事件)。</span><br></pre></td></tr></table></figure>

<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”</span><br></pre></td></tr></table></figure>

<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。</span><br><span class="line">函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。</span><br><span class="line">函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先高阶函数肯定是函数，不同的是输入的参数和返回的值这两项中的一项必须是函数才能叫高阶函数。</span><br><span class="line">这个问题在回答的时候可以稍微拓展一下，介绍一下常用的的高阶函数，</span><br><span class="line">比如：map、flatMap、filter、reduce、fold。</span><br></pre></td></tr></table></figure>

<h3 id="为什么函数被称为一等公民"><a href="#为什么函数被称为一等公民" class="headerlink" title="为什么函数被称为一等公民"></a>为什么函数被称为一等公民</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:</span><br><span class="line"></span><br><span class="line">赋值（var func &#x3D; function()&#123;&#125;）、</span><br><span class="line">传参(function func(x,callback)&#123;callback();&#125;)、</span><br><span class="line">返回(function()&#123;return function()&#123;&#125;&#125;)，</span><br><span class="line"></span><br><span class="line">这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)(因斯疼斯)。这样的多重身份让JavaScript的函数变得非常重要。</span><br><span class="line">									</span><br></pre></td></tr></table></figure>

<h3 id="new操作符的实现"><a href="#new操作符的实现" class="headerlink" title=". new操作符的实现"></a>. new操作符的实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、创建一个空对象 &#123;&#125;</span><br><span class="line">2、将构造函数中的this指向新创建的对象 (原型链)</span><br><span class="line">	obj.__proto__ &#x3D; Dog.prototype &#x2F;&#x2F; 设置原型链</span><br><span class="line">3、链接该对象到另一个对象 __proto__</span><br><span class="line">4、如果该函数没有返回对象，则返回this</span><br></pre></td></tr></table></figure>

<h3 id="回调函数？回调函数有什么缺点"><a href="#回调函数？回调函数有什么缺点" class="headerlink" title="回调函数？回调函数有什么缺点"></a>回调函数？回调函数有什么缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回调函数是一个匿名函数，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。可以让异步代码同步执行。</span><br><span class="line">回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）</span><br></pre></td></tr></table></figure>

<h3 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class="line">实现 instanceof：</span><br><span class="line"></span><br><span class="line">首先获取类型的原型</span><br><span class="line">然后获得对象的原型</span><br><span class="line">然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</span><br><span class="line"></span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  let prototype &#x3D; right.prototype</span><br><span class="line">  left &#x3D; left.__proto__</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (left &#x3D;&#x3D;&#x3D; null || left &#x3D;&#x3D;&#x3D; undefined)</span><br><span class="line">      return false</span><br><span class="line">    if (prototype &#x3D;&#x3D;&#x3D; left)</span><br><span class="line">      return true</span><br><span class="line">    left &#x3D; left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</span><br><span class="line">1、单例模式</span><br><span class="line">2、工厂模式</span><br><span class="line">3、观察者模式</span><br><span class="line">4、代理模式</span><br><span class="line">5、策略模式</span><br><span class="line">6、迭代器模式</span><br><span class="line"></span><br><span class="line">单例模式（Singleton Pattern）</span><br><span class="line">	单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。</span><br><span class="line">	</span><br><span class="line">工厂模式</span><br><span class="line">	工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</span><br><span class="line">使用场景：如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</span><br><span class="line">class Product &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">    init() &#123;</span><br><span class="line">        console.log(&#39;init&#39;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">class Factory &#123;</span><br><span class="line">    create(name) &#123;</span><br><span class="line">        return new Product(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; use</span><br><span class="line">let factory &#x3D; new Factory()</span><br><span class="line">let p &#x3D; factory.create(&#39;p1&#39;)</span><br><span class="line">p.init()</span><br><span class="line">https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;6844904200917221389#heading-81  </span><br></pre></td></tr></table></figure>

<h3 id="js的基本数据类型、值是如何存储的"><a href="#js的基本数据类型、值是如何存储的" class="headerlink" title="js的基本数据类型、值是如何存储的"></a>js的基本数据类型、值是如何存储的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JavaScript一共有8种数据类型</span><br><span class="line">7种基本数据类型：</span><br><span class="line">Undefined、Null、Boolean、Number、String、Symbol(es6新增，表示独一无二的值)和BigInt(es10新增)</span><br><span class="line"></span><br><span class="line">1种引用数据类型</span><br><span class="line">Object（Object本质上是由一组无序的名值对组成的）。</span><br><span class="line">里面包含 function、Array、Date等。</span><br><span class="line"></span><br><span class="line">JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。</span><br><span class="line">原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class="line">引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure>

<h3 id="amp-amp-、-和-运算符"><a href="#amp-amp-、-和-运算符" class="headerlink" title="&amp;&amp; 、||和!! 运算符"></a>&amp;&amp; 、||和!! 运算符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;&amp; 叫逻辑与，在其操作数中找到第一个虚值表达式并返回它，如果没有找到任何虚值表达式，则返回最后一个真值表达式。它采用短路来防止不必要的工作。</span><br><span class="line">|| 叫逻辑或，在其操作数中找到第一个真值表达式并返回它。这也使用了短路来防止不必要的工作。在支持 ES6 默认函数参数之前，它用于初始化函数中的默认参数值。</span><br><span class="line">!! 运算符可以将右侧的值强制转换为布尔值，这也是将值转换为布尔值的一种简单方法</span><br></pre></td></tr></table></figure>

<h3 id="js的数据类型的转换"><a href="#js的数据类型的转换" class="headerlink" title="js的数据类型的转换"></a>js的数据类型的转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 JS 中类型转换只有三种情况，分别是：</span><br><span class="line"></span><br><span class="line">转换为布尔值（调用Boolean()方法）</span><br><span class="line">转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class="line">转换为字符串（调用.toString()或者String()方法）</span><br></pre></td></tr></table></figure>

<h3 id="js-内置对象"><a href="#js-内置对象" class="headerlink" title="js 内置对象"></a>js 内置对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js 中的内置对象主要指的是</span><br><span class="line">在程序执行前存在全局作用域里的由 js定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。</span><br><span class="line">一般我们经常用到的如全局变量值 NaN、undefined，</span><br><span class="line">全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，</span><br><span class="line">还有提供数学计算的单体内置对象如 Math 对象。</span><br></pre></td></tr></table></figure>

<h3 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class="line">undefined 代表的含义是未定义，</span><br><span class="line">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class="line">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class="line">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等 号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="和-的valueOf和toString的结果"><a href="#和-的valueOf和toString的结果" class="headerlink" title="{}和[]的valueOf和toString的结果"></a>{}和[]的valueOf和toString的结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class="line">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="js-的作用域和作用域链"><a href="#js-的作用域和作用域链" class="headerlink" title="js 的作用域和作用域链"></a>js 的作用域和作用域链</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作用域： </span><br><span class="line">	作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class="line"></span><br><span class="line">作用域链： </span><br><span class="line">	作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。</span><br><span class="line">	作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</span><br><span class="line">当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</span><br></pre></td></tr></table></figure>

<h3 id="js-创建对象的方式"><a href="#js-创建对象的方式" class="headerlink" title="js 创建对象的方式"></a>js 创建对象的方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式，我了解到的方式有这么几种：</span><br><span class="line"></span><br><span class="line">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class="line"></span><br><span class="line">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class="line"></span><br><span class="line">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class="line"></span><br><span class="line">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class="line"></span><br><span class="line">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class="line"></span><br><span class="line">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br></pre></td></tr></table></figure>

<h3 id="对this、call、apply和bind的理解"><a href="#对this、call、apply和bind的理解" class="headerlink" title="对this、call、apply和bind的理解"></a>对this、call、apply和bind的理解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、在浏览器里，在全局范围内this 指向window对象；</span><br><span class="line">2、在函数中，this永远指向最后调用他的那个对象；</span><br><span class="line">3、构造函数中，this指向new出来的那个新的对象；</span><br><span class="line">4、call、apply、bind中的this被强绑定在指定的那个对象上；</span><br><span class="line">5、箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</span><br><span class="line">6、apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</span><br></pre></td></tr></table></figure>

<h3 id="什么是-DOM-和-BOM"><a href="#什么是-DOM-和-BOM" class="headerlink" title="什么是 DOM 和 BOM"></a>什么是 DOM 和 BOM</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOM指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class="line">BOM指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。</span><br><span class="line"></span><br><span class="line">BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，</span><br><span class="line">又是一个 Global（全局）(歌楼波)对象。</span><br><span class="line">这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。</span><br><span class="line">window 对象含有 location 对象、navigator(那V给特)对象、screen(斯歌锐)对象等子对象，</span><br><span class="line">并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</span><br></pre></td></tr></table></figure>

<h3 id="三种事件模型"><a href="#三种事件模型" class="headerlink" title="三种事件模型"></a>三种事件模型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事件 是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</span><br><span class="line">DOM0级模型： </span><br><span class="line">	这种模型不会传播，所以没有事件流的概念，同元素 绑定多个事件，只会绑定最后一次的事件，前面的会被覆盖。</span><br><span class="line"></span><br><span class="line">IE 事件模型：</span><br><span class="line">	在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。</span><br><span class="line">	事件处理阶段会首先执行目标元素绑定的监听事件。</span><br><span class="line">	然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，</span><br><span class="line">	依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</span><br><span class="line">	这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，</span><br><span class="line">	会按顺序依次执行。detachEvent删除事件</span><br><span class="line">	</span><br><span class="line">DOM2 级事件模型： </span><br><span class="line">	在该事件模型中，一次事件共有三个过程，</span><br><span class="line">	第一个过程是事件捕获阶段事件处理阶段，和事件冒泡阶段。</span><br><span class="line">	捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，</span><br><span class="line">	如果有则执行。。</span><br><span class="line">	这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br><span class="line">	取消事件removeEventListener</span><br></pre></td></tr></table></figure>

<h3 id="事件委托-代理"><a href="#事件委托-代理" class="headerlink" title="事件委托(代理)"></a>事件委托(代理)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本质上是利用了事件冒泡的机制。</span><br><span class="line">并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，</span><br><span class="line">由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托</span><br><span class="line">支持为同一个DOM元素注册多个同类型事件，可将事件分成事件捕获和事件冒泡机制</span><br></pre></td></tr></table></figure>

<h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事件传播有三个阶段：</span><br><span class="line">捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class="line">目标阶段–事件已达到目标元素。</span><br><span class="line">冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br><span class="line"></span><br><span class="line">什么是事件捕获</span><br><span class="line">当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。</span><br><span class="line">什么是事件冒泡？</span><br><span class="line">事件冒泡刚好与事件捕获相反，当前元素----&gt;body ----&gt; html----&gt;document ----&gt;window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。</span><br></pre></td></tr></table></figure>

<h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）创建新节点</span><br><span class="line"> 	createDocumentFragment()    &#x2F;&#x2F;创建一个DOM片段 (科瑞A特)(法歌们特)</span><br><span class="line"> 	createElement()             &#x2F;&#x2F;创建一个具体的元素</span><br><span class="line"> 	createTextNode()   		    &#x2F;&#x2F;创建一个文本节点</span><br><span class="line"></span><br><span class="line">（2）添加、移除、替换、插入</span><br><span class="line">	appendChild(node) </span><br><span class="line">	removeChild(node)</span><br><span class="line">	replaceChild(new,old) (锐普利斯)</span><br><span class="line">	insertBefore(new,old) (因色特比佛)</span><br><span class="line"></span><br><span class="line">（3）获取、查找</span><br><span class="line">	getElementById();</span><br><span class="line">	getElementsByName();</span><br><span class="line">	getElementsByTagName();</span><br><span class="line">	getElementsByClassName();</span><br><span class="line">	querySelector(); (斯来科特)</span><br><span class="line">	querySelectorAll();</span><br><span class="line"></span><br><span class="line">（4）属性操作</span><br><span class="line">	getAttribute(key); (去比又特)</span><br><span class="line">	setAttribute(key, value);</span><br><span class="line">	hasAttribute(key);</span><br><span class="line">	removeAttribute(key);</span><br></pre></td></tr></table></figure>

<h3 id="数据检测类型判断"><a href="#数据检测类型判断" class="headerlink" title="数据检测类型判断"></a>数据检测类型判断</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">检测方法4种</span><br><span class="line"></span><br><span class="line"> 1、Object.prototype.toString.call()</span><br><span class="line">    作用: 可以检测所有数据类型</span><br><span class="line">    所有数据类型都可以检测,而且非常正确</span><br><span class="line">    语法: Object.prototype.toString.call( &#39;xxx&#39;&#x2F;11&#x2F;[ ] )</span><br><span class="line">    返回值: [object Xxx], Xxx 就是对象的类型</span><br><span class="line"> 2、constructor</span><br><span class="line">    作用: 可以检测基本数据类型和引用数据类型</span><br><span class="line">    弊端: 把类的原型进行重写, 很有可能把之前的constructor覆盖 检测出来的结果就会不准确</span><br><span class="line">    语法: (&quot;xx&quot;)&#x2F;([])&#x2F;(function()&#123;&#125;).constructor &#x3D;&#x3D;&#x3D; String&#x2F;Array&#x2F;Function	</span><br><span class="line">    返回值: true&#x2F;false</span><br><span class="line">3、instanceOf</span><br><span class="line">    原理: 判断对象类型，基于原型链去判断(obj instanceof Object)</span><br><span class="line">    左边对象的原型链proto上是否有右边构造函数的proptotype属性</span><br><span class="line">    作用: 判断左边的对象是否是右边构造函数的实例</span><br><span class="line">    弊端: 用于引用类型的检测, 对于基本数据类型不生效</span><br><span class="line">    语法: &quot; &quot;&#x2F;[ ]&#x2F;true instanceOf String&#x2F;Array&#x2F;Boolean</span><br><span class="line">    返回值: true&#x2F;false</span><br><span class="line">4、typeOf</span><br><span class="line">    作用: 用于检测基本数据类型和函数</span><br><span class="line">    弊端: 引用数据类型(Arrary&#x2F;function&#x2F;object)只会返回Object, 不起作用</span><br><span class="line">    语法: typeOf &quot; &quot;&#x2F;[ ]&#x2F;xx</span><br><span class="line">    返回值: &quot;string&quot;&#x2F;&quot;boolean&quot;&#x2F;&quot;object&quot; (无法区分)</span><br></pre></td></tr></table></figure>

<h3 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型/原型链"></a>原型/原型链</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原型：</span><br><span class="line">Javascript规定，每一个函数都有一个prototype对象属性，指向另一个对象</span><br><span class="line">prototype就是调用构造函数所创建的那个实例对象的原型</span><br><span class="line"></span><br><span class="line">原型链：</span><br><span class="line">实例对象与原型之间的连接，叫做原型链。</span><br><span class="line">JS在创建对象的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。</span><br><span class="line"></span><br><span class="line">获取原型的方法</span><br><span class="line">p.proto</span><br><span class="line">p.constructor.prototype</span><br><span class="line">Object.getPrototypeOf(p)</span><br></pre></td></tr></table></figure>

<h3 id="prototype、proto、constructor三者的关系"><a href="#prototype、proto、constructor三者的关系" class="headerlink" title="prototype、proto、constructor三者的关系"></a>prototype、proto、constructor三者的关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、prototype:</span><br><span class="line">每一个函数都有一个prototype这个属性，而这个属性指向一个对象，这个对象我们叫做原型对象 </span><br><span class="line">作用：节约内存扩展属性和方法可以实现类之间的继承 </span><br><span class="line">2、__proto__: </span><br><span class="line">每一个对象都有一个__proto__属性,__proto__指向创建自己的那个构造函数的原型对象对象可以直接访问__proto__里面的属性和方法 </span><br><span class="line">3、constructor：</span><br><span class="line">指向创建自己的那个构造函数 ，是原型上的方法</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">当我们创建一个构造函数的时候这个构造函数自带了一个prototype属性，而这个属性指向一个对象，也就是原型对象。 这个原型对象里面有一个constructor构造器，它的作用是指向创建自己的构造函数。</span><br><span class="line">除此之外 prototype还可以存放公共的属性和方法。 </span><br><span class="line">当我们实例化一个对象的时候(被new调用的时候)，这个对象自带了一个 proto 属性，</span><br><span class="line">这个proto 指向创建自己的构造函数的原型对象。可以使用这个原型对象里面的属性和方法</span><br></pre></td></tr></table></figure>

<h3 id="constructor与class的区别"><a href="#constructor与class的区别" class="headerlink" title="constructor与class的区别"></a>constructor与class的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传统的javascript中只有对象，没有类的概念。它是基于原型的面向对象语言。</span><br><span class="line">原型对象特点就是将自身的属性共享给新对象。 </span><br><span class="line"></span><br><span class="line">ES6引入了Class（类）这个概念，通过class关键字可以定义类。</span><br><span class="line">该关键字的出现使得其在对象写法上更加清晰，更像是一种面向对象的语言</span><br><span class="line"></span><br><span class="line">constructor： </span><br><span class="line">constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。</span><br><span class="line">一个类必须有constructor()方法，如果没有显式定义，一个空的 constructor()方法会被默认添加。</span><br></pre></td></tr></table></figure>

<h3 id="构造函数与普通函数的区别"><a href="#构造函数与普通函数的区别" class="headerlink" title="构造函数与普通函数的区别"></a>构造函数与普通函数的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 返回值类型的区别：</span><br><span class="line">	构造函数是没有返回值类型的，</span><br><span class="line">	普通函数是有返回值类型的，即使函数没有返回值，返回值类型也要写上void。</span><br><span class="line">2. 函数名的区别：</span><br><span class="line">	构造函数的函数名必须要与类名一致，</span><br><span class="line">	普通函数的函数名只要符合标识符的命名规则即可。</span><br><span class="line">3. 调用方式的区别：</span><br><span class="line">	构造函数是在创建对象的时候由jvm调用的。</span><br><span class="line">	普通函数是由我们使用对象调用的，一个对象可以对象多次普通的函数，</span><br><span class="line">4. 作用上的区别：</span><br><span class="line">	构造函数的作用用于初始化一个对象。</span><br><span class="line">	普通函数是用于描述一类事物的公共行为的。</span><br></pre></td></tr></table></figure>

<h3 id="跨域出现的原因-解决方法"><a href="#跨域出现的原因-解决方法" class="headerlink" title="跨域出现的原因/解决方法"></a>跨域出现的原因/解决方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原因：由于浏览器的同源策略，即属于不同域的⻚面之间不能相互访问各自的⻚面内容。</span><br><span class="line"></span><br><span class="line">哪些情况下产生跨域</span><br><span class="line">1、域名不同</span><br><span class="line">2、端口号不同</span><br><span class="line">3、协议不同(http&#x2F;https)</span><br><span class="line">4、域名和域名对应ip</span><br><span class="line">5、主域名相同(127.0.01 和 localhost) 多域名匹配一个ip地址</span><br><span class="line">6、子域名不同（一级和二级域名）</span><br><span class="line"></span><br><span class="line">解决方法</span><br><span class="line"></span><br><span class="line">1、后端代理 </span><br><span class="line">后端不存在跨域（后端代码脱离浏览器，后端是服务器端）</span><br><span class="line">利用后端(自己公司的后端)去获取接口数据，将数据传给前端</span><br><span class="line">2、jsonp</span><br><span class="line">原理:</span><br><span class="line">	利用浏览器的&quot;漏洞&quot; src不受同源策略的影响，可以请求任何链接 。动态创建script标签，将事先写好的函数名传给服务器，供服务器使用</span><br><span class="line">（1）script标签src属性不存在跨域</span><br><span class="line">（2）get方式--传递函数名 --弊端</span><br><span class="line">（3）callback回调函数(传递函数名)</span><br><span class="line">3、反向代理  </span><br><span class="line">proxy  webpack配置</span><br><span class="line">&quot;proxy&quot;: &#123;</span><br><span class="line">    &quot;&#x2F;index.php&quot;: &#123;</span><br><span class="line">      &quot;target&quot;: &quot;http:&#x2F;&#x2F;qinqin.net&quot;,</span><br><span class="line">      &quot;changeOrigin&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">4、CORS解决跨域(xhr2)(后端)</span><br><span class="line">CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</span><br><span class="line">需要服务器(提供接口的源码里面)添加下面两句话。</span><br><span class="line">header(&#39;Access-Control-Allow-Origin:*&#39;);</span><br><span class="line">header(&#39;Access-Control-Allow-Method:POST,GET&#39;);</span><br><span class="line"></span><br><span class="line">jsonp是一种非正式传输协议，用于解决跨域问题流程： </span><br><span class="line">1、创建一个全局函数 </span><br><span class="line">2、创建一个script标签 </span><br><span class="line">3、给script添加src </span><br><span class="line">4、给src添加回调函数test(callback&#x3D;test) callback是传给后端的一个参数</span><br><span class="line">5、将script放到⻚面上 </span><br><span class="line">6、script请求完成，将自己从⻚面上删除</span><br></pre></td></tr></table></figure>

<h3 id="闭包原理-优点-缺点-使用场景"><a href="#闭包原理-优点-缺点-使用场景" class="headerlink" title="闭包原理/优点/缺点/使用场景"></a>闭包原理/优点/缺点/使用场景</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">闭包原理：定义在一个函数内部的函数(函数嵌套函数)，闭包就是将函数内部和函数外部连接起来的一座桥梁。</span><br><span class="line">打破了作用域链的规则 闭包就是能够读取其他函数内部变量的函数 </span><br><span class="line"></span><br><span class="line">用途:</span><br><span class="line">第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class="line">另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</span><br><span class="line"></span><br><span class="line">优点:</span><br><span class="line">1、使用闭包是不会污染全局环境，</span><br><span class="line">2、方便进行模块化开发，</span><br><span class="line">3、减少形参个数，延长了形参的生命周期，</span><br><span class="line"></span><br><span class="line">坏处:</span><br><span class="line">1、就是不恰当使用会造成内存泄漏 </span><br><span class="line"></span><br><span class="line">闭包的不适用于返回闭包的函数是个特别大的函数,很多高级应用都要依靠闭包实现.</span><br><span class="line"></span><br><span class="line">使用场景</span><br><span class="line">1、通过循环给页面上多个dom节点绑定事件</span><br><span class="line">2、封装私有变量(计数器)    </span><br><span class="line">3、延续局部变量的寿命</span><br><span class="line">4、高阶组件  </span><br><span class="line">5、函数防抖</span><br><span class="line"></span><br><span class="line">模块化的就是以闭包为基础构建的;</span><br></pre></td></tr></table></figure>

<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、意外的全局变量 </span><br><span class="line">2、被遗忘的定时器 </span><br><span class="line">3、没有清除的dom应用 ，故要及时清除，</span><br><span class="line">4、滥用闭包</span><br><span class="line"></span><br><span class="line">清除内存泄漏方法有两种，一是标记清除，二便是引用计数清除。</span><br></pre></td></tr></table></figure>

<h3 id="promise-async-amp-await"><a href="#promise-async-amp-await" class="headerlink" title="promise/async&amp;await"></a>promise/async&amp;await</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise是es6新增的，异步编程的一种解决方案，用来取代回调函数和事件，比传统的解决方案——回调函数和事件——更合理和更强大。</span><br><span class="line"></span><br><span class="line">Promise 对象用于延迟(deferred) 计算和异步(asynchronous)计算。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。Promise 对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。这使得异步方法可以像同步方法那样返回值:异步方法会返回一个包含了原返回值的 promise 对象来替代原返回值。</span><br><span class="line"></span><br><span class="line">有三种状态：pending（进行中）、fulfilled（resolve已成功）和rejected(锐杰克腾德)（已失败）</span><br><span class="line"></span><br><span class="line">promise的特点：</span><br><span class="line">（1）对象的状态不受外界影响。Promise对象代表一个异步操作。</span><br><span class="line">（2）一旦状态设定，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为resolve和从pending变为rejected。只要这两种情况发生，状态就凝固了</span><br><span class="line">    </span><br><span class="line">promise的方法：</span><br><span class="line">promise实例方法：</span><br><span class="line">	Promise.prototype.then        </span><br><span class="line">	Promise.prototype.catch</span><br><span class="line">	</span><br><span class="line">    一：resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</span><br><span class="line">    二：reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span><br><span class="line">    三：Promise.prototype.finally</span><br><span class="line">    finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</span><br><span class="line"></span><br><span class="line">promise的静态方法   </span><br><span class="line">    Promise.all():用于将多个 Promise 实例，包装成一个新的 Promise 实例，接受一个数组作为参数，只有数组里面的每个状态都变成resolve，则新的 Promise 实例状态才会变成resolve.</span><br><span class="line">    Promise.race():将Promise对象数组中最先执行完成的内容通过后面then传出</span><br><span class="line">    </span><br><span class="line">promise的基本使用：</span><br><span class="line">通过new promise创建一个promise对象，里面有一个参数，参数是一个回调函数，</span><br><span class="line">回调函数中有2个参数：resolve、reject </span><br><span class="line">	resolve()当异步执行成功的时候调用的方法，reject()当异步失败的时候调用的方法。</span><br><span class="line">除此之外promise有一个then方法，当成功的时候执行第一个回调函数，当失败的时候执行第二个回调函数。</span><br><span class="line">第二个回调函数也可以通过promise对象.catch调用 </span><br><span class="line"></span><br><span class="line">Promise.all():当所有的异步代码都执行完毕以后才会执行.then中的操作</span><br><span class="line">Promise.race():只要有一个promise执行完毕后就会执行.then操作</span><br><span class="line"></span><br><span class="line">promise的三种状态： </span><br><span class="line">1.pending - 进行中 </span><br><span class="line">2.fulfilled - 成功 </span><br><span class="line">3.rejected - 失败</span><br><span class="line"></span><br><span class="line">链式调用:</span><br><span class="line">promise俗称链式调用，它是es6中最重要的特性之一</span><br><span class="line">简单的说可以不停的then调用嵌套在调用（异步之后，链式调用方式执行回调），这种操作方式称为promise</span><br><span class="line"></span><br><span class="line">async异步能干什么？</span><br><span class="line">就是用来修饰函数，使该函数异步执行，不阻碍后续函数的执行 </span><br><span class="line">同时我们注意到，async修饰的函数也带有then catch方法，</span><br><span class="line">因此，经async修饰的函数也 是一个promise await只能放在async中，且只能修饰promise对象 </span><br><span class="line">	1. promise的诞生是为了简化函数嵌套调用流程，也便于后续维护 </span><br><span class="line">	2. async&#x2F;await定义了异步函数，并在其内部可通过await等待promise对象，阻塞后 续的执行 </span><br><span class="line"></span><br><span class="line">await关键字必须在async函数里面 </span><br><span class="line">await会阻塞当前直到完成 async返回reject的方法,当抛出异常等同于reject </span><br><span class="line"></span><br><span class="line">async &#x2F; await与 Promise的主要区别是：</span><br><span class="line">Promise代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来, </span><br><span class="line">async &#x2F; await函数的实现最简洁，最符合语义，几乎没有语义不相关的代码 </span><br><span class="line">async &#x2F; await 函数就是 Generator 函数的语法糖</span><br><span class="line"></span><br><span class="line">async&#x2F;await函数的优势 </span><br><span class="line">1. 使用async函数可以让代码简洁很多，不需要像Promise一样需要些then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码 </span><br><span class="line">2. 使用aync&#x2F;await的话，catch能处理JSON.parse错误 promise中不能处理 </span><br><span class="line">3. 条件语句也和错误捕获是一样的，在 Async 中也可以像平时一般使用条件语句</span><br><span class="line"></span><br><span class="line">promise的状态处理的原理:</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="promise-all和promise-race"><a href="#promise-all和promise-race" class="headerlink" title="promise.all和promise.race"></a>promise.all和promise.race</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pomise.all的使用</span><br><span class="line">	Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</span><br><span class="line">	Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。</span><br><span class="line"></span><br><span class="line">Promise.race的使用</span><br><span class="line">	Promise.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</span><br></pre></td></tr></table></figure>

<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generator 的中文名称是生成器，它是ECMAScript6中提供的新特性。</span><br><span class="line">在过去，封装一段运算逻辑的单元是函数。函数只存在“没有被调用”或者“被调用”的情况，</span><br><span class="line">不存在一个函数被执行之后还能暂停的情况，而Generator的出现让这种情况成为可能。</span><br><span class="line"></span><br><span class="line">通过 function* 来定义的函数称之为“生成器函数”（generator function），它的特点是可以中断函数的执行，</span><br><span class="line">每次执行yield语句之后，函数即暂停执行，直到调用返回的生成器对象的next()函数它才会继续执行。</span><br><span class="line"></span><br><span class="line">也就是说 Generator 函数是一个状态机，封装了多个内部状态。</span><br><span class="line">执行 Generator 函数返回一个遍历器对象（一个指向内部状态的指针对象），</span><br><span class="line">调用遍历器对象的next方法，使得指针移向下一个状态。每次调用next方法，</span><br><span class="line">内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。</span><br><span class="line"></span><br><span class="line">yield关键字</span><br><span class="line">真正让Generator具有价值的是yield关键字，这个yield关键字让 Generator内部的逻辑能够切割成多个部分。</span><br><span class="line">发现函数执行到第一个yield关键字的时候就停止了。要让业务逻辑继续执行完，需要反复调用.next()</span><br><span class="line">可以简单地理解为yield关键字将程序逻辑划分成几部分，每次.next()执行时执行一部分。</span><br><span class="line">这使得程序的执行单元再也不是函数，复杂的逻辑可以通过yield来暂停。</span><br><span class="line"></span><br><span class="line">.next()调用时，返回一个对象，这个对象具备两个属性。</span><br><span class="line">其中一个属性是布尔型的done。它表示这个Generator对象的逻辑块是否执行完成。</span><br><span class="line">另一个属性是value，它来自于yield语句后的表达式的结果。</span><br><span class="line"></span><br><span class="line">通过.next()传递参数，可以赋值给yield关键字前面的变量声明。</span><br></pre></td></tr></table></figure>

<h3 id="堆-栈"><a href="#堆-栈" class="headerlink" title="堆/栈"></a>堆/栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、堆——引用类型地址传递</span><br><span class="line">	堆：动态分配的内存，大小不定，不会自动释放。存放引用类型的值 先进后出FILO</span><br><span class="line">	引用类型: Object(Arrary, Date, Math,Function, Object)</span><br><span class="line">	访问方法: JS不能直接访问内存中的值, 只能操作对象的地址, 所以产生深&#x2F;浅拷贝问题</span><br><span class="line">	栈--基本类型值传递</span><br><span class="line">2、栈——自动分配内存空间，系统自动释放，存放基本类型的值和引用类型的地址先进先出FIFO</span><br><span class="line">    基本类型: Undefined、Null、Boolean、Number 和 String, Symbol(ES6新增)</span><br><span class="line">    访问方法: 按值访问, 直接操作内存中的值</span><br></pre></td></tr></table></figure>

<h3 id="深-浅拷贝及方法"><a href="#深-浅拷贝及方法" class="headerlink" title="深/浅拷贝及方法"></a>深/浅拷贝及方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">深&#x2F;浅拷贝针对的是引用类型</span><br><span class="line"></span><br><span class="line">浅拷贝</span><br><span class="line">浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</span><br><span class="line">新旧互相影响,改变的是地址</span><br><span class="line">新值&#x3D;&#x3D;&#x3D;原值,只能拷贝一层</span><br><span class="line"></span><br><span class="line">数组方法: slice截取, concat拼接, filter过滤, map</span><br><span class="line">对象方法: Object.assign(&#123;&#125;,obj), Object.create(obj)</span><br><span class="line">			   </span><br><span class="line">展开运算符: &#123;...obj&#125;,[...arr] </span><br><span class="line"></span><br><span class="line">深拷贝</span><br><span class="line">深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</span><br><span class="line">新旧互不影响,改变的是值</span><br><span class="line">新值&#x3D;&#x2F;&#x3D;原值,可以拷贝多层</span><br><span class="line"></span><br><span class="line">1、JSON序列化</span><br><span class="line">    JSON.parse(JSON.stringify(obj))对象--&gt;字符串--&gt;对象</span><br><span class="line">    这个方式的弊端：</span><br><span class="line">    1、如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对		象的形式</span><br><span class="line">    2、如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；</span><br><span class="line">    3、如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</span><br><span class="line">    4、如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</span><br><span class="line">    5、JSON.stringify()只能序列化对象的可枚举的自有属性，不可枚举的不能被复制</span><br><span class="line">    </span><br><span class="line">    可枚举:可枚举性（enumerable）用来控制所描述的属性，是否将被包括在for...in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。</span><br><span class="line">    for..in循环、Object.keys方法、JSON.stringify方法</span><br><span class="line">2、原生实现</span><br><span class="line">	递归+浅拷贝</span><br><span class="line"></span><br><span class="line">3、工具实现【第三方封装库】</span><br><span class="line">loadsh _.cloneDeep(obj)</span><br><span class="line">	.DeepClone()</span><br><span class="line">	用于 Model &#x2F; Entity &#x2F; ... ... 等引用类型对象的深度克隆</span><br><span class="line">		特性说明</span><br><span class="line">		1.不需要对对象做任何特殊处理，直接 .DeepClone() 即可得到该对象的深度克隆</span><br><span class="line">		2.不受对象层次深度限制，均可实现深度克隆（下面会给出几个简单示例 ... ...）</span><br><span class="line">Immutable</span><br><span class="line">Object.create()</span><br></pre></td></tr></table></figure>

<h3 id="set和map"><a href="#set和map" class="headerlink" title="set和map"></a>set和map</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set:它类似于数组，但是成员的值都是唯一的，没有重复的值。</span><br><span class="line">Set本身是一个构造函数，用来生成 Set 数据结构，数组作为参数。</span><br><span class="line"></span><br><span class="line">不说set  数据结构Set   new set()存储数据   set.size得到存储的数据长度   </span><br><span class="line"></span><br><span class="line">has()判断某个值是否存在set中   foreach遍历set</span><br><span class="line"></span><br><span class="line">不说map : new  map      map.set   map.get   map.delete</span><br><span class="line"></span><br><span class="line">都是用来存储数据用的，但是存储的数据格式不同</span><br><span class="line">set 直接存储 任意类型数据</span><br><span class="line">map 存储数据的时候，必须以key，value的形式，</span><br><span class="line">set 使用forEach 遍历的时候，key和value值是一样的</span><br><span class="line">而map 遍历的时候，key就是存进去的对象的key，value就是存在的值</span><br><span class="line"></span><br><span class="line">for循环这种写法比较麻烦，因此数组提供内置的forEach方法。</span><br><span class="line"></span><br><span class="line">forEach没有返回值，无法中途跳出forEach循环，break命令或return命令都不能奏效。</span><br><span class="line"></span><br><span class="line">for...in循环主要是为遍历对象而设计的，不适用于遍历数组**</span><br><span class="line"></span><br><span class="line">for...of循环相比上面几种做法，有一些显著的优点。</span><br><span class="line">有着同for...in一样的简洁语法，但是没有for...in那些缺点。</span><br><span class="line">不同于forEach方法，它可以与break、continue和return配合使用。</span><br><span class="line">提供了遍历所有数据结构的统一操作接口。</span><br></pre></td></tr></table></figure>

<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a><strong>宏任务和微任务</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js 是单线程执行的，js中的任务按顺序一个一个的执行，但是一个任务耗时太长，那么后面的任务就需要等待，为了解决这种情况，将任务分为了同步任务和异步任务，而异步任务又可以分为微任务和宏任务</span><br><span class="line"></span><br><span class="line">概念  </span><br><span class="line">1.宏任务：当前调用栈中执行的代码成为宏任务。（主代码快，定时器等等）。 </span><br><span class="line">2.微任务：当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。（promise.then，proness.nextTick等等）。 </span><br><span class="line">3.宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。</span><br><span class="line"></span><br><span class="line">运行机制</span><br><span class="line">1. 在执行栈中执行一个宏任务。 </span><br><span class="line">2. 执行过程中遇到微任务，将微任务添加到微任务队列中。</span><br><span class="line">3. 当前宏任务执行完毕，立即执行微任务队列中的任务。 </span><br><span class="line">4. 当前微任务队列中的任务执行完毕，检查渲染，GUI线程接管渲染。 </span><br><span class="line">5. 渲染完毕后，js线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。</span><br><span class="line"></span><br><span class="line">微任务：process.nextTick、MutationObserver、Promise.then catch finally</span><br><span class="line">宏任务：I&#x2F;O、setTimeout、setInterval、setImmediate、requestAnimationFrame</span><br><span class="line"></span><br><span class="line">js执行顺序，（先执行宏任务列，微任务队列）</span><br><span class="line">先同步再异步，在此基础上先宏任务再微任务</span><br><span class="line"></span><br><span class="line">流程：</span><br><span class="line">	同步和异步任务分别进入不同的执行“场所”，同步进入主线程，异步进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，回去了Event Queue读取对应的函数，进入主线程。</span><br><span class="line">	上述过程会不断重复，也就是常说的Event Loop（事件循环）。</span><br><span class="line">	但是，JS异步还有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入event queue，然后再执行微任务，将微任务放入eventqueue，但是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的queue拿宏任务的回调函数，</span><br></pre></td></tr></table></figure>

<h3 id="js异步操作"><a href="#js异步操作" class="headerlink" title="js异步操作"></a>js异步操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、定时器都是异步操作</span><br><span class="line">2、事件绑定都是异步操作</span><br><span class="line">3、AJAX中一般我们都采取异步操作（也可以同步）</span><br><span class="line">4、回调函数可以理解为异步（不是严谨的异步操作）</span><br><span class="line">5、promise</span><br><span class="line">6、generator（ES6） </span><br><span class="line">   通过yield关键字可以让任务在需要的地方暂停,每一步的值可以通过next获取</span><br><span class="line">7、async&#x2F;await(ES7) </span><br><span class="line">   await得到的就是async异步返回值,底层原理还是promise中的resolve方法</span><br><span class="line">8、设计模式-发布订阅模式</span><br><span class="line">9、事件监听</span><br></pre></td></tr></table></figure>

<h3 id="表单只能输入数字"><a href="#表单只能输入数字" class="headerlink" title="表单只能输入数字"></a>表单只能输入数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正则   type number</span><br></pre></td></tr></table></figure>

<h3 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a>Proxy和Reflect</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Proxy用于修改某些操作的默认行为，即对编程语言层面进行修改，属于“元编程”，Proxy意思为“代理”，即在访问对象之前建立一道“拦截”，任何访问该对象的操作之前都会通过这道“拦截”，即执行Proxy里面定义的方法</span><br><span class="line"></span><br><span class="line">let pro &#x3D; new Proxy(target,handler)</span><br><span class="line"></span><br><span class="line">其中 new Proxy相当于创建了一个Proxy实例，target为所要拦截的目标对象，handler也是一个对象，里面定义的是对拦截对象所要进行的拦截方法</span><br><span class="line"></span><br><span class="line">Proxy也可以作为其他对象的原型对象使用</span><br><span class="line"></span><br><span class="line">上述实例将pro作为obj的原型对象使用，虽然obj本身没有name这个属性，但是根据原型链，会在pro上读取到name属性，之后会执行相对应的拦截操作。</span><br><span class="line"></span><br><span class="line">let pro &#x3D; new Proxy(target,handler);</span><br><span class="line">let obj &#x3D; Object.create(pro);</span><br></pre></td></tr></table></figure>

<h3 id="Proxy常用的拦截方法"><a href="#Proxy常用的拦截方法" class="headerlink" title="Proxy常用的拦截方法"></a>Proxy常用的拦截方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get(target,name,property)方法</span><br><span class="line">用于拦截某个读取属性的操作,第一个参数为目标对象，第二个参数为属性名称，第三个属性为操作所针对的对象（可选参数）</span><br><span class="line"></span><br><span class="line">set(target,name,value,property)</span><br><span class="line">用于拦截某个属性的赋值操作，第一个参数为目标对象，第二个参数为属性名，第三个参数为属性值，第四个参数为操作行为所针对的对象（可选参数）</span><br><span class="line"></span><br><span class="line">has(target,key)</span><br><span class="line">用来拦截对象是否具有某个属性值的操作，第一个参数为目标对象，第二个参数为属性名</span><br><span class="line"></span><br><span class="line">Reflect(锐付莱克特)对象:</span><br><span class="line">Reflect设计的目的是为了优化Object的一些操作方法以及合理的返回Object操作返回的结果，对于一些命令式的Object行为，Reflect对象可以将其变为函数式的行为</span><br><span class="line"></span><br><span class="line">Reflect(target,name,property)  Reflect.has(obj,&quot;name&quot;)  Reflect.get(target,name,property)</span><br></pre></td></tr></table></figure>

<h3 id="浏览器优化"><a href="#浏览器优化" class="headerlink" title="浏览器优化"></a>浏览器优化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">减少请求数量</span><br><span class="line"></span><br><span class="line">图片处理</span><br><span class="line">	雪碧图</span><br><span class="line">	gulp   </span><br><span class="line">	Base64     </span><br><span class="line">	使用字体图标来代替图片 - 自定义字体 @font-face&#123;&#125;    </span><br><span class="line">	在安卓下可以使用webp格式的图片</span><br><span class="line"></span><br><span class="line">减小资源大小 -  webpack优化</span><br><span class="line">	HTML压缩</span><br><span class="line">	CSS压缩</span><br><span class="line">	JS压缩与混乱</span><br><span class="line">	图片压缩</span><br><span class="line"></span><br><span class="line">优化网络连接</span><br><span class="line">	cdnCDN即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状</span><br><span class="line">	用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度</span><br><span class="line"></span><br><span class="line">优化资源加载</span><br><span class="line">	资源加载位置</span><br><span class="line">		1、CSS文件放在head中，先外链，后本页</span><br><span class="line">		2、JS文件放在body底部，先外链，后本页</span><br><span class="line">		3、body中间尽量不写style标签和script标签</span><br><span class="line">	资源加载时机</span><br><span class="line">		1、异步script标签</span><br><span class="line">		2、模块按需加载需要根据路由来加载当前页面需要的业务模块</span><br><span class="line">		3、资源懒加载与资源预加载</span><br><span class="line"></span><br><span class="line">减少重绘回流</span><br><span class="line">	当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流</span><br><span class="line">	当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如		background-color。则就叫称为重绘。</span><br><span class="line">	回流必将引起重绘，而重绘不一定会引起回流。</span><br><span class="line">	css3硬件加速（GPU加速）</span><br><span class="line"></span><br><span class="line">六.【DOM优化】</span><br><span class="line">1、缓存DOM</span><br><span class="line">2、减少DOM深度及DOM数量</span><br><span class="line">3、批量操作DOM</span><br><span class="line">4、批量操作CSS样式</span><br><span class="line">5、在内存中操作DOM</span><br><span class="line">6、DOM元素离线更新</span><br><span class="line">7、DOM读写分离</span><br><span class="line">8、事件代理</span><br><span class="line">9、防抖和节流</span><br><span class="line">10、及时清理环境</span><br></pre></td></tr></table></figure>

<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept(艾可塞克特)</span><br><span class="line">告诉WEB服务器自己接受什么介质类型，*&#x2F;* 表示任何类型，type&#x2F;* 表示该类型下的所有子类型，type&#x2F;sub-type。</span><br><span class="line">　　</span><br><span class="line">Accept-Charset(恰斯特)</span><br><span class="line">浏览器告诉服务器自己能接收的字符集。</span><br><span class="line"></span><br><span class="line">Accept-Encoding(因扣定)</span><br><span class="line">浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）</span><br><span class="line"></span><br><span class="line">Accept-Language</span><br><span class="line">浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</span><br><span class="line">　　</span><br><span class="line">Authorization(哦瑟惹C逊)</span><br><span class="line">当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</span><br><span class="line">　　</span><br><span class="line">If-Match  </span><br><span class="line">如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作，获取文档。</span><br><span class="line"></span><br><span class="line">If-None-Match</span><br><span class="line">如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作，获取文档。</span><br><span class="line">   (莫得反得)</span><br><span class="line">If-Modified-Since(森恩斯)</span><br><span class="line">如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</span><br><span class="line"></span><br><span class="line">If-Unmodified-Since</span><br><span class="line">如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。</span><br><span class="line"></span><br><span class="line">If-Range &#x2F;reinge&#x2F;</span><br><span class="line">浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的ETag 或者自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</span><br><span class="line"></span><br><span class="line">Range</span><br><span class="line">浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes&#x3D;1173546</span><br><span class="line"></span><br><span class="line">Proxy-Authenticate(噢三特K特)</span><br><span class="line">代理服务器响应浏览器，要求其提供代理身份验证信息。</span><br><span class="line"></span><br><span class="line">Proxy-Authorization</span><br><span class="line">浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</span><br><span class="line"></span><br><span class="line">Host</span><br><span class="line">客户端指定自己想访问的WEB服务器的域名&#x2F;IP 地址和端口号。如Host：rss.sina.com.cn</span><br><span class="line"></span><br><span class="line">Referer(锐佛尔)</span><br><span class="line">浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址&#x2F;URL，</span><br><span class="line">例如：Referer：http:&#x2F;&#x2F;www.ecdoer.com&#x2F;</span><br><span class="line"></span><br><span class="line">User-Agent(A就特)</span><br><span class="line">浏览器表明自己的身份（是哪种浏览器）。</span><br><span class="line">例如：User-Agent：Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN;rv:1.8.1.14) Gecko&#x2F;20080404 Firefox&#x2F;2.0.0.14</span><br></pre></td></tr></table></figure>

<h3 id="static有什么特性"><a href="#static有什么特性" class="headerlink" title="static有什么特性"></a>static有什么特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new出来一个实例对象是否带有static属性   static用ES5怎么写</span><br><span class="line"></span><br><span class="line">没有创建对象，也能使用属性和调用方法</span><br><span class="line"></span><br><span class="line">用来形成静态代码块以优化程序性能。因为只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</span><br><span class="line"></span><br><span class="line">static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次</span><br><span class="line"></span><br><span class="line">被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</span><br><span class="line"></span><br><span class="line">类第一次加载初始化的时候就去加载static部分,后面可以重新赋值</span><br><span class="line"></span><br><span class="line">static用ES5怎么写: 静态是通过类名直接调用 class A staticB   </span><br><span class="line"></span><br><span class="line">直接用A.B    将B绑定在A上</span><br></pre></td></tr></table></figure>

<h3 id="async-await"><a href="#async-await" class="headerlink" title="async    await"></a>async    await</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同步还是异步  </span><br><span class="line">	await同步   </span><br><span class="line">	async异步</span><br><span class="line"></span><br><span class="line">async和await有两个关键字,一个写在函数外面,一个写在函数里面,函数外面是异步的，函数里面是同步的，调用函数的那一行其实是异步的,下一行</span><br><span class="line">函数里面转成阻塞的</span><br><span class="line"></span><br><span class="line">async  await &#x3D;&gt; promise 改写</span><br><span class="line"></span><br><span class="line">async函数中</span><br><span class="line">let  a&#x3D;await promise  的a函数</span><br><span class="line">let  b&#x3D;await promise  的b函数</span><br><span class="line"></span><br><span class="line">promise.all改写     </span><br><span class="line">Promise.allSettled   Promise.any</span><br><span class="line"></span><br><span class="line">promise实现promise.all的方法</span><br><span class="line"></span><br><span class="line">async使用的时候报错,如何捕获try...catch</span><br><span class="line"></span><br><span class="line">var test3 &#x3D; async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      await p1();</span><br><span class="line">      await p2();</span><br><span class="line">      p3();</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      console.log(&#39;p1失败了&#39;, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">await后面有个接口  </span><br><span class="line">接口要2S才能完成    接口2S才会执行</span><br></pre></td></tr></table></figure>

<h3 id="ajax中async-false的阻塞和await这种阻塞有什么区别"><a href="#ajax中async-false的阻塞和await这种阻塞有什么区别" class="headerlink" title="$.ajax中async:false的阻塞和await这种阻塞有什么区别"></a>$.ajax中async:false的阻塞和await这种阻塞有什么区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">没区别</span><br></pre></td></tr></table></figure>

<h3 id="怎么携带cookie发送给后端"><a href="#怎么携带cookie发送给后端" class="headerlink" title="怎么携带cookie发送给后端"></a>怎么携带cookie发送给后端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置请求头   请求头中携带cookie</span><br></pre></td></tr></table></figure>

<h3 id="对象浅拷贝在react中用到哪些地方-为什么"><a href="#对象浅拷贝在react中用到哪些地方-为什么" class="headerlink" title="对象浅拷贝在react中用到哪些地方,为什么"></a>对象浅拷贝在react中用到哪些地方,为什么</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么在react中要使用浅拷贝</span><br><span class="line"></span><br><span class="line">redux中要求:状态是只读的,唯一且不可修改的,reducer必须是一个纯函数</span><br><span class="line"></span><br><span class="line">因为redux中数据不可更改,所以redux中的数据应该要拷贝  返回一个新值</span><br></pre></td></tr></table></figure>

<h3 id="ajax、axios、fetch之间的详细区别以及优缺点"><a href="#ajax、axios、fetch之间的详细区别以及优缺点" class="headerlink" title="ajax、axios、fetch之间的详细区别以及优缺点"></a>ajax、axios、fetch之间的详细区别以及优缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.jQuery ajax </span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		type: &#39;POST&#39;,</span><br><span class="line">		url: url,</span><br><span class="line">		data: data,</span><br><span class="line">		dataType: dataType,</span><br><span class="line">		success: function () &#123;&#125;,</span><br><span class="line">		error: function () &#123;&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">优缺点：</span><br><span class="line">	是对原生XHR的封装，除此以外还增添了对JSONP的支持。</span><br><span class="line">	本身是针对MVC的编程,不符合现在前端MVVM的浪潮</span><br><span class="line">	基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</span><br><span class="line">	JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理</span><br><span class="line">	（采取个性化打包的方案又不能享受CDN服务）</span><br><span class="line"></span><br><span class="line">2.axios</span><br><span class="line">	axios(&#123;</span><br><span class="line">		method: &#39;post&#39;,</span><br><span class="line">		url: &#39;&#x2F;user&#x2F;12345&#39;,</span><br><span class="line">		data: &#123;</span><br><span class="line">			firstName: &#39;Fred&#39;,</span><br><span class="line">			lastName: &#39;Flintstone&#39;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(function (response) &#123;</span><br><span class="line">		console.log(response);</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(function (error) &#123;</span><br><span class="line">		console.log(error);</span><br><span class="line">	&#125;);</span><br><span class="line">优缺点：</span><br><span class="line">	Axios本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，</span><br><span class="line">	从它的官网上可以看到它有以下几条特性：</span><br><span class="line">		从 node.js 创建 http 请求</span><br><span class="line">		支持 Promise API</span><br><span class="line">		客户端支持防止CSRF</span><br><span class="line">		提供了一些并发请求的接口（重要，方便了很多的操作）</span><br><span class="line"></span><br><span class="line">3.fetch</span><br><span class="line">	try &#123;</span><br><span class="line">		let response &#x3D; await fetch(url);</span><br><span class="line">		let data &#x3D; response.json();</span><br><span class="line">		console.log(data);</span><br><span class="line">	&#125; catch(e) &#123;</span><br><span class="line">		console.log(&quot;Oops, error&quot;, e);</span><br><span class="line">	&#125;</span><br><span class="line">优缺点：</span><br><span class="line">	符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</span><br><span class="line">	更好更方便的写法</span><br><span class="line">	更加底层，提供的API丰富（request, response）</span><br><span class="line">	脱离了XHR，是ES规范里新的实现方式</span><br><span class="line"></span><br><span class="line">fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，</span><br><span class="line">需要进行封装，例如：</span><br><span class="line">1）fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</span><br><span class="line">2）fetch默认不会带cookie，需要添加配置项</span><br><span class="line">3）fetch不支持abort，不支持超时控制，</span><br><span class="line">   使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</span><br><span class="line">4）fetch没有办法原生监测请求的进度，而XHR可以</span><br><span class="line"></span><br><span class="line">为什么要用axios?</span><br><span class="line">axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</span><br><span class="line">	从浏览器中创建 XMLHttpRequest</span><br><span class="line">	从 node.js 发出 http 请求</span><br><span class="line">	支持 Promise API</span><br><span class="line">	拦截请求和响应</span><br><span class="line">	转换请求和响应数据</span><br><span class="line">	取消请求</span><br><span class="line">	自动转换JSON数据</span><br><span class="line">	客户端支持防止CSRF&#x2F;XSRF</span><br></pre></td></tr></table></figure>

<h3 id="回流-重绘-防抖-节流"><a href="#回流-重绘-防抖-节流" class="headerlink" title="回流/重绘 | 防抖/节流"></a>回流/重绘 | 防抖/节流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回流:</span><br><span class="line">当渲染树中的一部分或者全部因为元素的尺寸、布局、隐藏等改变而需要重新构建的时候，这时 候就会发生回流。 每个⻚面都至少发生一次回流，也就是⻚面第一次加载的时候。 在回流的时候，浏览器会使渲染树中受到影响的元素部分失效，并重新绘制这个部分的渲染树， 完成回流以后，</span><br><span class="line"></span><br><span class="line">重绘:</span><br><span class="line">当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</span><br><span class="line"></span><br><span class="line">防抖：</span><br><span class="line">短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</span><br><span class="line">在事件触发时，开始计时，在规定的时间（delay）内，若再次触发事件，将上一次计时（timer）清空，然后重新开始计时。保证只有在规定时间内没有再次触发事件之后，再去执行这个事件。 </span><br><span class="line"></span><br><span class="line">节流：</span><br><span class="line">指定时间间隔内，若事件被多次触发，只会执行一次</span><br><span class="line">在事件触发之后，开始计时，在规定的时间（delay）内，若再次触发事件，不对此事件做任何处理。保证在规定时间内只执行一次事件.</span><br></pre></td></tr></table></figure>

<h3 id="减少重绘和回流的方式"><a href="#减少重绘和回流的方式" class="headerlink" title="减少重绘和回流的方式"></a>减少重绘和回流的方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CSS</span><br><span class="line">	使用transform替代top</span><br><span class="line">	使用visibility替换display:none</span><br><span class="line">	避免使用table布局</span><br><span class="line">	尽可能在DOM树的最末端改变class</span><br><span class="line">	避免设置多层内联样式</span><br><span class="line">	将动画效果应用到position属性为absoulte或fixed的元素上</span><br><span class="line">	避免使用css表达式</span><br><span class="line">	将频繁重绘或者回流的节点设置为图层</span><br><span class="line">	css硬件加速</span><br><span class="line"></span><br><span class="line">JavaScript</span><br><span class="line">	避免频繁操作样式</span><br><span class="line">	避免频繁操作DOM</span><br><span class="line">	避免频繁读取会引发重绘&#x2F;回流的属性</span><br><span class="line">	对具有复杂动画的元素使用绝对定位</span><br></pre></td></tr></table></figure>

<h3 id="事件循环Event-Loop"><a href="#事件循环Event-Loop" class="headerlink" title="事件循环Event Loop"></a>事件循环Event Loop</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Event Loop 即事件循环</span><br><span class="line">是指浏览器或者Node的一种解决JavaScript单线程运行时不阻塞的一种机制，单线程的是所有任务都在主线程上完成,任务太多的时候,页面卡死,eventLoop可以解决单线程阻塞问题,程序中会有两个线程,一个主线程,一个eventLoop线程,负责主线程和其他进程之间的通信,遇到I&#x2F;O的时候,主线程会让eventLoop线程通知对应的程序,主线程的任务会继续往后执行,等I&#x2F;O程序执行完了,eventLoop线程会把结果返回给主线程,主线程利用回调函数调用结果,完成任务</span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br><span class="line"></span><br><span class="line">宏任务和微任务的执行顺序</span><br><span class="line">	一次事件循环中，先执行宏任务队列里的一个任务，再把微任务队列里的所有任务执行完毕，再去宏任务队列取下一个宏任务执行。</span><br></pre></td></tr></table></figure>

<h3 id="同步异步的区别"><a href="#同步异步的区别" class="headerlink" title="同步异步的区别"></a>同步异步的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在js中，所有任务都分为同步任务和异步任务两大类。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</span><br><span class="line"></span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br><span class="line"></span><br><span class="line">有时候 setTimeout明明写的延时3秒，实际却5，6秒才执行函数，这又是因为什么？</span><br><span class="line"></span><br><span class="line">答：setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。</span><br><span class="line">浏览器的JS引擎遇到setTimeout，拿走之后不会立即放入异步队列，同步任务执行之后，timer模块会到设置时间之后放到异步队列中。js引擎发现同步队列中没有要执行的东西了，即运行栈空了就从异步队列中读取，然后放到运行栈中执行。所以setTimeout可能会多了等待线程的时间。</span><br><span class="line">这时setTimeout函数体就变成了运行栈中的执行任务，运行栈空了，再监听异步队列中有没有要执行的任务，如果有就继续执行，如此循环，就叫Event Loop。</span><br></pre></td></tr></table></figure>

<h3 id="数据请求设置请求数据格式Content-Type"><a href="#数据请求设置请求数据格式Content-Type" class="headerlink" title="数据请求设置请求数据格式Content-Type"></a>数据请求设置请求数据格式Content-Type</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.浏览器默认的 application&#x2F;x-www-form-urlencoded(url因扣得的)</span><br><span class="line">这应该是最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。</span><br><span class="line"></span><br><span class="line">2.multipart(莫踢怕特)&#x2F;form-data</span><br><span class="line">这也是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，就要让 form 的 enctype 等于这个值</span><br><span class="line"></span><br><span class="line">3.application&#x2F;json</span><br><span class="line">除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify  </span><br><span class="line"></span><br><span class="line">4.text&#x2F;xml</span><br><span class="line">相比于JSON，不能更好的适用于数据交换，它包含了太多的包装, 而且它跟大多数编程语言的数据模型不匹配，让大多数程序员感到诧异，XML是面向数据的，JSON是面向对象和结构的，JSON会给程序员一种更加亲切的感觉。</span><br></pre></td></tr></table></figure>

<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. reduce</span><br><span class="line"></span><br><span class="line">遍历数组每一项，若值为数组则递归遍历，否则concat。</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;  </span><br><span class="line">    return arr.reduce((result, item)&#x3D;&gt; &#123;</span><br><span class="line">        return result.concat(Array.isArray(item) ? flatten(item) : item);</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reduce是数组的一种方法，它接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span><br><span class="line">reduce包含两个参数：回调函数，传给total的初始值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 求数组的各项值相加的和： </span><br><span class="line">arr.reduce((total, item)&#x3D;&gt; &#123;  &#x2F;&#x2F; total为之前的计算结果，item为数组的各项值</span><br><span class="line">    return total + item;</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. toString &amp; split</span><br><span class="line">调用数组的toString方法，将数组变为字符串然后再用split分割还原为数组</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&#39;,&#39;).map(function(item) &#123;</span><br><span class="line">        return Number(item);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">因为split分割后形成的数组的每一项值为字符串，所以需要用一个map方法遍历数组将其每一项转换为数值型</span><br><span class="line"></span><br><span class="line">3. join &amp; split</span><br><span class="line">和上面的toString一样，join也可以将数组转换为字符串</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.join(&#39;,&#39;).split(&#39;,&#39;).map(function(item) &#123;</span><br><span class="line">        return parseInt(item);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. 递归</span><br><span class="line"></span><br><span class="line">递归的遍历每一项，若为数组则继续遍历，否则concat</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    var res &#x3D; [];</span><br><span class="line">    arr.map(item &#x3D;&gt; &#123;</span><br><span class="line">        if(Array.isArray(item)) &#123;</span><br><span class="line">            res &#x3D; res.concat(flatten(item));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. 扩展运算符</span><br><span class="line">es6的扩展运算符能将二维数组变为一维</span><br><span class="line"></span><br><span class="line">[].concat(...[1, 2, 3, [4, 5]]);  &#x2F;&#x2F; [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">根据这个结果我们可以做一个遍历，若arr中含有数组则使用一次扩展运算符，直至没有为止。</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    while(arr.some(item&#x3D;&gt;Array.isArray(item))) &#123;</span><br><span class="line">        arr &#x3D; [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何扩展数组-让他拥有新的方法"><a href="#如何扩展数组-让他拥有新的方法" class="headerlink" title="如何扩展数组,让他拥有新的方法"></a>如何扩展数组,让他拥有新的方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.push.apply(a,b)</span><br></pre></td></tr></table></figure>

<h3 id="class中super作用是什么"><a href="#class中super作用是什么" class="headerlink" title="class中super作用是什么"></a>class中super作用是什么</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">es5 的继承是先创建子类的this，然后将父类的方法添加到子类的this上去； </span><br><span class="line">es6 的继承是创建父类的this对象，然后再对this对象添加方法&#x2F;属性。 </span><br><span class="line">而super方法就是用来创建父类this对象的。</span><br><span class="line"></span><br><span class="line">实际上执行的是 super.sport.call(this); </span><br></pre></td></tr></table></figure>

<h3 id="xss攻击和csrf攻击是什么"><a href="#xss攻击和csrf攻击是什么" class="headerlink" title="xss攻击和csrf攻击是什么"></a>xss攻击和csrf攻击是什么</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、CSRF（Cross-site request forgery）：跨站请求伪造。</span><br><span class="line">（1）登录受信任网站A，并在本地生成Cookie。</span><br><span class="line">	（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api	接口时，会提示你登录）</span><br><span class="line">（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）</span><br><span class="line"></span><br><span class="line">CSRF如何防御</span><br><span class="line">方法一: Token 验证：（用的最多）</span><br><span class="line">	（1）服务器发送给客户端一个token；</span><br><span class="line">	（2）客户端提交的表单中带着这个token。</span><br><span class="line">	（3）如果这个 token 不合法，那么服务器拒绝这个请求。</span><br><span class="line">方法二: 隐藏令牌：</span><br><span class="line">	把 token 隐藏在 http 的 head头中。</span><br><span class="line">	方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</span><br><span class="line">方法三: Referer(锐服尔) 验证：</span><br><span class="line">	Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。</span><br><span class="line">	</span><br><span class="line">2、XSS（Cross Site Scripting）：跨域脚本攻击。</span><br><span class="line">XSS攻击的核心原理是：</span><br><span class="line">	不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），</span><br><span class="line">	向你的页面注入脚本（可能是js、hmtl代码块等）。</span><br><span class="line">最后导致的结果可能是：</span><br><span class="line">	盗用Cookie破坏页面的正常结构，插入广告等恶意内容D-doss攻击</span><br><span class="line">XSS的攻击方式</span><br><span class="line">1、反射型</span><br><span class="line">	发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，</span><br><span class="line">	XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。</span><br><span class="line">2、存储型存</span><br><span class="line">	储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），</span><br><span class="line">	下次请求时目标页面时不用再提交XSS代码。</span><br><span class="line"></span><br><span class="line">XSS的防范措施（encode + 过滤）主要有三个：</span><br><span class="line">1、编码：</span><br><span class="line">	对用户输入的数据进行HTML Entity(安特踢) 编码。</span><br><span class="line">2、过滤：</span><br><span class="line">	移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。</span><br><span class="line">	（总而言是，过滤掉一些不安全的内容）移除用户输入的Style节点、Script节点、Iframe节点。</span><br><span class="line">	（尤其是Script节点，它可是支持跨域的呀，一定要移除）。</span><br><span class="line">3、校正</span><br><span class="line">	避免直接对HTML Entity进行解码。</span><br><span class="line">	使用DOM Parse转换，校正不配对的DOM标签。</span><br><span class="line">		这个概念，它的作用是把文本解析成DOM结构。</span><br><span class="line">		比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。</span><br><span class="line">	还有一种简洁的答案：</span><br><span class="line">	首先是encode，如果是富文本，就白名单。</span><br><span class="line"></span><br><span class="line">3、CSRF 和 XSS 的区别:</span><br><span class="line">区别一：</span><br><span class="line">	CSRF：需要用户先登录网站A，获取 cookie。</span><br><span class="line">	XSS：不需要登录。</span><br><span class="line">区别二：（原理的区别）</span><br><span class="line">	CSRF：是利用网站A本身的漏洞，去请求网站A的api。</span><br><span class="line">	XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</span><br></pre></td></tr></table></figure>

<h3 id="webapp和小程序有什么区别"><a href="#webapp和小程序有什么区别" class="headerlink" title="webapp和小程序有什么区别"></a>webapp和小程序有什么区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，微信小程序已经提供了一套 view, data, model, router 层的开发工具，</span><br><span class="line">对于开发简单应用，小程序是可以比 webapp 更加快速的。</span><br><span class="line"></span><br><span class="line">但是实际上微信小程序提供的这一套开发框架，要开发一些复杂应用，是很困难的，</span><br><span class="line">因为：小程序不支持 npm 等 package manager(麦呢橘)无法复用社区中已经很成熟的 web 框架和工具组件只能封装 view 和 style，无法封装行为（handler），行为只能定义在 page 上小程序有 1mb 的限制，所以我们只能将图片之类的静态资源事先放在服务器上</span><br><span class="line"></span><br><span class="line">其次，微信小程序是由微信自己来 host，开发者只需要上传就好，</span><br><span class="line">而微信 webapp 需要开发者自己 host，还需要注册域名甚至备案才可以调用微信接口以及跟公众号集成。</span><br><span class="line">所以微信小程序降低了开发者的门槛。</span><br><span class="line"></span><br><span class="line">综上，对于简单的工具型应用，微信小程序可以让开发者加快开发速度，降低发布门槛，</span><br><span class="line">这种类型的应用比较适合微信小程序。对于复杂的应用，webapp 是更适合的形式。</span><br></pre></td></tr></table></figure>

<h3 id="react优缺点"><a href="#react优缺点" class="headerlink" title="react优缺点"></a>react优缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优点： </span><br><span class="line">1、采用虚拟 DOM，它并不直接对DOM进行操作，安插在javascript逻辑和实际的DOM之间，性能好               </span><br><span class="line">2、跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。 </span><br><span class="line">3、一切都是组件：代码更加 模块化 ，重用代码更容易，可维护性高。                           </span><br><span class="line">4、单向数据流：redux 实现是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。                                           </span><br><span class="line">5、同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。                                    </span><br><span class="line">6、兼容性好：比如使用RequireJS来加载和打包，而Browserify(不弱瑟)和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。                              </span><br><span class="line">7、JSX语法：为了更加便利的模拟DOM结构，我们使用了JSX语法，可以让我们在JS中编译DOM结构                 8、函数式编程：JS的最大特点就是函数式编程，在React中，函数式编程可谓式无处不见</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">不适合单独做一个完整的框架：react是视图层框架，大型项目想要一套完整的框架的话，也许还需要引入Flux和route相关的东西。</span><br></pre></td></tr></table></figure>

<h3 id="react生命周期"><a href="#react生命周期" class="headerlink" title="react生命周期"></a>react生命周期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16版本：</span><br><span class="line">初始阶段:</span><br><span class="line">constructor</span><br><span class="line">	定义state</span><br><span class="line">componentWillMount(这个钩子函数在将来会被弃用)</span><br><span class="line">	为挂载做准备工作</span><br><span class="line">render	</span><br><span class="line">	解析 this.state 和 this.props </span><br><span class="line">	将jsx型的虚拟dom渲染为对象类型的虚拟dom</span><br><span class="line">	render 中不允许使用 this.setState() 如何你使用了，就会栈溢出</span><br><span class="line">componentDidMount</span><br><span class="line">	表示组件挂载结束</span><br><span class="line">	虚拟dom -&gt; Real dom</span><br><span class="line">	可以获取真实dom</span><br><span class="line">	数据请求 -&gt; 赋值给state</span><br><span class="line">	第三方库实例化&#x2F;DOM操作</span><br><span class="line">	</span><br><span class="line">更新阶段:</span><br><span class="line">componentWillReceiveProps(在17版本中被弃用)</span><br><span class="line">	这个钩子实际作用是判断组件身上的props是否发生改变</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">	可以决组件是否要更新渲染 return true&#x2F;false</span><br><span class="line">	接收新旧状态，用于作对比（浅对比）</span><br><span class="line">	一般需要我们手动作深对比</span><br><span class="line">	这个钩子函数是React组件性能优化的一种方式</span><br><span class="line">componentWillUpdate</span><br><span class="line">	表示组件更新前的准备</span><br><span class="line">	这个钩子函数在未来版本被弃用</span><br><span class="line">render</span><br><span class="line">	和初始化阶段的作用一致</span><br><span class="line">componentDidUpdate</span><br><span class="line">	对Real dom 作操作</span><br><span class="line">	注意：父组件数据更新，子组件会重新运行render，反之不行</span><br><span class="line">	每次都要运行子组件render，会造成react性能浪费  </span><br><span class="line">	粗略解决方案：</span><br><span class="line">		在shouldComponentUpdate中，可判断哪些数据改变从而来控制return true&#x2F;false </span><br><span class="line">		继而决定是否需要更新render渲染</span><br><span class="line">	更好的解决方案：</span><br><span class="line">    1.引用PureComponent，让类组件继承（extends）PureComponent </span><br><span class="line">      如：class App extends  PureComponent&#123;&#125;</span><br><span class="line">    2.引用memo，让函数组件写在memo（）里 如：const memoApp &#x3D;memo（function App() &#123;&#125;）</span><br><span class="line">    3.除了memo之外，更细致的是函数组件中还可以用useCallback（方法）和useMemo（对象和数组）两个钩子阻止组件render</span><br><span class="line"></span><br><span class="line">销毁阶段:</span><br><span class="line">componentWillUnmount</span><br><span class="line">	销毁组件</span><br><span class="line">	清除无用实例和事件</span><br><span class="line">错误捕获:</span><br><span class="line">	componentDidCatch</span><br><span class="line">	用户捕获子组件throw的错误，然后显示回退UI</span><br><span class="line"></span><br><span class="line">15版本：</span><br><span class="line">相对于16版本，初始化阶段（constructor钩子变成下列两个）：</span><br><span class="line"></span><br><span class="line">定义于初始化props的 getDefalutProps 钩子函数</span><br><span class="line"></span><br><span class="line">定义于初始化state的 getInitialState 钩子函数</span><br><span class="line">没有错误捕获阶段</span><br><span class="line"></span><br><span class="line">17版本：</span><br><span class="line">相对于16版本 少3多2</span><br><span class="line"></span><br><span class="line">少了componentWillMount，componentWillReceiveProps，componentWillUpdate 3个钩子函数</span><br><span class="line">   (斯塔得可)  (迪外的)</span><br><span class="line">多了static getDerivedStateFromProps钩子函数                           (破外服)</span><br><span class="line">	一个静态方法，所以不能在这个函数里面使用this，这个函数有两个参数nextProps和prevState，这个函数会返回一个对象用来更新当前的state对象，如果不需要更新可以返回null。</span><br><span class="line">	简单说就是，可以增加一次state状态</span><br><span class="line">	  (斯那坡秀的)</span><br><span class="line">多了getSnapshotBeforeUpdate钩子函数</span><br><span class="line">	快照</span><br><span class="line">	这个函数有一个返回值，会作为第三个参数传递给componentDidUpdate钩子</span><br></pre></td></tr></table></figure>

<h3 id="redux流程-redux的原理"><a href="#redux流程-redux的原理" class="headerlink" title="redux流程  redux的原理"></a>redux流程  redux的原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view用actionCreator(酷睿A特)创建一个action，里面可能包含一些数据</span><br><span class="line">使用store的dispatch方法将action传入store</span><br><span class="line">store将action与旧的state转发给reducer</span><br><span class="line">reducer深拷贝state,并返回一个新的state给store</span><br><span class="line">store接收并更新state</span><br><span class="line">使用store.subscribe(萨布斯快不)订阅更新,重新render组件</span><br><span class="line"></span><br><span class="line">redux组成</span><br><span class="line">	state  :用来存储数据和数据管理的、更新视图</span><br><span class="line">	reducer:是一个纯函数，接收旧 state 和 action，根据不同的 Action 做出不同的操作并返回新的 state</span><br><span class="line">	actions:发送动作给reducer,reducer接收动作，判断动作类型修改数据，修改事件后，组件重新做redux事件的订阅</span><br><span class="line"> </span><br><span class="line">Redux三大原则</span><br><span class="line">单一数据源:</span><br><span class="line">	整个应用的 state 被存储在一个 Object tree 中，且只存在于唯一的Store中</span><br><span class="line">	</span><br><span class="line">state 是只读的:</span><br><span class="line">	唯一改变 state 的方法就是触发 action，action 是一个用于描述发生事件的普通对象，视图部分只需要表达想要修改的意图，所有修改都会被集中化处理。</span><br><span class="line">	</span><br><span class="line">状态的改变通过纯函数来完成:</span><br><span class="line">	Redux使用纯函数方式来执行状态的修改，Action表明了修改状态值的意图，而真正执行状态修改的则是Reducer。且Reducer必须是一个纯函数，当Reducer接收到Action时，Action并不能直接修改State的值，而是通过创建一个新的状态对象来返回修改的状态。</span><br></pre></td></tr></table></figure>

<h3 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a>redux 中间件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在action 和 store 之间执行中间件</span><br><span class="line"></span><br><span class="line">Redux中间件机制</span><br><span class="line">	Redux本身就提供了非常强大的数据流管理功能，但这并不是它唯一的强大之处，它还提供了利用中间件来扩展自身功能，以满足用户的开发需求</span><br><span class="line"></span><br><span class="line">     (米的为尔)	</span><br><span class="line">applyMiddlewares():它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。</span><br><span class="line">applyMiddleware顾名思义，用于调用各种中间件；</span><br><span class="line">applyMiddleware执行后，将所有入参中间件存入一个数组，并且返回一个闭包（闭包的概念不做累述）</span><br><span class="line">闭包接受一个createStore作为入参并且执行后返回下一个闭包。</span><br></pre></td></tr></table></figure>

<h3 id="redux-thunk-异步action"><a href="#redux-thunk-异步action" class="headerlink" title="redux-thunk|异步action"></a>redux-thunk|异步action</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先检查参数 action 的类型，如果是函数的话，就执行这个 action 函数，</span><br><span class="line">并把 dispatch, getState, extraArgument(哎克斯拽埃歌门特) 作为参数传递进去，</span><br><span class="line">否则就调用 next 让下一个中间件继续处理 action </span><br><span class="line"></span><br><span class="line">好处</span><br><span class="line">	可以进行前后端数据交互</span><br><span class="line">缺点</span><br><span class="line">    将带有数据请求的action和没有带有数据请求的action混在一起了</span><br><span class="line">    缺点解决： 弃用redux-thunk,使用redux-saga</span><br><span class="line">    redux-saga可以将异步action和普通action区别开来</span><br></pre></td></tr></table></figure>

<h3 id="redux-saga-集中处理异步action"><a href="#redux-saga-集中处理异步action" class="headerlink" title="redux-saga|集中处理异步action"></a>redux-saga|集中处理异步action</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redux-saga可以将异步action和普通action区别开来，控制器与更优雅的异步处理</span><br><span class="line">redux-saga就是用Generator(杰呢瑞特)来处理异步。</span><br><span class="line"></span><br><span class="line">redux-saga文档并没有说自己是处理异步的工具，而是说用来处理边际效应（side effects），这里的边际效应你可以理解为程序对外部的操作，比如请求后端，比如操作文件。</span><br><span class="line"></span><br><span class="line">redux-saga相当于在Redux原有数据流中多了一层，通过对Action进行监听，从而捕获到监听的Action，然后可以派生一个新的任务对state进行维护（这个看项目本身的需求），通过更改的state驱动View的变更。</span><br><span class="line"></span><br><span class="line">redux-saga同样是一个redux中间件，它的定位就是通过集中控制action，起到一个类似于MVC中控制器的效果。</span><br><span class="line">同时它的语法使得复杂异步操作不会像promise那样出现很多then的情况，更容易进行各类测试。</span><br></pre></td></tr></table></figure>

<h3 id="redux与react-redux的关系"><a href="#redux与react-redux的关系" class="headerlink" title="redux与react-redux的关系"></a>redux与react-redux的关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redux是独立的应用状态管理工具。它是可以独立于react之外的。如果我们需要在react当中运用它，那么我们需要手动订阅store的状态变化，来对我们的react组件进行更新。react-reudx这个工具，就帮我们实现了这个功能，我们只需对store进行处理，react组件就会有相应的变化。</span><br><span class="line"></span><br><span class="line">Redux的核心由三部分组成：Store, Action, Reducer。</span><br><span class="line">Store: 是个对象，贯穿你整个应用的数据都应该存储在这里。</span><br><span class="line">Action: 是个对象，必须包含type这个属性，reducer将根据这个属性值来对store进行相应的处理。除此之外的属性，就是进行这个操作需要的数据。</span><br><span class="line">Reducer: 是个函数。接受两个参数：要修改的数据(state) 和 action对象。根据action.type来决定采用的操作，对state进行修改，最后返回新的state。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">Redux: store, action, reducer</span><br><span class="line">store: getState, dispatch, subscribe</span><br><span class="line">combineReducers (克木拜恩)</span><br><span class="line">createStore</span><br><span class="line">store ️ dispatch ️ action ️ reducer</span><br><span class="line"></span><br><span class="line">react-redux:</span><br><span class="line">connect : 将store作为props注入</span><br><span class="line">provider(破外的): 使store在子孙组件的connect中能够获取到</span><br></pre></td></tr></table></figure>

<h3 id="react-reudx"><a href="#react-reudx" class="headerlink" title="react-reudx"></a>react-reudx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. UI组件|显示页面??		 				 (破森特逊弄)</span><br><span class="line">   React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件</span><br><span class="line">2. 容器组件|负责管理数据&#x2F;复杂逻辑?</span><br><span class="line">   UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</span><br><span class="line">3. Provider组件|容器组件获取state??</span><br><span class="line">   所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</span><br><span class="line">4. connect()|UI组件+容器组件</span><br><span class="line">   React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。</span><br></pre></td></tr></table></figure>

<h3 id="DVA与CRA相比的优点"><a href="#DVA与CRA相比的优点" class="headerlink" title="DVA与CRA相比的优点"></a>DVA与CRA相比的优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dva:</span><br><span class="line">	dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。--- 来自官方。</span><br><span class="line">	相比于cra只是多了内置的redux和redux-saga，帮我们处理了数据流这方面的需求而已。如果只是想要达到这个效果的话，直接在cra中增加dva-core的依赖也是可以做到的。</span><br><span class="line"></span><br><span class="line">umi:</span><br><span class="line">	是一个可插拔的企业级 react 应用框架。umi和cra都是应用框架，可能相比cra来说umi的功能点更多一些，只能说是功能性的话umi要相对来说更胜一筹</span><br></pre></td></tr></table></figure>

<h3 id="flux"><a href="#flux" class="headerlink" title="flux"></a>flux</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flux 是 react 中的类似于 vuex 的公共状态管理方案，它是 Facebook 官方给出的应用架构，利用数据的单向流动的形式对公共状态进行管理。现已不推荐使用。</span><br><span class="line"></span><br><span class="line">flux的组成</span><br><span class="line">	View：视图层</span><br><span class="line">	Action：视图发出的消息</span><br><span class="line">	Dispatcher：派发者，用来接收Action，执行回调函数</span><br><span class="line">	Store：数据层，存放状态，一旦发生改动</span><br><span class="line">	</span><br><span class="line">flux 在进行数据更新时，会经历以下几步：</span><br><span class="line">	用户与 View 层交互，触发 Action</span><br><span class="line">	Action 使用 dispatcher.dispatch 将Action自己的状态发送给dispatcher</span><br><span class="line">	dispatcher 通过register注册事件，再通过Action传入的类型来触发对应的 Store 回调进行更新</span><br><span class="line">	Store 里进行相应的数据更新，并触发 View 层事件使试图也同步更新</span><br><span class="line">	View层 收到信号进行更新</span><br><span class="line"></span><br><span class="line">redux和flux的区别</span><br><span class="line">　　1）redux是flux中的一个实现</span><br><span class="line">　　2）在redux中我们只能定义一个store，在flux中我们可以定义多个</span><br><span class="line">　　3）在redux中，store和dispatch都放到了store，结构更加清晰</span><br><span class="line">　　4）在redux中本身就内置State对象，对仓库的管理更加明确</span><br></pre></td></tr></table></figure>

<h3 id="React-中-keys-的作用"><a href="#React-中-keys-的作用" class="headerlink" title="React 中 keys 的作用"></a>React 中 keys 的作用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key是react用于追踪哪些列表被修改、被添加或者被移出的辅助标识。</span><br><span class="line"></span><br><span class="line">在开发过程中，我们需要保证某些元素在同级的元素中key是具有唯一性的特性，在react Diff算法中React会借助元素的key值来判断该元素是新创建的还是移动而来的元素，从而减少元素的不必要的重复渲染。此外，我们还需要借助key值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</span><br><span class="line"></span><br><span class="line">react根据key来决定是销毁重新创建组件还是更新组件，原则是：</span><br><span class="line"></span><br><span class="line">key相同，组件有所变化，react会只更新组件对应变化的属性。</span><br><span class="line">key不同，组件会销毁之前的组件，将整个组件重新渲染。</span><br></pre></td></tr></table></figure>

<h3 id="react新特性和diff算法"><a href="#react新特性和diff算法" class="headerlink" title="react新特性和diff算法"></a>react新特性和diff算法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render</span><br><span class="line">支持返回这五类:</span><br><span class="line">React elements, 数组, Fragments, Portal, String&#x2F;numbers, boolean&#x2F;null, 基础数据类型</span><br><span class="line"></span><br><span class="line">Fiber</span><br><span class="line">React Fiber的方法其实很简单——分片。把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。</span><br><span class="line"></span><br><span class="line">新的生命周期函数</span><br><span class="line">由于异步渲染的改动，componentWillMount, componentWillReceiveProps,componentWillUpdate 三个函数将被废弃。</span><br><span class="line">由于这是一个很大的改变会影响很多现有的组件，所以需要慢慢的去改。</span><br><span class="line">目前react 16 只是会报warning，在react 17就只能在前面加UNSAFE_的前缀来使用</span><br><span class="line"></span><br><span class="line">diff算法</span><br><span class="line">作用: 计算出Virtual DOM中真 正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面</span><br><span class="line"></span><br><span class="line">getDerivedStateFromProps</span><br><span class="line">static getDerivedStateFromProps(props, state)在调用render方法之前调用，</span><br><span class="line">无论是在初始安装还是后续更新。它应返回一个对象来更新状态，或者返回null以不更新任何内容。</span><br><span class="line"></span><br><span class="line">根据props更新state</span><br><span class="line">这个生命周期可用于替代componentWillReceiveProps</span><br><span class="line"></span><br><span class="line">getSnapshotBeforeUpdate()</span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)在最近呈现的输出被提交到例如DOM之前调用。它使组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate()。</span><br><span class="line"></span><br><span class="line">hooks</span><br><span class="line"></span><br><span class="line">lazy、suspense</span><br><span class="line">lazy需要跟Suspence配合使用。</span><br><span class="line">lazy实际上是帮助我们实现代码分割的功能。</span><br><span class="line"></span><br><span class="line">由于有些内容，并不一定要在首屏展示，所以这些资源没有必要一开始就要去获取，那么这些资源就可以动态获取。</span><br><span class="line">这样的话，相当于把不需要首屏展示的代码分割出来，减少首屏代码的体积，提升性能。</span><br><span class="line"></span><br><span class="line">Suspence 很像Error Boundary，不同的是Error Boundary是用来捕获错误，显示相应的callback组件。而Suspence是用来捕获还没有加载好的组件，并暂停渲染，显示相应的callback。</span><br></pre></td></tr></table></figure>

<h3 id="setState概述-同步异步"><a href="#setState概述-同步异步" class="headerlink" title="setState概述,同步异步"></a>setState概述,同步异步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 两个参数及用法</span><br><span class="line">	第一个参数可以是对象或者函数，是更新state   </span><br><span class="line">	第二个参数获取最新的state,副作用操作，dom操作事件触发声明，数据获取，第三方库实例化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 同步&#x2F;异步原理</span><br><span class="line">	setState在合成事件和钩子函数中是异步的 </span><br><span class="line">	在原生事件和setTimeout中是同步的</span><br><span class="line"></span><br><span class="line">setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</span><br><span class="line"></span><br><span class="line">setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</span><br></pre></td></tr></table></figure>

<h3 id="react合成事件"><a href="#react合成事件" class="headerlink" title="react合成事件"></a>react合成事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 合成事件原理</span><br><span class="line">   如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。</span><br><span class="line"></span><br><span class="line">当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。</span><br><span class="line">而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）</span><br><span class="line">所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。</span><br><span class="line"></span><br><span class="line">2. 与原生事件的区别</span><br><span class="line">   React合成事件一套机制：React并不是将click事件直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理。</span><br></pre></td></tr></table></figure>

<h3 id="react路由传参和读参"><a href="#react路由传参和读参" class="headerlink" title="react路由传参和读参"></a>react路由传参和读参</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.params</span><br><span class="line">&lt;Route path&#x3D;&#39;&#x2F;path&#x2F;:name&#39; component&#x3D;&#123;Path&#125;&#x2F;&gt;</span><br><span class="line">&lt;link to&#x3D;&quot;&#x2F;path&#x2F;2&quot;&gt;xxx&lt;&#x2F;Link&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;&#x2F;path&#x2F;&quot; + name&#125;);</span><br><span class="line">读取参数用:this.props.match.params.name</span><br><span class="line">优势:刷新地址栏，参数依然存在</span><br><span class="line">缺点:只能传字符串，并且，如果传的值太多的话，url会变得长而丑陋。</span><br><span class="line"></span><br><span class="line">2.query</span><br><span class="line">&lt;Route path&#x3D;&#39;&#x2F;query&#39; component&#x3D;&#123;Query&#125;&#x2F;&gt;</span><br><span class="line">&lt;Link to&#x3D;&#123;&#123; path : &#39; &#x2F;query&#39; , query : &#123; name : &#39;sunny&#39; &#125;&#125;&#125;&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;&#x2F;query&quot;,query: &#123; name : &#39;sunny&#39; &#125;&#125;);</span><br><span class="line">读取参数用: this.props.location.query.name</span><br><span class="line">优势: 传参优雅，传递参数可传对象；</span><br><span class="line">缺点: 刷新地址栏，参数丢失</span><br><span class="line"></span><br><span class="line">3.state</span><br><span class="line">&lt;Route path&#x3D;&#39;&#x2F;sort &#39; component&#x3D;&#123;Sort&#125;&#x2F;&gt;</span><br><span class="line">&lt;Link to&#x3D;&#123;&#123; path : &#39; &#x2F;sort &#39; , state : &#123; name : &#39;sunny&#39; &#125;&#125;&#125;&gt; </span><br><span class="line">this.props.history.push(&#123;pathname:&quot;&#x2F;sort &quot;,state : &#123; name : &#39;sunny&#39; &#125;&#125;);</span><br><span class="line">读取参数用: this.props.location.query.state </span><br><span class="line">优缺点同query</span><br><span class="line"></span><br><span class="line">4.search</span><br><span class="line">&lt;Route path&#x3D;&#39;&#x2F;web&#x2F;departManange &#39; component&#x3D;&#123;DepartManange&#125;&#x2F;&gt;</span><br><span class="line">&lt;link to&#x3D;&quot;web&#x2F;departManange?tenantId&#x3D;12121212&quot;&gt;xxx&lt;&#x2F;Link&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;&#x2F;web&#x2F;departManange?tenantId&quot; + row.tenantId&#125;);</span><br><span class="line">读取参数用: this.props.location.search</span><br><span class="line">优缺点同params</span><br></pre></td></tr></table></figure>

<h3 id="redux和mobx-类似双向数据绑定-区别"><a href="#redux和mobx-类似双向数据绑定-区别" class="headerlink" title="redux和mobx(类似双向数据绑定)区别"></a>redux和mobx(类似双向数据绑定)区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 组成部分</span><br><span class="line">   actions-&gt;state-&gt;computed values-&gt;Reactions</span><br><span class="line">2. 工作流</span><br><span class="line">   在mobx中， 数据是通过加 @observable 作为可监测的被观察者， 在view层中， 你可以通过添加@observer 将view作为观察者，对数据进行监测， 如果要触发改变数据，则使用@action, 事实上，你可以直接在view层改变数据， 但这种方式不便监控数据，因此不推荐直接改变数据。 而@computed可以用来计算数据， 也可以是计算多个数据之后返回新的数据， 如果其中数据改变， @computed也会触发改变</span><br><span class="line">3. 优点</span><br><span class="line">   不同于redux的单一数据流， mobx中，你可以同时在各个地方使用同一份state, 也可以在一个页面中使用多个store文件</span><br></pre></td></tr></table></figure>

<h3 id="react组件通信5种"><a href="#react组件通信5种" class="headerlink" title="react组件通信5种"></a>react组件通信5种</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.父组件向子组件通信</span><br><span class="line">React数据流动是单向的,父组件向子组件通信也是最常见的;父组件通过props向子组件传递需要的信息</span><br><span class="line"></span><br><span class="line">2.子组件向父组件通信</span><br><span class="line">利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。</span><br><span class="line"></span><br><span class="line">3.非嵌套组件间通信</span><br><span class="line">非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</span><br><span class="line">	利用二者共同父组件的 context 对象进行通信</span><br><span class="line">	使用自定义事件的方式</span><br><span class="line">如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以。</span><br><span class="line"></span><br><span class="line">4.跨组件通信</span><br><span class="line">所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</span><br><span class="line">	中间组件层层传递 props</span><br><span class="line">	使用 context 对象</span><br><span class="line">中间组件层层传递 props:</span><br><span class="line">    如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。</span><br><span class="line">    </span><br><span class="line">使用 context 对象:</span><br><span class="line">	context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。</span><br><span class="line">使用 context 也很简单，需要满足两个条件：</span><br><span class="line">	上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</span><br><span class="line">	子组件要声明自己需要使用 context</span><br><span class="line"></span><br><span class="line">5.redux</span><br><span class="line">首先由view dispatch拦截action，然后执行对应reducer并更新到store中，最终views会根据store数据的改变执行界面的刷新渲染操作。</span><br><span class="line">	1)首先先把redux相关工具安装好 </span><br><span class="line">	2)通过创建一个store实例createStore,接收一个rootReducer和中间件执行函数</span><br><span class="line">	3)创建分块的数据rootReducer,通过combineReducers打造rootReducer,里面放分块的数据</span><br><span class="line">	4)在组件中通过高阶组件connect函数,接收store里的数据,把ActionCreators里的方法绑定到组件身上,</span><br><span class="line">	  并且可以发送动作action给reducer</span><br><span class="line">	5)在reductor中根据action中的type动作类型,判断动作修改数据</span><br></pre></td></tr></table></figure>

<h3 id="组件按需加载"><a href="#组件按需加载" class="headerlink" title="组件按需加载"></a>组件按需加载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（实现方式，需要的依赖）懒加载</span><br><span class="line"></span><br><span class="line">1、vue异步组件技术</span><br><span class="line">	vue-router配置路由，使用vue的异步组件技术，可以实现按需加载。</span><br><span class="line">	但是，这种情况下一个组件生成一个js文件。</span><br><span class="line"></span><br><span class="line">2.import()</span><br><span class="line"></span><br><span class="line">3.webpack提供的require.ensure()</span><br><span class="line"></span><br><span class="line">4.第三方库比如react-loadable   </span><br><span class="line"></span><br><span class="line">5.lazyload-loader</span><br></pre></td></tr></table></figure>

<h3 id="组件销毁"><a href="#组件销毁" class="headerlink" title="组件销毁"></a>组件销毁</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentWillUnmount</span><br><span class="line"></span><br><span class="line">定义state  flag:false   作为开关   定义方法if判断是否为1,改变state    flag:true</span><br><span class="line"></span><br><span class="line">将方法绑定组件上  可以用三目或者短路原则&amp;&amp;控制组件的显示隐藏</span><br></pre></td></tr></table></figure>

<h3 id="Ant-D中input输入框三个属性怎么实现"><a href="#Ant-D中input输入框三个属性怎么实现" class="headerlink" title="Ant D中input输入框三个属性怎么实现"></a>Ant D中input输入框三个属性怎么实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onChange输入框内容改变时候回调    value输入的内容   defaultValue输入框默认值</span><br><span class="line"></span><br><span class="line">input默认值在input中绑定value    定义一个state   和input双向数据绑定    做成受控组件    定义一个事件   改变的时候获取e.target.value</span><br></pre></td></tr></table></figure>

<h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么使用hook</span><br><span class="line">	不必写class组件就可以用state和其他的React特性；</span><br><span class="line">	自定义hook  实现组件的复用    用useEffects代替生命周期方法   代码更加简洁</span><br><span class="line"></span><br><span class="line">出现原因3点</span><br><span class="line">    为了让函数组件拥有类组件的功能。</span><br><span class="line">    	原因</span><br><span class="line">    	比如useState、useReducer  状态定义</span><br><span class="line">    	比如useEffect、useLayoutEffect 生命周期功能</span><br><span class="line">    	比如useRef useImperativeHandle 替代了类组件的 Ref</span><br><span class="line">    为了优化函数组件，比如useMemo、useCallback</span><br><span class="line">	函数组件添加新的方法,如</span><br><span class="line">    	useDebugValue显示自定义hook，自己添加hook类名</span><br><span class="line">    	自定义hooks来复用状态</span><br><span class="line"></span><br><span class="line">优点4点</span><br><span class="line">1.让函数组件可以定义状态 </span><br><span class="line">	让函数组件可以使用生命周期、监听数据</span><br><span class="line">	让函数组件可以有Ref的功能（父组件获取子组件）</span><br><span class="line">	优化函数组件 useMemo、useCallback</span><br><span class="line">	自定义hooks来复用状态,</span><br><span class="line">	代码量比类组件更少，更清爽。</span><br><span class="line">2.使用规则2点</span><br><span class="line">	不要在循环，条件或嵌套函数中调用 Hook</span><br><span class="line">	只在函数组件中使用 Hooks</span><br><span class="line">3.常用Hook</span><br><span class="line">	useState:</span><br><span class="line">		定义状态 修改状态</span><br><span class="line">		返回一个数组，其中第一项是状态值，第二项是一个更新状态的函数。</span><br><span class="line">		状态一旦改变，React 就会重新渲染组件，变量获取新的状态值。</span><br><span class="line">	useEffect:</span><br><span class="line">		相当于componentDidMount,componentDidUpdate,componentWillUnmount三个钩子的组合</span><br><span class="line">		参数一：执行的回调函数；</span><br><span class="line">		参数二：该useEffect在哪些state发生变化时，才重新执行；</span><br><span class="line">		第二个参数是空数组的时候执行一次,相当于componentDidMount,不加的时候执行多次</span><br><span class="line">		第二个参数的作用就是 仅在更改时更新，实现性能的优化</span><br><span class="line">		DOM操作 第三方实例化可以做 清除无用实例和事件</span><br><span class="line">		useEffect传入的回调函数本身可以有一个返回值，</span><br><span class="line">		这个返回值是另外一个回调函数，来模拟componentWillUnmount</span><br><span class="line">	useLayoutEffect:</span><br><span class="line">		布局副作用</span><br><span class="line">			useEffect 在浏览器渲染完成后执行</span><br><span class="line">			useLayoutEffect 在浏览器渲染前执行</span><br><span class="line">		useLayoutEffect 里的任务最好影响了 Layout</span><br><span class="line">		为了用户体验，优先使用 useEffect (优先渲染)</span><br><span class="line">	useContext:</span><br><span class="line">		跨组件通信 createContext创建一个组件 &lt;numContext.Provider value&#x3D;&#123;num&#125;&gt;</span><br><span class="line">	useDebugValue:</span><br><span class="line">		自定义 hook 的标签 方便调试台查看</span><br><span class="line">	useMemo:</span><br><span class="line">		记忆组件 动态缓存 新值和旧值一样,不重新渲染页面,优化作用,类似于shouldComponentUpdate     	useCallBack:</span><br><span class="line">		作用和 useMemo 一样</span><br><span class="line">		useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行</span><br><span class="line">		并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。</span><br><span class="line">		useCallback(x &#x3D;&gt; console.log(x), [m]) 等价于</span><br><span class="line">		useMemo( () &#x3D;&gt; x &#x3D;&gt; console.log(x), [m])</span><br><span class="line">	useRef:</span><br><span class="line">		返回一个可变的ref对象</span><br><span class="line">	useImperativeHandle:</span><br><span class="line">		将组件中的方法放到外面使用</span><br><span class="line">		搭配React.forwardRef</span><br><span class="line"></span><br><span class="line">5.自定义hook</span><br><span class="line">   类似于高阶组件 </span><br><span class="line">   高阶组件返回的一个类组件，而自定义Hook可以返回任何东西</span><br><span class="line">   高阶组件必须传递一个组件作为参数，而自定义Hook不需要</span><br><span class="line">   function useFriendStatus(friendID) &#123;</span><br><span class="line">      const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line">      &#x2F;&#x2F; 在开发者工具中的这个 Hook 旁边显示标签</span><br><span class="line">      &#x2F;&#x2F; e.g. &quot;FriendStatus: Online&quot;</span><br><span class="line">      useDebugValue(isOnline ? &#39;Online&#39; : &#39;Offline&#39;);</span><br><span class="line">      return isOnline;</span><br><span class="line">   &#125;</span><br><span class="line">可以理解为数据的操作都在hook里进行，而外部只关心自己想要的。我只要数据列表，获取产品钩子（可能并不需要，可通过参数变更从而触发重新获取数据）、删除产品钩子</span><br><span class="line">为了封装方法：节流；</span><br></pre></td></tr></table></figure>

<h3 id="react-useState-Hook"><a href="#react-useState-Hook" class="headerlink" title="react useState() Hook"></a>react useState() Hook</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.使用 useState() 进行状态管理</span><br><span class="line">	调用useState() Hook 来启用函数组件中的状态。</span><br><span class="line">	useState(initialValue)的第一个参数initialValue是状态的初始值。</span><br><span class="line">	[state, setState] &#x3D; useState(initialValue)返回一个包含2个元素的数组:状态值和状态更新函数。</span><br><span class="line">	使用新值调用状态更新器函数setState(newState)更新状态。或者，可以使用一个回调setState(prev &#x3D;&gt; next)来调用状态更新器，该回调将返回基于先前状态的新状态。</span><br><span class="line">	调用状态更新器后，React 确保重新渲染组件，以使新状态变为当前状态。</span><br><span class="line">2.多种状态</span><br><span class="line">	通过多次调用useState()，一个函数组件可以拥有多个状态。</span><br><span class="line">	需要注意的，要确保对useState()的多次调用在渲染之间始终保持相同的顺序。</span><br><span class="line">3.状态的延迟初始化</span><br><span class="line">	每当 React 重新渲染组件时，都会执行useState(initialState)。如果初始状态是原始值（数字，布尔值等），则不会有性能问题。</span><br><span class="line">	当初始状态需要昂贵的性能方面的操作时，可以通过为useState(computeInitialState)提供一个函数来使用状态的延迟初始化，该函数仅在初始渲染时执行一次，以获得初始状态。在以后的组件渲染中，不会再调用该函数，从而跳过昂贵的操作。</span><br><span class="line">4.调用 useState()</span><br><span class="line">在使用useState() Hook 时，必须遵循 Hook 的规则：</span><br><span class="line">1.仅顶层调用Hook:不能在循环，条件，嵌套函数等中调用useState()。在多个useState()调用中，渲染之间的调用顺序必须相同。</span><br><span class="line">2.仅从React 函数调用 Hook:必须仅在函数组件或自定义钩子内部调用useState()。</span><br></pre></td></tr></table></figure>

<h3 id="高阶组件HOC"><a href="#高阶组件HOC" class="headerlink" title="高阶组件HOC"></a>高阶组件HOC</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.名词解释&#x2F;作用</span><br><span class="line">    使函数复用，可以通过给组件传递方法来复用高阶组件中的函数方法。</span><br><span class="line">    高阶组件特点</span><br><span class="line">    高阶组件是一个函数</span><br><span class="line">    高阶组件接收一个组件作为参数进行使用，且需要在render函数中return返回这个组件</span><br><span class="line">    高阶组件的目的是为了： 复用组件,将多个组件都要使用的类似逻辑放在同一个地方进行处理，类似于在Vue中封装cookie以供重复使用</span><br><span class="line">    </span><br><span class="line">2.常用高阶组件4个</span><br><span class="line">	React.memo()</span><br><span class="line">	connect()</span><br><span class="line">	provider()  </span><br><span class="line">	withRouter()  &#x2F;&#x2F; 可以使用</span><br><span class="line">3.有自己封装过吗  </span><br><span class="line">    拖拽封装，给组件里面的标签添加方法就可以实现拖拽，并返回标签的x与y坐标。</span><br><span class="line">	深对比，深复制封装、正则封装、页面路由跳转、路由数据接收解析。</span><br></pre></td></tr></table></figure>

<h3 id="拖拽封装思路"><a href="#拖拽封装思路" class="headerlink" title="拖拽封装思路"></a>拖拽封装思路</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">重点：</span><br><span class="line">1、一定要绝对定位，脱离文档流才可以移动。</span><br><span class="line">2、绑定拖拽的元素，移动和鼠标松开后是对document的绑定，因为移动的是整个div。</span><br><span class="line">3、点击：a&#x3D; 获取当前鼠标坐标、b &#x3D;div距浏览器距离、c &#x3D; 鼠标在div内部距离&#x3D;a-b。</span><br><span class="line">   移动：通过  a - c 建立鼠标与div的关系，防止鼠标超出div。</span><br><span class="line"></span><br><span class="line">拖拽状态 &#x3D; 0鼠标在元素上按下的时候&#123; </span><br><span class="line">	拖拽状态 &#x3D; 1 </span><br><span class="line">	记录下鼠标的x和y坐标 </span><br><span class="line">	记录下元素的x和y坐标 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">鼠标在元素上移动的时候&#123; </span><br><span class="line">	如果拖拽状态是0就什么也不做。 </span><br><span class="line">	如果拖拽状态是1，那么 </span><br><span class="line">	元素y &#x3D; 现在鼠标y - 原来鼠标y + 原来元素y </span><br><span class="line">	元素x &#x3D; 现在鼠标x - 原来鼠标x + 原来元素x </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">鼠标在任何时候放开的时候&#123; </span><br><span class="line">	拖拽状态 &#x3D; 0 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据请求封装思路"><a href="#数据请求封装思路" class="headerlink" title="数据请求封装思路"></a>数据请求封装思路</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义hook封装过组件吗"><a href="#自定义hook封装过组件吗" class="headerlink" title="自定义hook封装过组件吗"></a>自定义hook封装过组件吗</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.将Hello组件和App组件中共用的逻辑放在统一的自定义hook中写</span><br><span class="line">2.自定义hook,hook名以use开头</span><br><span class="line">3.其他组件通过import引入自定义hook,就可以使用了</span><br></pre></td></tr></table></figure>

<h3 id="react和vue的区别"><a href="#react和vue的区别" class="headerlink" title="react和vue的区别"></a>react和vue的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">相同点:</span><br><span class="line">1.都使用了虚拟dom,如果需要改变任何元素的状态,先改虚拟dom,当有变化产生时,会创建新的虚拟dom,通过diff算法对比新旧虚拟dom的差异,只需要渲染差异部分就行</span><br><span class="line">2.都使用组件化</span><br><span class="line"></span><br><span class="line">不同点:</span><br><span class="line">1.react中有新语法jsx,vue用普通的html   </span><br><span class="line">2.vue中父组件和子组件有通信的时候,父组件数据改变引起子组件改变,子组件会重新渲染，如果父子组件没有通信,父组件改变子组件不会渲染，react中不管是否有数据通信,父组件改变子组件都会渲染</span><br><span class="line">3.react:create-react-app</span><br><span class="line">  vue  :vue-cli</span><br><span class="line">4.react中用redux管理状态,state通过setState更新</span><br><span class="line">  vue中数据由vuex管理</span><br></pre></td></tr></table></figure>

<h3 id="react的class组件-没有class的时候怎么写"><a href="#react的class组件-没有class的时候怎么写" class="headerlink" title="react的class组件,没有class的时候怎么写"></a>react的class组件,没有class的时候怎么写</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React.createClass    </span><br><span class="line">我们最早使用这个方法来构建一个组件“类”，它接受一个对象为参数，</span><br><span class="line">对象中必须声明一个render方法，render返回一个组件实例</span><br></pre></td></tr></table></figure>

<h3 id="生命周期-钩子函数用es5怎么定义"><a href="#生命周期-钩子函数用es5怎么定义" class="headerlink" title="生命周期  钩子函数用es5怎么定义"></a>生命周期  钩子函数用es5怎么定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protoType.componentDidMount</span><br></pre></td></tr></table></figure>

<h3 id="虚拟dom和diff算法"><a href="#虚拟dom和diff算法" class="headerlink" title="虚拟dom和diff算法"></a>虚拟dom和diff算法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法 避免了没有必要的 dom 操作，从而提高性能</span><br><span class="line">具体实现步骤如下 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树， 插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两 棵树差异把2所记录的差异应用到步骤1所构建的真正的 DOM 树上，视图就更新</span><br><span class="line"></span><br><span class="line">1.虚拟dom是什么</span><br><span class="line">	所谓的虚拟 dom，也就是虚拟节点。它通过JS的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点</span><br><span class="line">	用js模拟一颗dom树,放在浏览器内存中。当你要变更时,虚拟dom使用diff算法进行新旧虚拟dom的比较,将变更放到变更队列中,反应到实际的dom树,减少了dom操作。</span><br><span class="line"></span><br><span class="line">2.虚拟dom的使用基本流程（前四步骤）</span><br><span class="line">	1.获取数据</span><br><span class="line">	2.创建虚拟dom</span><br><span class="line">	3.通过render函数解析jsx，将其转换成虚拟dom结构</span><br><span class="line">	4.将虚拟dom渲染成真实dom</span><br><span class="line">	5.数据更改了</span><br><span class="line">	6.使用diff算法比对两次虚拟dom,生成patch对象</span><br><span class="line">	7.根据key将patch对象渲染到页面中改变的结构上，而其他没有改变的地方是不做任何修改的(虚拟dom的惰性原则)</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">保证性能下限： </span><br><span class="line">	框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</span><br><span class="line">无需手动操作 DOM： </span><br><span class="line">	我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</span><br><span class="line">跨平台： </span><br><span class="line">	虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">无法进行极致优化： </span><br><span class="line">虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</span><br><span class="line"></span><br><span class="line">1.diff算法是什么</span><br><span class="line">	Diff算法是用于比较两个新旧虚拟dom树的差异的，比较完之后会得到一个差异对象，我们称之为patch补丁对象</span><br><span class="line">	比较后会出现四种情况：</span><br><span class="line">		1、此节点是否被移除 -&gt; 添加新的节点</span><br><span class="line">		2、属性是否被改变 -&gt; 旧属性改为新属性</span><br><span class="line">		3、文本内容被改变 -&gt; 旧内容改为新内容</span><br><span class="line">		4、节点要被整个替换 -&gt; 结构完全不相同 移除整个替换</span><br><span class="line"></span><br><span class="line">2.diff算法运行结束后，返回是什么</span><br><span class="line"> 返回一个key</span><br></pre></td></tr></table></figure>

<h3 id="react-Native"><a href="#react-Native" class="headerlink" title="react Native"></a>react Native</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React Native(内特服)能在手机上创建原生应用，React在这方面处于领先位置。使用JavaScript, CSS和HTML创建原生移动应用，这是一个重要的革新。Vue社区与阿里合作开发Vue版的React Native——Weex也很不错，但仍处于开发状态且并没经过实际项目的验证。</span><br><span class="line"></span><br><span class="line">既拥有Native的用户体验、又保留React的开发效率</span><br><span class="line"></span><br><span class="line">React Native与React.js的主要区别还是JSX,它使用XML标记的方式去直接声明界面，将HTML直接嵌入到JavaScript代码中</span><br></pre></td></tr></table></figure>

<h3 id="react-router-路由-原理"><a href="#react-router-路由-原理" class="headerlink" title="react-router(路由)原理"></a>react-router(路由)原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-router依赖基础 - history </span><br><span class="line"></span><br><span class="line">history是一个独立的第三方js库，可以用来兼容在不同浏览器、不同环境下对历史记录的管理</span><br><span class="line"></span><br><span class="line">老浏览器的history: </span><br><span class="line">	主要通过hash来实现，对应createHashHistory</span><br><span class="line">高版本浏览器: </span><br><span class="line">	通过html5里面的history，对应createBrowserHistory </span><br><span class="line">node环境下:                         (不弱惹)</span><br><span class="line">	主要存储在历史记录memeory里面，对应createMemoryHistory</span><br><span class="line">抽象了一个公共的文件createHistory:</span><br><span class="line">	此时的location跟浏览器原生的location是不相同的，最大的区别就在于里面多了key字段，</span><br><span class="line">	history内部通过key来进行location的操作</span><br><span class="line"></span><br><span class="line">原理:</span><br><span class="line">1.执行URL前进</span><br><span class="line">	createBrowserHistory: pushState、replaceState</span><br><span class="line">	createHashHistory: location.hash&#x3D;*** location.replace()</span><br><span class="line">	createMemoryHistory: 在内存中进行历史记录的存储</span><br><span class="line">1.检测URL回退</span><br><span class="line">	createBrowserHistory: popstate</span><br><span class="line">	createHashHistory: hashchange</span><br><span class="line">	createMemoryHistory: 因为是在内存中操作，跟浏览器没有关系，不涉及UI层面的事情，所以可以直接进行历史信息的回退</span><br><span class="line">1.state的存储</span><br><span class="line">	为了维护state的状态，将其存储在sessionStorage里面:</span><br><span class="line">	基本原理:实现URL与UI可视化界面的同步。其中在react-router中，URL对应Location对象，而UI是由react components来决定的，这样就转变成location与components之间的同步问题。</span><br><span class="line"></span><br><span class="line">在react-router中最主要的component是Router、RouterContext、Link，history库起到了中间桥梁的作用</span><br><span class="line"></span><br><span class="line">安装react-router-dom     </span><br><span class="line">	Link组件用于点击链接跳转其他页面，没有路由激活</span><br><span class="line">	NavLink 用于有路由激活效果的</span><br></pre></td></tr></table></figure>

<h3 id="react-router-dom和react-router的区别"><a href="#react-router-dom和react-router的区别" class="headerlink" title="react-router-dom和react-router的区别"></a>react-router-dom和react-router的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写法上的区别：</span><br><span class="line">import &#123;Swtich, Route, Router, HashHistory, Link&#125; from &#39;react-router-dom&#39;;</span><br><span class="line"></span><br><span class="line">import &#123;Switch, Route, Router&#125; from &#39;react-router&#39;;</span><br><span class="line">import &#123;HashHistory, Link&#125; from &#39;react-router-dom&#39;;</span><br><span class="line"></span><br><span class="line">react-router-dom: </span><br><span class="line">加入了在浏览器运行环境下的一些功能:</span><br><span class="line">	BrowserRouter和HashRouter组件，</span><br><span class="line">	前者使用pushState和popState事件构建路由，</span><br><span class="line">	后者使用window.location.hash和hashchange事件构建路由。</span><br><span class="line"></span><br><span class="line">react-router-dom是依赖于react-router的，其中Switch、Route、Router、Redirect等组件是直接引入react-router中的</span><br><span class="line"></span><br><span class="line">react-router-dom还另外新增了Link、BrowserRouter、HashRouter组件。</span><br><span class="line"></span><br><span class="line">在引入react-router-dom后不需要显性引入react-router，</span><br><span class="line">react-router-dom依赖react-router，npm都会将他们安装。</span><br><span class="line"></span><br><span class="line">react-router3.x与react-router-dom区别</span><br><span class="line">	react-router3.x版本下路由采用集中式配置，UI组件和路由是分开的。</span><br><span class="line">	react-router4.x版本下路由路由采用分散式配置，路由嵌套在UI组件当中，</span><br><span class="line">	更加契合组件化思想（组件中的路由也应该包含在组件之中）。</span><br></pre></td></tr></table></figure>

<h3 id="react路由模式"><a href="#react路由模式" class="headerlink" title="react路由模式"></a>react路由模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们一直在使用的路由方式是BrowserRouter，也就是浏览器的路由方式，其实React还有几种路由方式：</span><br><span class="line">					 (不弱惹)</span><br><span class="line">1、BrowserRouter：浏览器的路由方式，也就是在开发中最常使用的路由方式</span><br><span class="line">2、HashRouter：在路径前加入#号成为一个哈希值，Hash模式的好处是，再也不会因为我们刷新而找不到我们的对应路径</span><br><span class="line">3、MemoryRouter：不存储history，所有路由过程保存在内存里，不能进行前进后退，因为地址栏没有发生任何变化</span><br><span class="line">4、NativeRouter：经常配合ReactNative使用，多用于移动端</span><br><span class="line">5、StaticRouter：设置静态路由，需要和后台服务器配合设置，比如设置服务端渲染时使用</span><br><span class="line">  (斯大推克)</span><br></pre></td></tr></table></figure>

<h3 id="react路由配置"><a href="#react路由配置" class="headerlink" title="react路由配置"></a>react路由配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、引入路由包</span><br><span class="line">	npm install --save react-router</span><br><span class="line">	npm install --save react-router-dom</span><br><span class="line">	react-router：是基本的router包，里边函的内容较多，</span><br><span class="line">				  但是在网页开发中有很多用不到，现在的市面上的课程讲的基本都是这个包的教程。</span><br><span class="line">	react-router-dom：随着react生态环境的壮大，后出现的包，</span><br><span class="line">					  这个包比react-router包轻巧了很多。</span><br><span class="line">2、设置路由配置文件</span><br><span class="line">	在src目录下新建一个Router&#x2F;index.js文件用于管理路由，这里需要引入一些对应的组件和路由包文件。</span><br><span class="line">		Router的history是必需的props</span><br><span class="line">		Switch表示只渲染第一个与当前地址匹配的&lt;Route&gt;</span><br><span class="line">		Route的props path为路径，component为路径对应的页面</span><br><span class="line">		exact属性表示精确匹配,比如我们有多层路由进行嵌套时，exact可以帮助我们精确匹配到你想跳转的路由。		 exact的值为bool型，为true是表示严格匹配，为false时为正常匹配</span><br><span class="line"></span><br><span class="line">3、在入口文件引入路由配置文件</span><br><span class="line">	import RouterConfig from &#39;.&#x2F;router&#x2F;index.js&#39;;</span><br><span class="line">	ReactDOM.render(&lt;RouterConfig&#x2F;&gt;, document.getElementById(&#39;root&#39;));</span><br><span class="line">	</span><br><span class="line">4、在各组件中使用路由</span><br><span class="line">	&lt;ul className&#x3D;&quot;menu&quot;&gt;</span><br><span class="line">    	&lt;li&gt;&lt;NavLink to&#x3D;&#39;&#x2F;Page1&#39;&gt;第一个页面&lt;&#x2F;NavLink&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    	&lt;li&gt;&lt;NavLink to&#x3D;&#39;&#x2F;Page2&#39;&gt;第二个页面&lt;&#x2F;NavLink&gt;&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;&#x2F;ul&gt;</span><br><span class="line">	</span><br><span class="line">1.Switch:表示一次只渲染一个组件</span><br><span class="line">2.Route:路由组件,用于展示一个组件  同router-view</span><br><span class="line">3.Redirect:重定向(锐得埃克特)</span><br><span class="line">4.lazy + Suspense(色斯盘丝):实现路由懒加载</span><br><span class="line">5.exact:路径完全匹配</span><br><span class="line">6.fallback:组件切换时候的转场组件</span><br></pre></td></tr></table></figure>

<h3 id="react路由-router-实现异步加载"><a href="#react路由-router-实现异步加载" class="headerlink" title="react路由(router)实现异步加载"></a>react路由(router)实现异步加载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-router，官网文档给出的是用webpack的bundle-loader</span><br><span class="line"></span><br><span class="line">require.ensure。这是webpack的旧式写法，现在已不推荐</span><br><span class="line"></span><br><span class="line">import()</span><br><span class="line">	符合ECMAScript提议的import()语法，该提案与普通 import 语句或 require 函数的类似，</span><br><span class="line">	但返回一个 Promise 对象。这意味着模块时异步加载的</span><br></pre></td></tr></table></figure>

<h3 id="react原理"><a href="#react原理" class="headerlink" title="react原理"></a>react原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. setState  </span><br><span class="line">	setState在合成事件和钩子函数中是异步的 </span><br><span class="line">	在原生事件和setTimeout中是同步的</span><br><span class="line"></span><br><span class="line">	setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，</span><br><span class="line">	只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，</span><br><span class="line">	形式了所谓的“异步”，</span><br><span class="line"></span><br><span class="line">	第一个参数可以是对象或者函数  是更新state   </span><br><span class="line">	第二个参数获取最新的state,副作用操作    dom操作事件触发声明  数据获取</span><br><span class="line"></span><br><span class="line">2. JSX语法的转化</span><br><span class="line">	JSX 仅仅是 createElement() 方法的语法糖（简化语法）</span><br><span class="line">	JSX 语法被 @babel&#x2F;preset-react 插件编译为 createElement() 方法</span><br><span class="line">	react.createElement()</span><br><span class="line">	React 元素：是一个对象，用来描述你希望在屏幕上看到的内容</span><br><span class="line"></span><br><span class="line">3. 组件更新机制</span><br><span class="line">	setState() 的两个作用： 1. 修改 state 2. 更新组件（UI）</span><br><span class="line">	过程：父组件重新渲染时，也会重新渲染子组件。但只会渲染当前组件子树（当前组件及其所有子组件）   </span><br><span class="line"></span><br><span class="line">4. 组件性能优化</span><br><span class="line">	减轻 state：只存储跟组件渲染相关的数据</span><br><span class="line">	避免不必要的重新渲染 : shouldComponentUpdate(nextProps, nextState)    </span><br><span class="line">	通过返回值决定该组件是否重新渲染，返回 true 表示重新渲染，false 表示不重新渲染   起到优化作用</span><br><span class="line"></span><br><span class="line">5. 纯组件 PureComponent</span><br><span class="line">	PureComponent 内部自动实现了 shouldComponentUpdate 钩子，不需要手动比较    </span><br><span class="line">	纯组件内部通过分别 对比 前后两次 props 和 state 的值，来决定是否重新渲染组件 </span><br><span class="line">	纯组件内部的对比是 shallow compare（浅层对比）</span><br><span class="line"></span><br><span class="line">6. 虚拟 DOM 和 Diff 算法</span><br><span class="line">	数据改变视图更新</span><br><span class="line">	初次渲染时，React 会根据初始state（Model），创建一个虚拟 DOM 对象（树）。</span><br><span class="line">	根据虚拟 DOM 生成真正的 DOM，渲染到页面中。</span><br><span class="line">	当数据变化后（setState()，重新根据新的数据，创建新的虚拟DOM对象（树）。</span><br><span class="line">	与上一次得到的虚拟 DOM 对象，使用 Diff 算法 对比（找不同），生成patch补丁对象,得到需要更新的内容。</span><br><span class="line">	最终，React 只将变化的内容更新（patch）到 DOM 中，重新渲染到页面。</span><br></pre></td></tr></table></figure>

<h3 id="react的connect高阶组件实现-如何在全局中取得store"><a href="#react的connect高阶组件实现-如何在全局中取得store" class="headerlink" title="react的connect高阶组件实现, 如何在全局中取得store"></a>react的connect高阶组件实现, 如何在全局中取得store</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">连接React组件与 Redux store。</span><br><span class="line">connect:connect函数的返回值是一个高阶组件,通过高阶组件来获取store中的数据     </span><br><span class="line">connect底层原理:是闭包</span><br><span class="line"></span><br><span class="line">mapStateFromProps:从countReducer中解构出num数据,用来获取数据</span><br><span class="line">mapDispatchFromProps:将ActionCreators中的方法绑定到组件上,并且发送action</span><br><span class="line"></span><br><span class="line">connect调用的结果是返回一个高阶组件</span><br><span class="line">connect方法利用了合并分发的原理来帮助我们完成store内容的获取</span><br><span class="line"></span><br><span class="line">合并： 将store中的所有数据拿到手</span><br><span class="line">分发： 将我们UI需要的数据派发出去</span><br><span class="line"></span><br><span class="line">原理 </span><br><span class="line">合并分发 ：合并的意思是：(我们项目中)redux的数据是集中在一处的</span><br><span class="line">分发的意思是：给的是所有数据中的分块的数据</span><br></pre></td></tr></table></figure>

<h3 id="react的connect实现原理"><a href="#react的connect实现原理" class="headerlink" title="react的connect实现原理"></a>react的connect实现原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先connect之所以会成功，是因为Provider组件：</span><br><span class="line">在原应用组件上包裹一层，使原来整个应用成为Provider的子组件</span><br><span class="line">接收Redux的store作为props，通过context对象传递给子孙组件上的connect</span><br><span class="line"></span><br><span class="line">那connect做了些什么呢？</span><br><span class="line">它真正连接 Redux 和 React，它包在我们的容器组件的外一层，</span><br><span class="line">它接收上面 Provider 提供的 store 里面的 state 和 dispatch，</span><br><span class="line">传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。</span><br><span class="line"></span><br><span class="line">关于它的源码</span><br><span class="line">connect是一个高阶函数，首先传入mapStateFromProps、mapDispatchFromProps，</span><br><span class="line">然后返回一个生产Component的函数(wrapWithConnect)，</span><br><span class="line">然后再将真正的Component作为参数传入wrapWithConnect，</span><br><span class="line">这样就生产出一个经过包裹的Connect组件，该组件具有如下特点:</span><br><span class="line"></span><br><span class="line">通过props.store获取祖先Component的store</span><br><span class="line">props包括stateProps、dispatchProps、parentProps,合并在一起得到nextState，作为props传给真正的Component</span><br><span class="line">componentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互</span><br><span class="line">shouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextState</span><br><span class="line">componentWillUnmount时移除注册的事件this.handleChange</span><br></pre></td></tr></table></figure>

<h3 id="react-router3和react-router4-的区别"><a href="#react-router3和react-router4-的区别" class="headerlink" title="react-router3和react-router4 的区别"></a>react-router3和react-router4 的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、V3或者说V早期版本是把router 和 layout components 分开</span><br><span class="line">　	在V4中是：</span><br><span class="line">		集中式 router</span><br><span class="line">		通过 &lt;Route&gt; 嵌套，实现 Layout 和 page 嵌套</span><br><span class="line">		Layout 和 page 组件 是作为 router 的一部分</span><br><span class="line">二、在V3中，我们是将整个庞大的router直接丢给Dom</span><br><span class="line">　　在V4中，除了BrowserRouter，我们丢给DOM的我们的程序本身</span><br><span class="line"></span><br><span class="line">　　另外，V4 中，我们不再使用 &#123;props.children&#125; 来嵌套组件了，</span><br><span class="line">　　替代的 &lt;Route&gt;，当 route 匹配时，子组件会被渲染到 &lt;Route&gt; 书写的地方</span><br><span class="line"></span><br><span class="line">三、在V3 中的 routing 规则是 exclusive，意思就是最终只获取一个 route</span><br><span class="line">　　而 V4 中的 routes 默认是 inclusive 的，这就意味着多个 &lt;Route&gt;可以同时匹配和呈现</span><br><span class="line"></span><br><span class="line">　　如果只想匹配一个路由，可以使用Switch，在 &lt;Switch&gt; 中只有一个 &lt;Route&gt; 会被渲染，</span><br><span class="line">　　同时可以再在每个路由添加exact，做到精准匹配</span><br><span class="line"></span><br><span class="line">　　Redirect，浏览器重定向，当多有都不匹配的时候，进行匹配</span><br></pre></td></tr></table></figure>

<h3 id="react中获取真实的dom节点"><a href="#react中获取真实的dom节点" class="headerlink" title="react中获取真实的dom节点"></a>react中获取真实的dom节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用ref属性获取Dom元素后，再使用原生javascript获取内容</span><br></pre></td></tr></table></figure>

<h3 id="react是什么层面上的框架"><a href="#react是什么层面上的框架" class="headerlink" title="react是什么层面上的框架"></a>react是什么层面上的框架</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React框架本身和我们常用的JavaScript MVC框架，如：AngularJS，Backbone，Ember等，没有直接的可比性。</span><br><span class="line">React的官方博客中明确阐述了React不是一个MVC框架，</span><br><span class="line">而是一个用于构建组件化UI的库，是一个前端界面开发工具。所以顶多算是MVC中的V（view）。</span><br></pre></td></tr></table></figure>

<h3 id="react数据流"><a href="#react数据流" class="headerlink" title="react数据流"></a>react数据流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React遵循从上到下的数据流向，即单向数据流。</span><br><span class="line"></span><br><span class="line">单向数据流并非‘单向绑定’，甚至单向数据流与绑定没有‘任何关系’。</span><br><span class="line">对于React来说，单向数据流（从上到下）与单一数据源这两个原则，</span><br><span class="line"></span><br><span class="line">限定了React中要想在一个组件中更新另一个组件的状态（类似于Vue的平行组件传参，或者是子组件向父组件传递参数）</span><br><span class="line">，需要进行状态提升。即将状态提升到他们最近的祖先组件中。</span><br><span class="line"></span><br><span class="line">子组件中Change了状态，触发父组件状态的变更，父组件状态的变更，</span><br><span class="line">影响到了另一个组件的显示（因为传递给另一个组件的状态变化了，这一点与Vue子组件的$emit()方法很相似）。</span><br></pre></td></tr></table></figure>

<h3 id="react数据一定要在DidMount里获取更新的原因"><a href="#react数据一定要在DidMount里获取更新的原因" class="headerlink" title="react数据一定要在DidMount里获取更新的原因"></a>react数据一定要在DidMount里获取更新的原因</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。</span><br><span class="line">在这方法中调用setState方法，会触发重渲染。这个方法就是用来加载外部数据用的，或处理其他的副作用代码。</span><br><span class="line"></span><br><span class="line">constructor()</span><br><span class="line">	constructor()中获取数据的话，如果时间太长，或者出错，组件就渲染不出来，整个页面都没法渲染了。</span><br><span class="line">	constructor是作组件state初绐化工作，并不是设计来作加载数据的。</span><br><span class="line"></span><br><span class="line">componentWillMount()</span><br><span class="line">	如果使用SSR（服务端渲染）,componentWillMount会执行2次，一次在服务端，一次在客户端。</span><br><span class="line">	而componentDidMount不会。</span><br><span class="line">	</span><br><span class="line">	constructor可以完成state初始化，componentWillMount使用的很少，目前16版本加入了UNSAFE来标识		componentWillMount，新的生命周期static getDerivedStateFromProps() 也会替代这个。</span><br><span class="line"></span><br><span class="line">	React16之后采用了Fiber架构，只有componentDidMount声明周期函数是确定被执行一次的，</span><br><span class="line">	类似ComponentWillMount的生命周期钩子都有可能执行多次，</span><br><span class="line">	所以不加以在这些生命周期中做有副作用的操作，比如请求数据之类。</span><br><span class="line"></span><br><span class="line">render()</span><br><span class="line">	无限render</span><br><span class="line"></span><br><span class="line">componentDidMount()</span><br><span class="line">	确保已经render过一次。提醒我们正确地设置初始状态，这样就不会得到导致错误的&quot;undefined&quot;状态。</span><br></pre></td></tr></table></figure>

<h3 id="react中的受控组件和非受控组件"><a href="#react中的受控组件和非受控组件" class="headerlink" title="react中的受控组件和非受控组件"></a>react中的受控组件和非受控组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">受控组件</span><br><span class="line">	HTML中的表单元素是可输入的，也就是有自己的可变状态</span><br><span class="line">	而React中可变状态通常保存在state中，并且只能通过setState()方法来修改</span><br><span class="line">	React讲state与表单元素值value绑定在一起，有state的值来控制表单元素的值</span><br><span class="line">	简单来说，值受到react控制的表单元素</span><br><span class="line">	</span><br><span class="line">非受控组件</span><br><span class="line">	调用 React.createRef() 方法创建ref对象</span><br><span class="line">	将创建好的 ref 对象添加到文本框中</span><br><span class="line">	通过ref对象获取到文本框的值</span><br><span class="line">	简单来说，表单组件没有value prop就可以称为非受控组件</span><br></pre></td></tr></table></figure>

<h3 id="react中的ref的3种方式"><a href="#react中的ref的3种方式" class="headerlink" title="react中的ref的3种方式"></a>react中的ref的3种方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式1: string类型绑定</span><br><span class="line">类似于vue中的ref绑定方式，可以通过this.refs.绑定的ref的名字获取到节点dom</span><br><span class="line">注意的是 这种方式已经不被最新版的react推荐使用，有可能会在未来版本中遗弃</span><br><span class="line"> </span><br><span class="line">方式2: react.CreateRef()</span><br><span class="line">通过在class中使用React.createRef()方法创建一些变量，可以将这些变量绑定到标签的ref中</span><br><span class="line">那么该变量的current则指向绑定的标签dom</span><br><span class="line"> </span><br><span class="line">方式3: 函数形式</span><br><span class="line">在class中声明函数，在函数中绑定ref</span><br><span class="line">使用这种方法可以将子组件暴露给父组件以使得父组件能够调用子组件的方法</span><br><span class="line">通过函数的方法绑定ref可以将整个子组件暴露给父组件</span><br><span class="line"></span><br><span class="line">当在子组件中调用onRef函数时，正在调用从父组件传递的函数。this.props.onRef（this）这里的参数指向子组件本身，父组件接收该引用作为第一个参数：onRef &#x3D; &#123;ref &#x3D;&gt;（this.child &#x3D; ref）&#125;然后它使用this.child保存引用。之后，可以在父组件内访问整个子组件实例，并且可以调用子组件函数。</span><br></pre></td></tr></table></figure>

<h3 id="react中的static-静态方法"><a href="#react中的static-静态方法" class="headerlink" title="react中的static(静态方法)"></a>react中的static(静态方法)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">静态方法和 React 没有直接关系，React 的组件都是继承自 React.Component 这个类，静态方法属于类本身。</span><br><span class="line"></span><br><span class="line">static并不是react定义的，而加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用。</span><br><span class="line"></span><br><span class="line">这里涉及到了ES6的class，我们定义一个组件的时候通常是定义了一个类，</span><br><span class="line">而static则是创建了一个属于这个类的属性或者方法。</span><br><span class="line">组件则是这个类的一个实例，component的props和state是属于这个实例的，</span><br></pre></td></tr></table></figure>

<h3 id="react的props与state的区别"><a href="#react的props与state的区别" class="headerlink" title="react的props与state的区别"></a>react的props与state的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props:</span><br><span class="line">一般用于父组件向子组件通信，在组件之间通信使用。</span><br><span class="line">state: </span><br><span class="line">一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等。</span><br></pre></td></tr></table></figure>

<h3 id="混合开发"><a href="#混合开发" class="headerlink" title="混合开发"></a>混合开发</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 混合开发是介于webapp和原生app之间的一种应用，它同时具有webapp可以跨平台的特性，也具备原生app可以进行安装使用的特性</span><br><span class="line">2. webApp  </span><br><span class="line">   1. 优点： 跨平台 、 维护更新、项目迭代快</span><br><span class="line">   2. 缺点： 交互体验不好 、进入应用的方式麻烦</span><br><span class="line">3. 原生app</span><br><span class="line">   1.案例： 美团、饿了吗、微信、QQ </span><br><span class="line">   2.安装在手机中使用的 </span><br><span class="line">   3.优点： 手机安装、交互体验好 </span><br><span class="line">   4.缺点： 维护更新、项目迭代很慢、成本太高了</span><br><span class="line">4. 混合开发： 择中方案</span><br><span class="line">   跨平台</span><br><span class="line">   维护更新快   成本低</span><br><span class="line">   手机安装，交互体验好</span><br><span class="line"></span><br><span class="line">为什么混合开发会兴起呢？</span><br><span class="line">1. 混合开发的兴起是偶然的</span><br><span class="line"></span><br><span class="line">混合开发方式</span><br><span class="line">1. h5 主导</span><br><span class="line">   - 开发思维： H5【 vue&#x2F; react&#x2F; angular 】 + 第三方可以访问原生设备的库</span><br><span class="line">     - 微信公众号： h5网页 + 微信JSSDK </span><br><span class="line">   - 历史</span><br><span class="line">      1. PhoneGap + cordva.js 淘汰</span><br><span class="line">      2. vue&#x2F;react&#x2F;angular + ioinc.js </span><br><span class="line">      3. vue - uni-app </span><br><span class="line">      4. h5 + h5plus.js   h5 + h5+</span><br><span class="line">      5. 微信公众号： webapp + js-jdk </span><br><span class="line">      6. vue&#x2F;react + weex.js[ 阿里内部 ]</span><br><span class="line">2. React Native</span><br><span class="line">   1. facebook 团队项目  16 - 18年很热火，18年后半年开始热度下降，</span><br><span class="line">   	  facebook觉得这个框架对于开发者而言开发难度太大，维护成本也高，Facebook决定不再更新它了、</span><br><span class="line">   2. 典型应用： 饿了吗</span><br><span class="line">   3. React Native开发出来项目 - 原生app </span><br><span class="line">   4. React Native  &#x3D; React + 原生js</span><br><span class="line">   5. 构建React Native项目 - 脚手架   </span><br><span class="line">      1. 构建项目环境: create-react-native-app  </span><br><span class="line">      2. 手机调试：expo  expo-cli</span><br><span class="line">      3. 目录解释</span><br><span class="line">         1. __test__   expo手机调试的测试文件夹，不用管</span><br><span class="line">         2. .expo  临时文件，运行项目</span><br><span class="line">         3. .expo-shared 分享</span><br><span class="line">         4. assets 静态资源</span><br><span class="line">         5. components  公共组件</span><br><span class="line">         6. constants  项目公用的常量</span><br><span class="line">         7. navigation  底部tabbar栏组件</span><br><span class="line">         8. node_modules  依赖包</span><br><span class="line">         9. screens   页面</span><br></pre></td></tr></table></figure>

<h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><p>对于路由的触发方式以及页面生命周期函数如下:</p>
<table>
<thead>
<tr>
<th>路由方式</th>
<th>触发时机</th>
<th>路由前页面</th>
<th>路由后页面</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>小程序打开的第一个页面</td>
<td></td>
<td>onLoad, onSHow</td>
</tr>
<tr>
<td>打开新页面</td>
<td>调用 API wx.navigateTo 或使用组件 <navigator open-type="navigateTo"/></td>
<td>onHide</td>
<td>onLoad, onShow</td>
</tr>
<tr>
<td>页面重定向</td>
<td>调用 API wx.redirectTo 或使用组件 <navigator open-type="redirectTo"/></td>
<td>onUnload</td>
<td>onLoad, onShow</td>
</tr>
<tr>
<td>页面返回</td>
<td>调用 API wx.navigateBack 或使用组件<navigator open-type="navigateBack">或用户按左上角返回按钮</td>
<td>onUnload</td>
<td>onShow</td>
</tr>
<tr>
<td>Tab 切换</td>
<td>调用 API wx.navigateBack 或使用组件<navigator open-type="navigateBack">或用户按调用 API wx.switchTab 或使用组件 <navigator open-type="switchTab"/> 或用户切换 Tab</td>
<td></td>
<td>各种情况请参考下表</td>
</tr>
<tr>
<td>重启动</td>
<td>调用 API wx.reLaunch 或使用组件 <navigator open-type="reLaunch"/></td>
<td>onUnload</td>
<td>onLoad, onShow</td>
</tr>
</tbody></table>
<p>页面跳转触发的生命周期，其实还是存在问题的，并非官方所说的那样。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">SwitchTab的跳转BUG</span><br><span class="line">首页跳转到子页面后，在子页面上使用：</span><br><span class="line">&lt;navigator type=<span class="string">&#x27;switchTab&#x27;</span> url=<span class="string">&quot;/pages/index/index&quot;</span> &gt;</span><br><span class="line">    &lt;view&gt;跳转首页&lt;/button&gt;</span><br><span class="line">&lt;/navigator&gt;</span><br><span class="line">这种方式有问题，解决的办法是通过JS来实现跳转，代码如下：</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;weui-btn-area&quot;</span>&gt;</span><br><span class="line">             &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;weui-btn&quot;</span> bindtap=<span class="string">&quot;backIndex&quot;</span> type=<span class="string">&quot;default&quot;</span>&gt;返回主页&lt;/button&gt; </span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">跳转成功后，重新调用onload方法，JS代码如下：</span><br><span class="line">backIndex:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    wx.switchTab(&#123;</span><br><span class="line">      url: <span class="string">&#x27;/pages/index/index&#x27;</span>,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> page = getCurrentPages().pop();</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">undefined</span> || page == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        page.onLoad();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="get与post的区别"><a href="#get与post的区别" class="headerlink" title="get与post的区别"></a>get与post的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.提交方式</span><br><span class="line">get: get会将接收到的数据拼接到url地址中,以&quot;?&quot;问号划分,问号后面是接收到的数据,多个数据之间用&amp;连接。用户可以很直观的看见。</span><br><span class="line">post: post会将接收到的数据放置在html header中一起发送到指定的url地址内。用户看不到这个过程。</span><br><span class="line"></span><br><span class="line">2.传递数据大小</span><br><span class="line">get: get传递数据的大小因为受到浏览器地址栏的限制,所以一般在2k-8k,这要据浏览器而定,比如谷歌浏览器就是8k。</span><br><span class="line">post: post传递数据的大小最小是2M,但理论上是无上限的。</span><br><span class="line"></span><br><span class="line">3.应用范围</span><br><span class="line">get: get一般用于获取&#x2F;查询资源信息.多用于a标签的href属性中,也常用于location.href属性中。</span><br><span class="line">post: post一般是用于更新数据信息.多用于表单提交。</span><br><span class="line"></span><br><span class="line">4.安全性</span><br><span class="line">get的安全性比post较差。</span><br></pre></td></tr></table></figure>

<h3 id="react父组件通过ref获取不到子组件的解决方案"><a href="#react父组件通过ref获取不到子组件的解决方案" class="headerlink" title="react父组件通过ref获取不到子组件的解决方案"></a>react父组件通过ref获取不到子组件的解决方案</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在子组件中</span><br><span class="line">this.customfunction &#x3D; this.customfunction.bind(this);</span><br><span class="line">即可</span><br></pre></td></tr></table></figure>

<h3 id="React-PureComponent-和-Component-区别"><a href="#React-PureComponent-和-Component-区别" class="headerlink" title="React PureComponent 和 Component 区别"></a>React PureComponent 和 Component 区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()。</span><br><span class="line">　　如果React组件的 render() 函数在给定相同的props和state下渲染为相同的结果，在某些场景下你可以使用 React.PureComponent 来提升性能。</span><br><span class="line">　　React.PureComponent 的 shouldComponentUpdate() 只会对对象进行浅对比。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新, 原文：false-negatives)。当你期望只拥有简单的props和state时，才去继承 PureComponent ，或者在你知道深层的数据结构已经发生改变时使用 forceUpate() 。或者，考虑使用 不可变对象 来促进嵌套数据的快速比较。</span><br><span class="line">　　此外,React.PureComponent 的 shouldComponentUpate() 会忽略整个组件的子级。请确保所有的子级组件也是”Pure”的。</span><br><span class="line">　　</span><br><span class="line">PureComponent的作用：</span><br><span class="line">	PureComponent 其实是在内部帮我们简单实现了一下shouldComponentUpdate的功能，以便提供组件的性能；这里的简单指是：对prop和state做浅比较，若浅比较结果相同，则该组件以及其子组件不做render；否则，render。</span><br><span class="line"></span><br><span class="line">使用PureComponent注意事项：</span><br><span class="line">	PureComponent主要针对prop和state为基本数据类型，如bool、string、number；</span><br><span class="line">	对于数组和对象等引用类型，则要引用不同，才会渲染；如果引用相同，则PureComponent浅比较返回结果相同，不做render；</span><br><span class="line">	PureComponent 中不建议再另外重写shouldComponentUpdate方法，否则会报warning信息：</span><br><span class="line">	PureComponent的最好作为展示组件，如果prop和state每次都会变，PureComponent做浅比较也会影响性能，可以考虑直接用Component；</span><br><span class="line">	对于prop和state数据结构比较复杂的情况，可以考虑自己重写shouldComponentUpdate方法来做优化；</span><br></pre></td></tr></table></figure>

<h3 id="react中调用setState之后发生"><a href="#react中调用setState之后发生" class="headerlink" title="react中调用setState之后发生"></a>react中调用setState之后发生</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React会将当前传入的参数对象与组件当前的状态合并,然后触发调和过程,在调和的过程中,React会以相对高效的方式根据新的状态构建React元素树并且重新渲染整个UI界面.</span><br><span class="line"></span><br><span class="line">React得到的元素树之后,React会自动计算出新的树与老的树的节点的差异,然后根据差异对界面进行最小化的渲染,在React的差异算法中,React能够精确的知道在哪些位置发生看改变以及应该如何去改变,这样就保证了UI是按需更新的而不是重新渲染整个界面</span><br></pre></td></tr></table></figure>

<h3 id="SPA和MPA的异同"><a href="#SPA和MPA的异同" class="headerlink" title="SPA和MPA的异同"></a>SPA和MPA的异同</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单页应用（SinglePage Application，SPA）</span><br><span class="line">	指只有一个主页面的应用，一开始只需加载一次 js,css 等相关资源。所有的内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅刷新局部资源。</span><br><span class="line"></span><br><span class="line">多页应用（MultiPage Application，MPA）</span><br><span class="line">	指有多个独立的页面的应用，每个页面必须重复加载 js,css 等相关资源。多页应用跳转，需要整页资源刷新。</span><br><span class="line">	</span><br><span class="line">两者对比表格：</span><br><span class="line"> 	                    SPA	   |||     MPA</span><br><span class="line">结构:一个主页面 + 许多模块的组件	  |||   许多完整的页面</span><br><span class="line">体验:页面切换快，体验佳；当初次加载文件过多时，需要做相关的调优。 |||	页面切换慢，网速慢的时候，体验尤其不好</span><br><span class="line">资源文件:组件公用的资源只需要加载一次 |||	每个页面都要自己加载公用的资源</span><br><span class="line">适用场景:对体验度和流畅度有较高要求的应用，不利于 SEO（可借助 SSR 优化 SEO）  |||	适用于对 SEO 要求较高的应用</span><br><span class="line">过渡动画:Vue 提供了 transition 的封装组件，容易实现	|||	很难实现</span><br><span class="line">内容更新:相关组件的切换，即局部更新	|||	整体 HTML 的切换，费钱（重复 HTTP 请求）</span><br><span class="line">路由模式:可以使用 hash ，也可以使用 history  |||	普通链接跳转</span><br><span class="line">数据传递:因为单页面，使用全局变量就好（Vuex）  |||	cookie 、localStorage 等缓存方案，URL 参数，调用接口保存等</span><br><span class="line">相关成本:前期开发成本较高，后期维护较为容易	|||	前期开发成本低，后期维护就比较麻烦，因为可能一个功能需要改很多地方</span><br><span class="line"></span><br><span class="line">单页应用实现核心：前端路由</span><br><span class="line">前端路由的核心：改变视图的同时不会向后端发出请求。</span><br></pre></td></tr></table></figure>

<h3 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TS好处：</span><br><span class="line">1、强类型 </span><br><span class="line">2、不需要去浏览器中浏览效果，就能知道编译错误</span><br><span class="line">   静态类型检查可以做到early fail，即你编写的代码即使没有被执行到，一旦你编写代码时发生类型不匹配，</span><br><span class="line">   语言在编译阶段（解释执行也一样，可以在运行前）即可发现</span><br><span class="line">4、类型就是最好的注释，看类型我们就知道这个是什么</span><br><span class="line">3、即使ts中有编译报错，tsc依旧可以将其编译成js</span><br><span class="line"></span><br><span class="line">学习TS的基本数据类型</span><br><span class="line">定类型是为了安全，规矩多就安全</span><br><span class="line">1、基础数据类型 ：number \string\boolean\null\undefined</span><br><span class="line">	any 表示任意类型 void 表示空类型，空类型是针对函数的，表示函数没有返回值。返回空</span><br><span class="line">2、内置对象类型 ： Array \  Boolean \  HTMLElement</span><br><span class="line">3、自定义类型 : 接口  类  泛型  枚举类型</span><br></pre></td></tr></table></figure>

<h3 id="TS-中-interface-和-type-的区别"><a href="#TS-中-interface-和-type-的区别" class="headerlink" title="TS 中 interface 和 type 的区别"></a>TS 中 interface 和 type 的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在ts中，定义类型由两种方式：接口（interface）和类型别名（type alias）</span><br><span class="line">interface只能定义对象类型，</span><br><span class="line">type声明的方式可以定义组合类型，交叉类型和原始类型</span><br><span class="line"> </span><br><span class="line">如果用type alias 声明的方式，会导致一些功能的缺失</span><br><span class="line"> 	1.interface方式可以实现接口的extends&#x2F;implements，而type 不行</span><br><span class="line">	2.interface可以实现接口的merge，但是type不行</span><br></pre></td></tr></table></figure>

<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack打包react  vue,与自己的源代码分离使用splitchunks</span><br><span class="line">webpack热更新:不用刷新浏览器而将新变更的模块替换掉旧的模块。</span><br><span class="line"></span><br><span class="line">webpack会分析每个入口文件，解析包依赖关系的各个文件，每个模块都打包到bundle.js。webpack给每个模块分配一个唯一的ID并通过这个ID索引和访问模块。页面运行时，先启动entry.js，其他模块会在运行require时候执行。</span><br><span class="line"></span><br><span class="line">1.Webpack  Loader   Plugin</span><br><span class="line"></span><br><span class="line">（loader ，plugin分别什么作用，哪个配置可以把依赖包抽离出来，不打包进去）</span><br><span class="line">【Loader】：用于对模块源码的转换，loader描述了webpack如何处理非javascript模块，并且在buld中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。babel-loader优雅降级配置ES高版本转成低版本</span><br><span class="line"></span><br><span class="line">【Plugin】：是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作,</span><br><span class="line"></span><br><span class="line">依赖包抽离  const ExtractTextWebapckPlugin&#x3D; require(&quot;extract-text-webpack-plugin&quot;)    module    exclude node_modules</span><br><span class="line"></span><br><span class="line">排除excloude排除node_modules</span><br><span class="line"></span><br><span class="line">loader的使用很简单：</span><br><span class="line"></span><br><span class="line">在webpack.config.js中指定loader。module.rules可以指定多个loader，对项目中的各个loader有个全局概览。</span><br><span class="line"></span><br><span class="line">loader是运行在NodeJS中，可以用options对象进行配置。plugin可以为loader带来更多特性。loader可以进行压缩，打包，语言翻译等等。</span><br><span class="line"></span><br><span class="line">loader从模板路径解析，npm install node_modules。也可以自定义loader，命名XXX-loader。</span><br><span class="line"></span><br><span class="line">语言类的处理器loader：CoffeeScript，TypeScript，ESNext（Bable）,Sass,Less,Stylus。任何开发技术栈都可以使用webpack。</span><br><span class="line"></span><br><span class="line">webpack常用的loader</span><br><span class="line"></span><br><span class="line">样式：style-loader、css-loader、less-loader、sass-loader等</span><br><span class="line">文件：raw-loader、file-loader 、url-loader等</span><br><span class="line">编译：babel-loader、coffee-loader 、ts-loader等</span><br><span class="line">校验测试：mocha-loader、jshint-loader 、eslint-loader等</span><br><span class="line"></span><br><span class="line">目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。</span><br><span class="line"></span><br><span class="line">webpack功能强大，难点在于它的配置文件，webpack4默认不需要配置文件，可以通过mode选项为webpack指定了一些默认的配置，mode分为：development&#x2F;production，默认是production。</span><br><span class="line"></span><br><span class="line">插件可以携带参数，所以在plugins属性传入new实例。</span><br><span class="line"></span><br><span class="line">webpack常用的plugin</span><br><span class="line">webpack内置UglifyJsPlugin，压缩和混淆代码。</span><br><span class="line">webpack内置CommonsChunkPlugin，提高打包效率，将第三方库和业务代码分开打包。</span><br><span class="line">ProvidePlugin：自动加载模块，代替require和import</span><br><span class="line"></span><br><span class="line">html-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件extract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件</span><br><span class="line"></span><br><span class="line">DefinePlugin 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。</span><br><span class="line"></span><br><span class="line">【Mode】可以在config文件里面配置，也可以在CLI参数中配置：webpack--mode&#x3D;production（一般会选择在CLI，也就是npm scripts里面进行配置）。</span><br><span class="line"></span><br><span class="line">在webpack4以下版本，webpack3.XX，通过plugins进行环境变量的配置。</span><br><span class="line"></span><br><span class="line">【resolve】模块，resolver是个库，帮助webpack找到bundle需要引入的模块代码，打包时，webpack使用enhanced-resolve来解析路径。 </span><br><span class="line"></span><br><span class="line">2.webpack优化</span><br><span class="line">多进程打包   安装插件thread-loader   parallel-webpack   HappyPack</span><br><span class="line"></span><br><span class="line">多进程压缩   parallel-uglify-plugin    terser-webpack-plugin</span><br><span class="line">资源CDN    公用代码提取，使用 CDN 加载</span><br><span class="line">动态polyfill     动态 polyfill 指的是根据不同的浏览器，动态载入需要的 polyfill</span><br></pre></td></tr></table></figure>

<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex是由 flex-grow:1父容器在主轴上还有多少剩余空间，</span><br><span class="line"></span><br><span class="line">flex-shrink当父元素的宽度大于所有子元素的宽度的和时（即父元素会有剩余空间），</span><br><span class="line">子元素如何分配父元素的剩余空间</span><br><span class="line"></span><br><span class="line">flex-basis基准值组成</span><br><span class="line"></span><br><span class="line">flex 怎么实现1个盒子垂直居中	如何实现四个盒子水平均匀分布</span><br><span class="line"></span><br><span class="line">父容器 display:flex; justify-content: center; align-items: center;</span><br><span class="line"></span><br><span class="line">display: flex; justify-content:space-evenly; align-items: center;</span><br></pre></td></tr></table></figure>

<h3 id="实现导航的吸顶效果"><a href="#实现导航的吸顶效果" class="headerlink" title="实现导航的吸顶效果"></a>实现导航的吸顶效果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置css:fixed固定定位    </span><br><span class="line"></span><br><span class="line">判断滚动条滚动的距离大于导航条距顶部的距离,来判断是否实现吸顶,然后addClass添加样式</span><br></pre></td></tr></table></figure>

<h3 id="less的hover简写"><a href="#less的hover简写" class="headerlink" title="less的hover简写"></a>less的hover简写</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">	&amp;:hover &#123;&#125; &#x2F;&#x2F;这里&amp;代表它的上一级就是a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS伪类-after-before的应用场景"><a href="#CSS伪类-after-before的应用场景" class="headerlink" title="CSS伪类 ::after,before的应用场景"></a>CSS伪类 ::after,before的应用场景</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">::before和::after必须配合content属性来使用，</span><br><span class="line">content用来定义插入的内容，content必须有值，至少是空。</span><br><span class="line">默认情况下，伪类元素的display是默认值inline，可以通过设置display:block来改变其显示。</span><br><span class="line"></span><br><span class="line">1.清除浮动:</span><br><span class="line">在浮动元素后面添加一个空的Div标签，然后在设置它的清除浮动要是，使用after伪元素</span><br><span class="line"></span><br><span class="line">2.常见消息框 : </span><br><span class="line">伪类content:&#39; &#39;  伪类4条边必须宽度相同，而且其他三条边为transparent     </span><br><span class="line">可以通过设置定位元素left,top值为50%,translate(-50%,-50%) 来使任意宽高的元素居中。</span><br><span class="line"></span><br><span class="line">div::before&#123;</span><br><span class="line">          content:&#39; &#39;;</span><br><span class="line"></span><br><span class="line">3.阴影 : 通过设置before，after不同位置，不同旋转角度,要保证伪类的颜色及z-index</span><br><span class="line"></span><br><span class="line">div.outer::before,div.outer::after&#123;content:&#39;&#39;;</span><br><span class="line">            z-index:1;</span><br><span class="line">            width:50%;</span><br><span class="line">            height:3px;</span><br><span class="line">            position:absolute;</span><br><span class="line">            left:10px;</span><br><span class="line">            bottom:7px;</span><br><span class="line">            background-color:transparent;</span><br><span class="line">            box-shadow:5px 5px 10px rgba(0,0,0,0.5);</span><br><span class="line">            -webkit-transform:rotate(-3deg);</span><br><span class="line"></span><br><span class="line">4.做出各种图形效果</span><br><span class="line"></span><br><span class="line">#star-five:before &#123;</span><br><span class="line">            border-bottom: 80px solid red;</span><br><span class="line">            border-left: 30px solid transparent;</span><br><span class="line">            border-right: 30px solid transparent;</span><br><span class="line">            position: absolute;</span><br><span class="line">            height: 0;</span><br><span class="line">            width: 0;</span><br><span class="line">            top: -45px;</span><br><span class="line">            left: -65px;</span><br><span class="line">            content: &#39;&#39;;</span><br><span class="line">            transform: rotate(-35deg);</span><br><span class="line">        &#125;</span><br><span class="line">        #star-five:after &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">            height: 0;</span><br><span class="line">            border-left: 100px solid transparent;</span><br><span class="line">            border-right: 100px solid transparent;</span><br><span class="line">            border-bottom: 70px solid yellow;</span><br><span class="line">            top: 7px;</span><br><span class="line">            left: -110px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            display: block;</span><br><span class="line">            content: &#39;&#39;;</span><br><span class="line">            transform: rotate(-70deg);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS权重的计算"><a href="#CSS权重的计算" class="headerlink" title="CSS权重的计算"></a>CSS权重的计算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">权重叠加 0,0,0,5 + 0,0,0,5 &#x3D;0,0,0,10 而不是 0,0,1,0，所以不会存在10个div能赶上一个类选择器的情况</span><br><span class="line"></span><br><span class="line">继承的权重是0   </span><br><span class="line">1)如果选中了，那么以上面的公式来计权重。谁大听谁的。</span><br><span class="line">2)如果没有选中，那么权重是0，因为继承的权重为0</span><br><span class="line"></span><br><span class="line">当选择器冲突时，权重高的生效；当权重相同时，写在后头的会把前面的覆盖。</span><br></pre></td></tr></table></figure>

<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http2.0，https连接，</span><br><span class="line"></span><br><span class="line">http概述:超文本传输协议,是互联网上应用最为广泛的一种网络协议</span><br><span class="line"></span><br><span class="line">http的缺点</span><br><span class="line">1.通信使用明文可能会被窃听。</span><br><span class="line">2.不验证通信方的身份可能遭遇伪装。</span><br><span class="line">3.无法证明报文的完整性，可能已遭篡改。</span><br><span class="line"></span><br><span class="line">https就是在安全的传输层上发送的http。它在将http报文发送给TCP之前，先将其发送给了一个安全层 ，对其进行加密。http安全层是通过ssl及其现代替代协议TSL来实现的。</span><br><span class="line"></span><br><span class="line">https的优点</span><br><span class="line">（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</span><br><span class="line">（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</span><br><span class="line"></span><br><span class="line">https的缺点</span><br><span class="line">但是https因为加了层ssl，所以在效率方面比较低，会使页面加载的时长延长近50%,也会增加10-20%的耗电。</span><br><span class="line">需要安装证书，在一定基础上增加部署费用，并且报文加密解密对数据传递有一点的效率影响。</span><br><span class="line"></span><br><span class="line">http&#x2F;2.0的目标是改善用户加载页面的时候更快</span><br><span class="line">HTTP&#x2F;2采用二进制格式而非文本格式</span><br><span class="line">HTTP&#x2F;2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行</span><br></pre></td></tr></table></figure>

<h3 id="http对称加密非对称加密"><a href="#http对称加密非对称加密" class="headerlink" title="http对称加密非对称加密"></a>http对称加密非对称加密</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对称密钥加密是指加密和解密使用同一个密钥的方式,一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文</span><br><span class="line"></span><br><span class="line">非对称加密是加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</span><br></pre></td></tr></table></figure>

<h3 id="WebSocket和http有什么区别"><a href="#WebSocket和http有什么区别" class="headerlink" title="WebSocket和http有什么区别"></a>WebSocket和http有什么区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket是传输控制层协议，webSocket是应用层协议</span><br><span class="line"></span><br><span class="line">WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。</span><br><span class="line">一开始的握手需要借助HTTP请求完成。</span><br><span class="line"></span><br><span class="line">HTTP请求缺点：</span><br><span class="line">会导致过多不必要的请求，浪费流量和服务器资源，每一次请求、应答，都浪费了一定流量在相同的头部信息上</span><br><span class="line"></span><br><span class="line">然而WebSocket的出现可以弥补这一缺点。</span><br><span class="line">在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握	手的动作，然后单独建立一条TCP的通信通道进行数据的传送。</span><br><span class="line"></span><br><span class="line">原理:(webSocket)</span><br><span class="line">WebSocket同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的。</span><br><span class="line"></span><br><span class="line">1. 浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。</span><br><span class="line">2. TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）</span><br><span class="line">3. 服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。</span><br><span class="line">4. 当收到了连接成功的消息后，通过TCP通道进行传输通信。</span><br><span class="line"></span><br><span class="line">WebSocket与HTTP的关系</span><br><span class="line">相同点:</span><br><span class="line">都是一样基于TCP的，都是可靠性传输协议。</span><br><span class="line">都是应用层协议</span><br><span class="line"></span><br><span class="line">不同点:</span><br><span class="line">WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。</span><br><span class="line">WebSocket是需要握手进行建立连接的。</span><br></pre></td></tr></table></figure>

<h3 id="错误调试工具"><a href="#错误调试工具" class="headerlink" title="错误调试工具"></a>错误调试工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F12    断点   错误附近输出打印    火狐中的firebug    IE开发者工具   Emmet</span><br></pre></td></tr></table></figure>

<h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200	OK	请求成功。一般用于GET与POST请求</span><br><span class="line">3开头 重定向</span><br><span class="line">300	多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</span><br><span class="line">301	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</span><br><span class="line">302	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</span><br><span class="line">303	查看其它地址。与301类似。使用GET和POST请求查看</span><br><span class="line">304	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</span><br><span class="line">305	使用代理。所请求的资源必须通过代理访问</span><br><span class="line">306	已经被废弃的HTTP状态码</span><br><span class="line">307	临时重定向。与302类似。使用GET请求重定向</span><br><span class="line">400	客户端请求的语法错误，服务器无法理解</span><br><span class="line">401	请求要求用户的身份认证</span><br><span class="line">402	保留，将来使用</span><br><span class="line">403	服务器理解请求客户端的请求，但是拒绝执行此请求</span><br><span class="line">404	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</span><br><span class="line">405	客户端请求中的方法被禁止</span><br><span class="line">406	N服务器无法根据客户端请求的内容特性完成请求</span><br><span class="line">407	请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</span><br><span class="line">408	服务器等待客户端发送的请求时间过长，超时</span><br><span class="line">409	服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</span><br><span class="line">410	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</span><br><span class="line">411	服务器无法处理客户端发送的不带Content-Length的请求信息</span><br><span class="line">412	客户端请求信息的先决条件错误</span><br><span class="line">413	由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</span><br><span class="line">414	请求的URI过长（URI通常为网址），服务器无法处理</span><br><span class="line">415	服务器无法处理请求附带的媒体格式</span><br><span class="line">416	客户端请求的范围无效</span><br><span class="line">417	服务器无法满足Expect的请求头信息</span><br><span class="line">500	服务器内部错误，无法完成请求</span><br><span class="line">501	服务器不支持请求的功能，无法完成请求</span><br><span class="line">502 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</span><br><span class="line">503	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</span><br><span class="line">504	充当网关或代理的服务器，未及时从远端服务器获取请求</span><br><span class="line">505	服务器不支持请求的HTTP协议的版本，无法完成处理</span><br></pre></td></tr></table></figure>

<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP是超文本传输协议，信息是明文传输的，HTTPS是具有ssl&#x2F;tls加密传输协议。</span><br><span class="line"></span><br><span class="line">默认端口不同，前者是80，后者是443。</span><br><span class="line"></span><br><span class="line">HTTPS比HTTP安全</span><br><span class="line"></span><br><span class="line">HTTPS协议需要到CA申请证书，需要一定费用</span><br></pre></td></tr></table></figure>

<h3 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">什么是浏览器缓存 </span><br><span class="line">	Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。浏览器和网站服务器是根据缓存机制进行缓存的</span><br><span class="line"></span><br><span class="line">非HTTP协议定义的缓存机制</span><br><span class="line">	浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta 标签，Web开发者可以在HTML页面的&lt;head&gt;节点中加入&lt;meta&gt;标签</span><br><span class="line">	</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;Pragma&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">	上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。</span><br><span class="line">	</span><br><span class="line">浏览器在第一次请求发生后，再次请求时：</span><br><span class="line">	浏览器会先获取该资源缓存的header信息，根据其中的expires和cache-control判断是否命中强缓存），若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；  </span><br><span class="line">	如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified&#x2F;IF-Modified-Since、Etag&#x2F;IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容</span><br></pre></td></tr></table></figure>

<h3 id="浏览器的强缓存和协商缓存"><a href="#浏览器的强缓存和协商缓存" class="headerlink" title="浏览器的强缓存和协商缓存"></a>浏览器的强缓存和协商缓存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。</span><br><span class="line"></span><br><span class="line">浏览器缓存主要有以下几个优点：</span><br><span class="line">1. 减少重复数据请求，避免通过网络再次加载资源，节省流量。</span><br><span class="line">2. 降低服务器的压力，提升网站性能。</span><br><span class="line">3. 加快客户端加载网页的速度，提升用户体验。</span><br><span class="line"></span><br><span class="line">浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：</span><br><span class="line">1. 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。</span><br><span class="line">2. 在chrome中强缓存（虽然没有发出真实的http请求）的请求状态码返回是200(from cache)；而协商缓存如果命中走缓存的话，请求的状态码是304(not modified)。不同浏览器的策略不同，在Fire Fox中，from cache状态码是304.</span><br><span class="line"></span><br><span class="line">强缓存</span><br><span class="line">强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。</span><br><span class="line">Expires:</span><br><span class="line">	该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</span><br><span class="line">Cache-Control:</span><br><span class="line">	Cache-Control是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age&#x3D;3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值：</span><br><span class="line">	</span><br><span class="line">no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，</span><br><span class="line">		如果之前的响应中存ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</span><br><span class="line">no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</span><br><span class="line">public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</span><br><span class="line">private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</span><br><span class="line"></span><br><span class="line">Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。</span><br><span class="line"></span><br><span class="line">为什么要有Etag</span><br><span class="line">HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</span><br><span class="line">	</span><br><span class="line">1.一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)</span><br><span class="line">	这个时候我们并不希望客户端认为这个文件被修改了，而重新GET</span><br><span class="line">2.某些文件修改非常频繁，</span><br><span class="line">	比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</span><br><span class="line">3.某些服务器不能精确的得到文件的最后修改时间。</span><br><span class="line">	</span><br><span class="line">Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</span><br><span class="line"></span><br><span class="line">200 OK（from cache）与304 Not Modified的区别</span><br><span class="line">	200 OK( from cache )不向服务器发送请求，直接使用本地缓存文件。</span><br><span class="line">	304 Not Modified则向服务器询问，若服务器认为浏览器的缓存版本还可用，那么便会返回304。</span><br><span class="line"></span><br><span class="line">缓存类型	获取资源形式	  状态码	               发送请求到服务器</span><br><span class="line">强缓存	     从缓存取	    200（from cache）	       否，直接从缓存取</span><br><span class="line">协商缓存	从缓存取	   304（Not Modified）	  否，通过服务器来告知缓存是否可用</span><br><span class="line"></span><br><span class="line">用户行为对缓存的影响</span><br><span class="line">用户操作		  Expires&#x2F;Cache-Control		    Last-Modied&#x2F;Etag</span><br><span class="line">地址栏回车		    有效							有效</span><br><span class="line">页面链接跳转	       有效						    有效</span><br><span class="line">新开窗口		     有效						     有效</span><br><span class="line">前进回退	         有效	                         有效</span><br><span class="line">F5刷新	          无效	                       有效</span><br><span class="line">Ctrl+F5强制刷新	     无效	                          无效</span><br></pre></td></tr></table></figure>

<h3 id="不能被缓存的请求"><a href="#不能被缓存的请求" class="headerlink" title="不能被缓存的请求"></a>不能被缓存的请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），</span><br><span class="line">   或Cache-Control:max-age&#x3D;0等告诉浏览器不用缓存的请求</span><br><span class="line">2. 需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的</span><br><span class="line">3. 经过HTTPS安全加密的请求</span><br><span class="line">4. POST请求无法被缓存</span><br><span class="line">5. HTTP响应头中不包含Last-Modified&#x2F;Etag，也不包含Cache-Control&#x2F;Expires的请求无法被缓存</span><br></pre></td></tr></table></figure>

<h3 id="用户行为对缓存的影响"><a href="#用户行为对缓存的影响" class="headerlink" title="用户行为对缓存的影响"></a>用户行为对缓存的影响</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qq、fire fox 、safari 、chrome 这几个浏览器的访问同一个页面，不同的浏览器在 F5 刷新的时候 ，同一个文件 qq 、fire fox 浏览器会返回 &#96;304 Not Nodified&#96;，在请求头中不携带 &#96;Expires&#x2F;Cache-Control&#96;； 而 chrome 和 safari 刷新的时候，会返回 &#96;200 from cache&#96;， 没有真正发起请求，走强缓存。可见不同的浏览器反馈是不一致的，所以下面表格中&quot;F5刷新&quot;时 &#96;Expires&#x2F;Cache-Control&#96; 会无效我认为是存在一定争议的。而 Ctrl + F5 强制刷新的时候，会暂时禁用强缓存和协商缓存。</span><br></pre></td></tr></table></figure>

<h3 id="eslint规则"><a href="#eslint规则" class="headerlink" title="eslint规则"></a>eslint规则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Eslint 是一个JavaScript验证工具,有了它可以让你的编辑器像ide一样进行一些静态的错误提示功能.</span><br><span class="line"></span><br><span class="line">npm install eslint -g</span><br><span class="line"></span><br><span class="line">某些文件关闭eslint检测  </span><br><span class="line">	在文件的最顶端加上注释 &#x2F;*eslint-disable*&#x2F;</span><br><span class="line"></span><br><span class="line">关闭某一行代码的eslint检查   </span><br><span class="line">	&#x2F;&#x2F; eslint-disable-next-line</span><br><span class="line"></span><br><span class="line">.eslintrc.json配置rules选项</span><br></pre></td></tr></table></figure>

<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（版本回退是什么命令，哪个命令查看已删除的提交commitId）</span><br><span class="line"></span><br><span class="line">git-reset 版本回退</span><br><span class="line"></span><br><span class="line">git reset --hard xxx	回到上一个版本</span><br><span class="line"></span><br><span class="line">git reset --soft xxx 该命令将最近一次提交节点的提交记录回退到暂存区</span><br><span class="line"></span><br><span class="line">git reset --mixed xxx	是将最近一次提交节点记录回退到工作区</span><br><span class="line"></span><br><span class="line">git log 与 git reflog 查看历史记录（被删除的历史commit ID）</span><br><span class="line"></span><br><span class="line">git场景问题</span><br><span class="line">提交暂存区git  add 出错    git reset HEAD &lt;文件名&gt; 回退</span><br><span class="line"></span><br><span class="line">提交本地仓库  </span><br><span class="line">git  commit出错: </span><br><span class="line">1.更改 commit 信息:git commit --amend -m“新提交消息”   </span><br><span class="line">2.漏提交:git add missed-file              &#x2F;&#x2F; missed-file 为遗漏提交文件</span><br><span class="line">		git commit --amend --no-edit     &#x2F;&#x2F;--no-edit提交消息不会更改</span><br><span class="line">3.git reset --hard commit_id      git  log查看提交的版本</span><br><span class="line"></span><br><span class="line">git revert 是提交一个新的版本</span><br><span class="line">git fetch  将远程主机的更新全部放到本地中</span><br><span class="line"></span><br><span class="line">git revert 和 git reset 的区别:</span><br><span class="line"></span><br><span class="line">(1)git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。</span><br><span class="line">(2)git revert是用一次逆向的commit“中和”之前的提交   ,合并的时候回滚的变化不会出现</span><br><span class="line"></span><br><span class="line">git reset是之间把某些commit在某个branch上删除,合并时候回滚的commit会被引入</span><br></pre></td></tr></table></figure>

<h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Node不是一个后端语言，但是它可以做类似后端语言的功能</span><br><span class="line">2.Node是使用谷歌V8引擎</span><br><span class="line">3.Node是js的一个运行环境</span><br><span class="line">4.Node具有非阻塞I&#x2F;O 特点</span><br><span class="line">5.Node采用了Common.js规范  </span><br><span class="line"></span><br><span class="line">node+koa2   node+express</span><br><span class="line"></span><br><span class="line">用于快速构建Node.js项目</span><br><span class="line"></span><br><span class="line">node.js 是一个基于 Chrome V8 引擎的 JavaScirpt 运行环境。</span><br><span class="line"></span><br><span class="line">Node.js使用了一个事件驱动、非阻塞式I&#x2F;O的模型,使其轻量又高效**</span><br><span class="line"></span><br><span class="line">Node.js基于commonjs规范</span><br><span class="line"></span><br><span class="line">事件驱动： 任务执行，发布者，订阅者，事件驱动 .</span><br><span class="line">异步（非阻塞）： 执行某一个任务的同时也可以执行其他任务</span><br><span class="line">同步（阻塞）： 执行某一个任务，这个任务如果没有执行完成，其他任务必须等待</span><br><span class="line">I&#x2F;O: 输入&#x2F;输出（ 数据库操作，文件系统操作等  ） - 服务器的环境</span><br><span class="line">非阻塞I&#x2F;O模型： 当使用Node.js来实现数据库操作、文件系统等操作时，要进行的异步操作，异步操作的核心传统实现方式就是回调函数和事件。</span><br><span class="line"></span><br><span class="line">Node.js的包管理工具npm</span><br><span class="line"></span><br><span class="line">优点：Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，异步编程，使其轻量又高效。</span><br><span class="line">缺点：单进程，单线程，只支持单核cpu，不能充分的利用多核cpu服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。</span><br><span class="line"></span><br><span class="line">内置模块 http 是用于创建一个能够处理和响应 http 响应的服务</span><br><span class="line"></span><br><span class="line">fs 用于对系统文件及目录进行读写操作。</span><br><span class="line">path 提供了一些用于处理文件路径的小工具</span><br><span class="line">Url：帮助我们对提交上来的url进行解析处理</span><br><span class="line">querystring  提供用于解析和格式化 URL 查询字符串的工具。qs.parse()   qs.stringify()</span><br></pre></td></tr></table></figure>

<h3 id="TS语法"><a href="#TS语法" class="headerlink" title="TS语法"></a>TS语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeScript具有类型系统，且是JavaScript的超集。它可以编译成普通的JavaScript代码。 </span><br><span class="line">TypeScript支持任意浏览器，任意环境，任意系统并且是开源的。</span><br><span class="line"></span><br><span class="line">npm install -g typescript</span><br><span class="line"></span><br><span class="line">tsc --init 生成tsconfig.json配置文件</span><br><span class="line"></span><br><span class="line">基础数据类型</span><br><span class="line">number、string、boolean、null 、undefined</span><br><span class="line">any 表示任意类型</span><br><span class="line">void 表示空类型</span><br><span class="line">内置对象类型</span><br><span class="line">	Array Boolean</span><br><span class="line">	HTMLElement</span><br><span class="line">	HTMLDivElement</span><br><span class="line">自定义类型</span><br><span class="line">接口 interface</span><br><span class="line">类</span><br><span class="line">泛型  未来的类型定义的时候不知道是什么类型，调用的时候才知道</span><br><span class="line"></span><br><span class="line">元组  </span><br><span class="line">1、数组中的数据类型必须和规定的类型顺序对应起来</span><br><span class="line">2、当使用越界索引给数组赋值的时候，会使用联合类型（只要值是规定类型的某一种即可）。</span><br><span class="line"></span><br><span class="line">枚举  enum类型是对JavaScript标准数据类型的一个补充</span><br><span class="line"></span><br><span class="line">never类型表示的是那些永不存在的值的类型。</span><br><span class="line"></span><br><span class="line">readonly:只读属性,不可修改</span><br><span class="line"></span><br><span class="line">sex? :表示sex是一个可传属性,可以有也可以没有</span><br><span class="line"></span><br><span class="line">[propName: string]: any;表示新增的属性可以是任意类型</span><br><span class="line"></span><br><span class="line">arr3: Array&lt;number&gt;  数组类型定义</span><br><span class="line"></span><br><span class="line">arr2: (number | string)[]</span><br><span class="line"></span><br><span class="line">fn (a: number, b: number) : number  函数类型定义</span><br></pre></td></tr></table></figure>

<h3 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd:输入pwd命令，Linux会输出当前目录。</span><br><span class="line"></span><br><span class="line">ls命令用来查看目录的内容。</span><br><span class="line"></span><br><span class="line">cd命令用来改变所在目录。</span><br><span class="line"></span><br><span class="line">cat命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。</span><br><span class="line"></span><br><span class="line">grep命令的最大功能是在一堆文件中查找一个特定的字符串。</span><br><span class="line"></span><br><span class="line">touch命令用来创建新文件</span><br><span class="line"></span><br><span class="line">cp命令用来拷贝文件</span><br><span class="line"></span><br><span class="line">mv命令用来移动文件</span><br><span class="line"></span><br><span class="line">rm命令用来删除文件。 </span><br><span class="line"></span><br><span class="line">mkdir   创建文件夹创建目录</span><br></pre></td></tr></table></figure>

<h3 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 圆角边框：border-radius </span><br><span class="line">2 多背景图：background </span><br><span class="line">3 颜色和透明度：background: rgba(0,0,0,.5) </span><br><span class="line">4 多列布局和弹性盒：display: flex</span><br><span class="line">5 盒子的变幻（2D、3D）</span><br><span class="line">	transform: translate(50px,100px);&#x2F;&#x2F;移动 </span><br><span class="line">	transform: rotate();             &#x2F;&#x2F;旋转 </span><br><span class="line">	transform: scale();  			 &#x2F;&#x2F;缩放</span><br><span class="line">	transform: skew();  			 &#x2F;&#x2F;倾斜 </span><br><span class="line">6 过渡 transition: width 1s linear 2s; </span><br><span class="line">动画：animation: myfirst 5s;</span><br><span class="line">@keyframes myfirst &#123; 0% &#123;background: block;&#125; 25% &#123;background: red;&#125; 50% &#123;background: yellow;&#125; 100% &#123;background: green;&#125; &#125; </span><br><span class="line">7 引入web字体（在服务器端存储） </span><br><span class="line">8 媒体查询 </span><br><span class="line">9 阴影 h</span><br><span class="line">10 文字阴影 text-shadow div </span><br><span class="line">11 盒子阴影 box-shadow</span><br></pre></td></tr></table></figure>

<h3 id="HTML5-h5新特性"><a href="#HTML5-h5新特性" class="headerlink" title="HTML5  h5新特性"></a>HTML5  h5新特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 语义化标签 section aside header nav</span><br><span class="line">2 表单新特性：autofocus 自动获取焦点</span><br><span class="line">	placeholder 占位</span><br><span class="line">	multiple</span><br><span class="line">	autocomplete  自动补全，是否自动记录之前提交的数据，以用于下一次输入建议</span><br><span class="line">	required 在表单提交时会验证是否有输入，没有则弹出提示消息。</span><br><span class="line">	min：限定输入数字的最小值。</span><br><span class="line">	max：限定输入数字的最大值</span><br><span class="line">3 video（视频）和audio（音频） </span><br><span class="line">4 canvas画布 </span><br><span class="line">5 webworker  就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。</span><br><span class="line">6 webscoket  服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</span><br><span class="line">7 拖拽api</span><br><span class="line">	dragstart：源对象开始拖放。 </span><br><span class="line">	drag：源对象拖放过程中。 </span><br><span class="line">	dragend：源对象拖放结束。 </span><br><span class="line">	过程对象： </span><br><span class="line">	dragenter：源对象开始进入过程对象范围内。 </span><br><span class="line">	dragover：源对象在过程对象范围内移动。 </span><br><span class="line">	dragleave：源对象离开过程对象</span><br></pre></td></tr></table></figure>

<h3 id="标准盒模型与怪异盒模型区别"><a href="#标准盒模型与怪异盒模型区别" class="headerlink" title="标准盒模型与怪异盒模型区别"></a>标准盒模型与怪异盒模型区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标准盒模型一个块的总宽度&#x3D; width + margin(左右) + padding(左右) + border(左右) </span><br><span class="line">怪异盒模型一个块的总宽度&#x3D; width + margin(左右)（即width已经包含了padding和 border值）</span><br></pre></td></tr></table></figure>

<h3 id="CSS3弹性盒"><a href="#CSS3弹性盒" class="headerlink" title="CSS3弹性盒"></a>CSS3弹性盒</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弹性盒 display:flex（父元素添加） </span><br><span class="line">弹性盒：控制子元素按主轴方向排列 </span><br><span class="line">弹性盒可以设置单独内容水平垂直居中</span><br><span class="line">父元素：display:flex 子元素：margin:auto </span><br><span class="line">灵活元素：灵活元素即使是内联元素也能设置宽高</span><br><span class="line"></span><br><span class="line">加父元素身上</span><br><span class="line">1.flex-direction 属性指定了弹性子元素在父容器中的位置。 </span><br><span class="line">	row：横向从左到右排列（左对齐），默认的排列方式。</span><br><span class="line">	row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。</span><br><span class="line">	column：纵向排列。</span><br><span class="line">	olumn-reverse：反转纵向排列，从后往前排，最后一项排在最上面。</span><br><span class="line">2.justify-content:flex-start&#x2F;flex-end&#x2F;space-between&#x2F;space-around</span><br><span class="line">3.align-items: 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。  </span><br><span class="line">		center&#x2F;flex-start&#x2F;flex-end&#x2F;baseline&#x2F;stretch</span><br><span class="line">4.flex-wrap:属性用于指定弹性盒子的子元素换行方式。nowrap&#x2F;wrap&#x2F;wrap-reverse</span><br><span class="line">5.align-content:设置各个行的对齐:  </span><br><span class="line">	stretch - 默认。各行将会伸展以占用剩余的空间。</span><br><span class="line">	flex-start - 各行向弹性盒容器的起始位置堆叠。</span><br><span class="line">	flex-end - 各行向弹性盒容器的结束位置堆叠。</span><br><span class="line">	center -各行向弹性盒容器的中间位置堆叠。</span><br><span class="line">	space-between -各行在弹性盒容器中平均分布。</span><br><span class="line">	space-around </span><br><span class="line">	</span><br><span class="line">加子元素身</span><br><span class="line">1、align-self：属性用于设置弹性元素自身在侧轴（纵轴）方向上的对齐方式。</span><br><span class="line">	align-self: auto | flex-start | flex-end | center | baseline | stretch</span><br><span class="line">	flex 属性用于指定弹性子元素如何分配空间。</span><br><span class="line">     	1: 计算值为 1 1 auto</span><br><span class="line">    	initial: 计算值为 0 1 auto</span><br><span class="line">     	none：计算值为 0 0 auto</span><br><span class="line">inherit：从父元素继承</span><br><span class="line">2、第一个参数表示: flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</span><br><span class="line">3、第二个参数表示: flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</span><br><span class="line">4、第三个参数表示: flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小</span><br></pre></td></tr></table></figure>

<h3 id="CSS元素居中"><a href="#CSS元素居中" class="headerlink" title="CSS元素居中"></a>CSS元素居中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.使用margin进行固定长度的偏移	</span><br><span class="line"></span><br><span class="line">2.使用绝对定位并进行偏移(已知宽高)</span><br><span class="line">#father&#123; position:relative; &#125; </span><br><span class="line">#son&#123; position: absolute; left:50%; top:50%; </span><br><span class="line">	  margin-left: -子元素的宽&#x2F;2; margin-top: -子元素的高&#x2F;2; &#125; </span><br><span class="line"></span><br><span class="line">3.使用绝对定位并margin自适应进行居中 </span><br><span class="line">#father&#123; position:relative;&#125; </span><br><span class="line">#son&#123;position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin:auto; &#125;</span><br><span class="line">			  (啊不斯陆特)</span><br><span class="line">4.使用弹性盒子来实现居中 </span><br><span class="line">#father&#123; display: flex; justify-content: center; align-items: center; &#125;</span><br><span class="line">						(加斯特佛)				  (额来) (哎特木)</span><br><span class="line">5.使用定位 + transform</span><br><span class="line">#father&#123; position:relative;&#125; </span><br><span class="line">#son&#123; position: absolute; left: 50%; top: 50%; transform:translate(-50% -50%) &#125;</span><br><span class="line"></span><br><span class="line">6.table-cell布局</span><br><span class="line">因为table-cell相当与表格的td，td为行内元素，无法设置宽和高，所以嵌套一层，嵌套一层必须设置display: inline-block;</span><br></pre></td></tr></table></figure>

<h3 id="CSS几种定位的区别-relative-absolute-fixed"><a href="#CSS几种定位的区别-relative-absolute-fixed" class="headerlink" title="CSS几种定位的区别 relative, absolute, fixed"></a>CSS几种定位的区别 relative, absolute, fixed</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、相对定位position:relative;参考物是自己,不脱离文档流(初始位置仍然占据空 间),top:100px; 给正值是向该容器的中心点移动;</span><br><span class="line"></span><br><span class="line">2、绝对定位position:absolute; 参考物是外层具有position属性的元素, 如果向外 都么有找到最后会参考body&#x2F;html做定位</span><br><span class="line"></span><br><span class="line">3、固定定位position:fixed; 参考物是可视窗口 </span><br><span class="line"></span><br><span class="line">4、粘性定位(了解)position:sticky; 是绝对定位+固定定位</span><br></pre></td></tr></table></figure>

<h3 id="div外边距重叠的原因及解决办法"><a href="#div外边距重叠的原因及解决办法" class="headerlink" title="div外边距重叠的原因及解决办法"></a>div外边距重叠的原因及解决办法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">情况一:</span><br><span class="line">	两个div垂直边界相邻，margin会等于二者中margin较大的值 </span><br><span class="line">解决方案:</span><br><span class="line">1.position：absolute </span><br><span class="line">2.float:left </span><br><span class="line"></span><br><span class="line">情况二:</span><br><span class="line">	子元素在父元素内，子元素的margin-top会与父元素的margin-top重叠，值等于二者中较大的，如果只有子元素设置了margin-top，则显示为父元素的margin-top </span><br><span class="line">解决方案:</span><br><span class="line">1.给父元素设置border（给子元素设置边框没有用） </span><br><span class="line">2.给父元素设置padding值 </span><br><span class="line">3.给父元素或子元素添加float：left </span><br><span class="line">4.给父元素或子元素添加position：absolute </span><br><span class="line">5.给父元素添加overflow：hidden </span><br><span class="line">6.给子元素添加display：inline-block </span><br><span class="line"></span><br><span class="line">情况三:</span><br><span class="line">	一个空白元素自身的margin-top和margin-bottom会重叠，值为而这种较大的 </span><br><span class="line">解决方案:</span><br><span class="line">1.设置透明border </span><br></pre></td></tr></table></figure>

<h3 id="px，em，rem，pt的区别"><a href="#px，em，rem，pt的区别" class="headerlink" title="px，em，rem，pt的区别"></a>px，em，rem，pt的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、px实际上就是像素，用px设置字体大小时，比较稳定和精确 </span><br><span class="line">2、em就是根据基准来缩放字体的大小 </span><br><span class="line">3、rem是相对于根元素字体大小来显示的 </span><br><span class="line">4、pt的大小等于1英寸的1&#x2F;72 浏览器的兼容性除了IE6-IE8，其他的浏览器都支持em和rem，px所有浏览器都支持</span><br></pre></td></tr></table></figure>

<h3 id="CSS的BFC"><a href="#CSS的BFC" class="headerlink" title="CSS的BFC"></a>CSS的BFC</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、什么是BFC BFC（Block formatting context）直译为“块级格式化上下文”。</span><br><span class="line">他是一个独立的渲染区域，也可以理解成一个独立的容器，并且这个容器里box的布局，与这个容器外的毫不相干。 </span><br><span class="line"></span><br><span class="line">2、BFC渲染规则</span><br><span class="line">a.内部的box会在垂直方向，一个接一个的放置 </span><br><span class="line">b.box垂直方向的距离由margin决定。属于同一个BFC的两个相邻box的margin会发生重 叠</span><br><span class="line">c.每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格 式化，否则相反）。</span><br><span class="line">即使存在浮动也是如此 </span><br><span class="line">d.BFC的区域不会与float box重叠 </span><br><span class="line">e.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之 也如此 </span><br><span class="line">f.计算BFC的高度时，浮动元素也参与计算 </span><br><span class="line"></span><br><span class="line">3、如何产生BFC </span><br><span class="line">a.根元素</span><br><span class="line">b.float属性不为none </span><br><span class="line">c.position为absolute或fixed </span><br><span class="line">d.display为inline-block， table-cell，table-caption，flex，inline-flex </span><br><span class="line">e.overflow不为visible </span><br><span class="line"></span><br><span class="line">4、BFC的作用 </span><br><span class="line">a.自适应两栏布局</span><br><span class="line">b.清除内部浮动 </span><br><span class="line">c.防止垂直margin重叠（放在两个BFC里） </span><br></pre></td></tr></table></figure>

<h3 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题"></a>兼容问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）css浏览器兼容问题（比如设置元素透明度，ie浏览器使用滤镜实现，filter </span><br><span class="line">：progid：DXlmage Transform.Microsoft.Alpha(style&#x3D;0,opacity&#x3D;50);非IE浏览器 </span><br><span class="line">opacity：0.5） </span><br><span class="line">解决方法：现在前端开发已经出现了非常多的框架和类库用于浏览器的兼容问题，比如jq类 库，解决获取元素中包含的所有文本内容兼容性问题，$(“element”).text(“element text”) </span><br><span class="line"></span><br><span class="line">2）css3浏览器前缀问题 </span><br><span class="line">	-ms-：ie浏览器 </span><br><span class="line">	-o-：opera欧朋浏览器 </span><br><span class="line">	-webkit-：谷歌浏览器 </span><br><span class="line">	-moz-：火狐浏览器</span><br><span class="line"></span><br><span class="line">工作中遇到的困难 </span><br><span class="line">	1）IE6中高度不对问题 </span><br><span class="line">		在div中给定了高度为1px,其它浏览器显示正常，可是ie6中显示的高度就不对了，这时我 </span><br><span class="line">		给样式表中加 了个font-size:0px;line-height:0px;就好了 </span><br><span class="line">	2)把border设为“0”像素虽然在页面上看不见，但按border默认值理解，</span><br><span class="line">		浏览器依然对 border- width&#x2F;border-color进行了渲染，</span><br><span class="line">		即已经占用了内存值把border设为“none”即没有，浏览器解析“none”时将不作出渲染动作，即不会消耗内存</span><br></pre></td></tr></table></figure>

<h3 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Media Queries 通过查询设备的宽度来执行不同的 css 代码，最终达到界面 的配置 </span><br><span class="line">2.Flex弹性布局 </span><br><span class="line">3.rem + viewport 缩放 实现原理 根据rem将页面放大dpr倍, 然后viewport设置为1&#x2F;dpr. </span><br><span class="line">4、rem实现 移动端适配方案： </span><br><span class="line">	1）viewport（scale&#x3D;1&#x2F;dpr）    dpr:备像素比   </span><br><span class="line">	2）rem 3）flex 4）vm&#x2F;vh</span><br><span class="line">	以iphone8为例，iphone8的CSS像素为375px*677px，DPR是2，</span><br><span class="line">	所以其设备像素为750px*1354px</span><br><span class="line">	750(px) &#x2F; 375(px)  &#x3D; 2</span><br></pre></td></tr></table></figure>

<h3 id="什么是CSS预处理器？优点是什么"><a href="#什么是CSS预处理器？优点是什么" class="headerlink" title="什么是CSS预处理器？优点是什么"></a>什么是CSS预处理器？优点是什么</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css预处理器用一种专门的编程语言，进行web页面样式设计，然后在编译成正常的css文件，</span><br><span class="line">以供项目使用 在css中使用变量、简单的逻辑程序、函数。可以让你的css更加简洁、适应性更强、可读性更佳、更易于代码的维护</span><br></pre></td></tr></table></figure>

<h3 id="0-5px线怎么实现（单边框0-5px）"><a href="#0-5px线怎么实现（单边框0-5px）" class="headerlink" title="0.5px线怎么实现（单边框0.5px）"></a>0.5px线怎么实现（单边框0.5px）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：border + border - img + 线性渐变linear-gradient</span><br><span class="line">方式二：定位 + 伪元素 + background + 线性渐变linear-gradient</span><br><span class="line">方式三：定位 + 伪元素 + transform缩放（scale）</span><br></pre></td></tr></table></figure>

<h3 id="CSS布局-左侧宽度固定，右侧自适应"><a href="#CSS布局-左侧宽度固定，右侧自适应" class="headerlink" title="CSS布局 - 左侧宽度固定，右侧自适应"></a>CSS布局 - 左侧宽度固定，右侧自适应</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一: </span><br><span class="line">	设置绝对定位</span><br><span class="line">	宽度固定区域设置 position：absolute+ left&#x2F;right+ top + width</span><br><span class="line">	自适应区域设置 margin-left&#x2F;margin-right: 固定宽度区域的宽度。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">	（1）若左侧固定的高度大于右侧自适应区域高度</span><br><span class="line">		页面布局就变成这样了：（测试布局区域紧挨着自适应区域的下方，盖住了部分固定区域）</span><br><span class="line">		简单粗暴的就是测试布局区域定位的top值直接设置为两个区域最高的高度值</span><br><span class="line">	（2）若左侧固定的高度大于右侧自适应区域高度，且测试区域不进行定位</span><br><span class="line">方法二:</span><br><span class="line">	浮动布局</span><br><span class="line">	左侧固定区域浮动+宽度，右侧自适应区域 设置margin-left :左侧宽度值。</span><br><span class="line">方法三:</span><br><span class="line">	BFC规则</span><br><span class="line">	左侧固定区域浮动+宽度，右侧自适应区域（非浮动元素）设置overflow：hidden。</span><br></pre></td></tr></table></figure>

<h3 id="CSS布局-左右侧宽度固定，中间自适应"><a href="#CSS布局-左右侧宽度固定，中间自适应" class="headerlink" title="CSS布局 - 左右侧宽度固定，中间自适应"></a>CSS布局 - 左右侧宽度固定，中间自适应</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、绝对定位布局：position + margin</span><br><span class="line">缺点: 如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况。</span><br><span class="line">2、浮动布局： float + margin</span><br><span class="line">3、flex布局</span><br><span class="line">	高度由内容决定。</span><br><span class="line">4、table布局</span><br><span class="line">	高度由内容决定。</span><br><span class="line">5、Grid网格布局</span><br><span class="line">6、圣杯布局</span><br><span class="line">7、双飞翼布局</span><br><span class="line">8、对比圣杯布局和双飞翼布局</span><br><span class="line">（1）都是左右栏定宽，中间栏自适应的三栏布局，中间栏都放到文档流前面，保证先行渲染。</span><br><span class="line">（2）解决方案基本相似：都是三栏全部设置左浮动float：left,然后分别结局中间栏内容被覆盖的问题。</span><br><span class="line">（3）解决中间栏内容被覆盖问题时，圣杯布局设置父元素的padding,双飞翼布局在中间栏嵌套一个div,</span><br><span class="line">	内容放到新的	div中，并设置margin，实际上，双飞翼布局就是圣杯布局的改进方案。</span><br></pre></td></tr></table></figure>

<h3 id="webpack-打包优化-怎么减少打包时间"><a href="#webpack-打包优化-怎么减少打包时间" class="headerlink" title="webpack 打包优化  怎么减少打包时间"></a>webpack 打包优化  怎么减少打包时间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多进程打包 - 速度分析</span><br><span class="line">多进程压缩 - 体积分析</span><br><span class="line">资源CDN</span><br><span class="line">动态polyfill - 根据不同浏览器，动态载入需要的polyfill,大幅度减少构建体积</span><br><span class="line"></span><br><span class="line">split-thunk</span><br><span class="line">前端构建项目中，为了提高打包效率，往往将第三库与业务逻辑代码分开打包，因为第三方库往往不需要经常打包更新。webpack建议使用CommonsChunk 来单独打包第三方库</span><br><span class="line"></span><br><span class="line">webpack loader(转换器)和plugin(插件)有什么区别:</span><br><span class="line">	loader它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程</span><br><span class="line">	plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</span><br><span class="line"></span><br><span class="line">loader:</span><br><span class="line">	优雅降级，</span><br><span class="line">	图片打包</span><br><span class="line">plugin:</span><br><span class="line">	html产出：把public下面的html文件打包到build里面的index.html并自动引入app.js</span><br><span class="line">	css抽离</span><br><span class="line">	静态资源拷贝</span><br></pre></td></tr></table></figure>

<h3 id="继承的6种方式"><a href="#继承的6种方式" class="headerlink" title="继承的6种方式"></a>继承的6种方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.原型链继承</span><br><span class="line">	重点：让新实例的原型等于父类的实例。</span><br><span class="line">	特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。</span><br><span class="line">　　　		（新实例不会继承父类实例的属性！）</span><br><span class="line">	缺点：1、新实例无法向父类构造函数传参。</span><br><span class="line">		 2、继承单一。</span><br><span class="line">		 3、所有新实例都会共享父类实例的属性。</span><br><span class="line">　　　　　　（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</span><br><span class="line">2.借用构造函数继承</span><br><span class="line">	重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））</span><br><span class="line">	特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。</span><br><span class="line">		 2、解决了原型链继承缺点1、2、3。</span><br><span class="line">		 3、可以继承多个构造函数属性（call多个）。</span><br><span class="line">		 4、在子实例中可向父实例传参。</span><br><span class="line">	缺点：1、只能继承父类构造函数的属性。</span><br><span class="line">		 2、无法实现构造函数的复用。（每次用每次都要重新调用）</span><br><span class="line">		 3、每个新实例都有父类构造函数的副本，臃肿。</span><br><span class="line">3.组合继承（组合原型链继承和借用构造函数继承）		 </span><br><span class="line">	重点：结合了两种模式的优点，传参和复用</span><br><span class="line">	特点：1、可以继承父类原型上的属性，可以传参，可复用。</span><br><span class="line">		 2、每个新实例引入的构造函数属性是私有的。</span><br><span class="line">	缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</span><br><span class="line">4.原型式继承</span><br><span class="line">	重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。			 object.create()就是这个原理。</span><br><span class="line">	特点：类似于复制一个对象，用函数来包装。</span><br><span class="line">	缺点：1、所有实例都会继承原型上的属性。</span><br><span class="line">		 2、无法实现复用。（新实例属性都是后面添加的）</span><br><span class="line">5.寄生式继承</span><br><span class="line">	重点：就是给原型式继承外面套了个壳子。</span><br><span class="line">	优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。</span><br><span class="line">	缺点：没用到原型，无法复用。</span><br><span class="line">6.寄生组合式继承（常用）</span><br><span class="line">	重点：修复了组合继承的问题</span><br><span class="line">	寄生：在函数内返回对象然后调用</span><br><span class="line">	组合：1、函数的原型等于另一个实例。</span><br><span class="line">		 2、在函数中用apply或者call引入另一个构造函数，可传参　</span><br></pre></td></tr></table></figure>

<h3 id="阻止冒泡和取消默认事件-默认行为"><a href="#阻止冒泡和取消默认事件-默认行为" class="headerlink" title="阻止冒泡和取消默认事件(默认行为)"></a>阻止冒泡和取消默认事件(默认行为)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">防止事件捕获和冒泡:</span><br><span class="line">w3c的方法是e.stopPropagation()</span><br><span class="line">IE则是使用e.cancelBubble &#x3D; true</span><br><span class="line"></span><br><span class="line">取消默认事件</span><br><span class="line">w3c的方法是e.preventDefault()</span><br><span class="line">IE则是使用e.returnValue &#x3D; false</span><br><span class="line"></span><br><span class="line">jQuery用法</span><br><span class="line">阻止默认事件 return false (不停止冒泡)</span><br></pre></td></tr></table></figure>

<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变量的作用域无非就是两种：</span><br><span class="line">全局变量和局部变量。javascript的作用域是相对函数而言的，可以称为函数作用域</span><br><span class="line"></span><br><span class="line">全局作用域： </span><br><span class="line">最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的</span><br><span class="line"></span><br><span class="line">局部作用域： </span><br><span class="line">局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的</span><br><span class="line"></span><br><span class="line">作用域链：</span><br><span class="line">根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。</span><br><span class="line">	作用域链的前端，始终都是当前执行的代码所在环境的变量对象</span><br><span class="line">	作用域链中的下一个对象来自于外部环境，而在下一个变量对象则来自下一个外部环境，一直到全局执行环境</span><br><span class="line">	全局执行环境的变量对象始终都是作用域链上的最后一个对象</span><br></pre></td></tr></table></figure>

<h3 id="遍历数组的方式"><a href="#遍历数组的方式" class="headerlink" title="遍历数组的方式"></a>遍历数组的方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.for循环</span><br><span class="line">使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。</span><br><span class="line"></span><br><span class="line">2.foreach循环</span><br><span class="line">遍历数组中的每一项，没有返回值，对原数组没有影响，不支持IE。</span><br><span class="line">有一些局限，不能continue跳过或者break终止循环</span><br><span class="line"></span><br><span class="line">3.map循环</span><br><span class="line">有返回值，可以return出来</span><br><span class="line">map的回调函数中支持return返回值</span><br><span class="line">并不影响原来的数组，return的是新数组</span><br><span class="line"></span><br><span class="line">4.for of遍历</span><br><span class="line">可以正确响应break、continue和return语句</span><br><span class="line"></span><br><span class="line">5.filter遍历</span><br><span class="line">不会改变原始数组,返回新数组</span><br><span class="line"></span><br><span class="line">6.every遍历</span><br><span class="line">every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。</span><br><span class="line"></span><br><span class="line">7.some遍历</span><br><span class="line">some()是对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true。</span><br><span class="line"></span><br><span class="line">8.reduce</span><br><span class="line">reduce()方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。</span><br><span class="line"></span><br><span class="line">9.reduceRight</span><br><span class="line">reduceRight()方法的功能和reduce()功能是一样的，</span><br><span class="line">不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。</span><br><span class="line"></span><br><span class="line">10.find</span><br><span class="line">find()方法返回数组中符合测试函数条件的第一个元素。否则返回undefined </span><br><span class="line"></span><br><span class="line">11.findIndex</span><br><span class="line">对于数组中的每个元素，findIndex方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 true。</span><br><span class="line">只要有一个元素返回 true，findIndex立即返回该返回 true 的元素的索引值。</span><br><span class="line">如果数组中没有任何元素返回 true，则 findIndex 返回 -1。</span><br><span class="line">findIndex 不会改变数组对象。</span><br><span class="line"></span><br><span class="line">12.keys，values，entries</span><br><span class="line">ES6 提供三个新的方法 —— entries()，keys()和values() —— 用于遍历数组。</span><br><span class="line">它们都返回一个遍历器对象，可以用for...of循环进行遍历，</span><br><span class="line">唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</span><br></pre></td></tr></table></figure>

<h3 id="数据分页"><a href="#数据分页" class="headerlink" title="数据分页"></a>数据分页</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前端的话，定义一个新的数组for循环判断，有个公式，计算起始页和终止页的。</span><br><span class="line">符合条件push仅数组中，后端就是用limt判断</span><br></pre></td></tr></table></figure>

<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 普通数组排序　　</span><br><span class="line">　　js中用方法sort()为数组排序。sort()方法有一个可选参数，是用来确定元素顺序的函数。如果这个参数被省略，那么数组中的元素将按照ASCII字符顺序进行排序。</span><br><span class="line">2. 冒泡排序</span><br><span class="line">（1）比较相邻的元素。如果第一个比第二个大，就交换他们两个位置。</span><br><span class="line">（2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</span><br><span class="line">（3）针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line">（4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span><br><span class="line">3. 快速排序：递归思想，两边快速的排序，冒泡排序的改进</span><br><span class="line">（1）选择数组中间数作为基数，并从数组中取出此基数；</span><br><span class="line">（2）准备两个数组容器，遍历数组，逐个与基数比对，较小的放左边容器，较大的放右边容器；</span><br><span class="line">（3）进行相同的操作，直到数组中只有一个元素时，返回该数组。</span><br><span class="line">4. 插入排序</span><br><span class="line">（1）从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line">（2）取出下一个元素，在已经排序的元素序列中扫描</span><br><span class="line">（3）如果该元素（已排序）大于新元素，将该元素移到下一位置</span><br><span class="line">（4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span><br><span class="line">（5）将新元素插入到下一位置中</span><br><span class="line">（6）重复步骤2</span><br><span class="line">5. 选择排序</span><br><span class="line">（1）在未排序序列中找到最小（大）元素</span><br><span class="line">（2）并存放到排序序列的起始位置</span><br><span class="line">（3）然后，再从剩余未排序元素中继续寻找最小（大）元素</span><br><span class="line">（4）然后放到已排序序列的末尾。</span><br><span class="line">（5）以此类推</span><br></pre></td></tr></table></figure>

<h3 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、concat</span><br><span class="line">	js的Array对象提供了一个叫concat()方法，连接两个或更多的数组，并返回结果。</span><br><span class="line">		var c &#x3D; a.concat(b); &#x2F;&#x2F;c&#x3D;[1,2,3,4,5,6];</span><br><span class="line"></span><br><span class="line">	这里有一个问题，concat方法连接a、b两个数组后，a、b两个数组的数据不变，同时会返回一个新的数组。这样当我们需要进行多次的数组合并时，会造成很大的内存浪费，如果是数据量比较小的时候，还可以勉强用，如果数据量大的时候，这个就不妥了，所以这个方法肯定不是最好的。</span><br><span class="line"></span><br><span class="line">2、for循环</span><br><span class="line">大概的思路是：遍历其中一个数组，把该数组中的所有元素依次添加到另外一个数组中。直接上代码：</span><br><span class="line">	for(var i in b) &#123; a.push ( b[i] );&#125;</span><br><span class="line">	</span><br><span class="line">3、apply</span><br><span class="line">	函数的apply方法有一个特性，那就是func.apply(obj,argv)，argv是一个数组。</span><br><span class="line">		a.push.apply(a,b);</span><br><span class="line">	调用a.push这个函数实例的apply方法，同时把，b当作参数传入，</span><br><span class="line">	这样a.push这个方法就会遍历b数组的所有元素，达到合并的效果。</span><br><span class="line">	这里可能有点绕，我们可以把b看成[4,5,6]，变成这样：</span><br><span class="line">		a.push.apply(a,[4,5,6]);</span><br><span class="line">	然后上面的操作就等同于：</span><br><span class="line">		a.push(4,5,6);</span><br><span class="line">	这样就很清楚了！</span><br></pre></td></tr></table></figure>

<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push，在数组末尾添加一位或多位元素</span><br><span class="line">pop，删除数组最后一位元素</span><br><span class="line">unshift，在数组的开头添加一位或多位元素</span><br><span class="line">shift，删除数组的第一位元素</span><br><span class="line">join，将数组转换为字符串</span><br><span class="line">reserve，反转数组元素的顺序</span><br><span class="line">sort，对数组进行排序</span><br><span class="line">concat，连接两个或多个数组</span><br><span class="line">splice，添加或删除数组中的元素</span><br><span class="line">slice，从已有的数组中返回选定的元素</span><br><span class="line">indexOf、lastIndexOf，查找数组中的元素</span><br><span class="line">forEach，对数组进行遍历循环，对数组中每一项运行指定的函数</span><br><span class="line">map，迭代数组</span><br><span class="line">filter，对数组中的元素进行指定的检查返回符合条件的元素放入一个新数组中</span><br><span class="line">every，测试所有元素是否都符合指定条件</span><br><span class="line">some，测试某些元素是否符合指定条件</span><br><span class="line">reduce，接收一个函数作为累加器，数组中的每个值开始缩减，最终计算为一个值</span><br><span class="line">toString，将数组转换为字符串</span><br></pre></td></tr></table></figure>

<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用ES6 Set</span><br><span class="line">	var arr &#x3D; [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	arr &#x3D; Array.from(new Set(arr));  [...new Set(arr)]</span><br><span class="line">	console.log(arr);&#x2F;&#x2F;[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用indexOf</span><br><span class="line">	var arr &#x3D; [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	var newArr &#x3D; [];</span><br><span class="line">	arr.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">  		newArr.indexOf(item) &#x3D;&#x3D;&#x3D; -1 ? newArr.push(item) : &quot;&quot;;</span><br><span class="line">	&#125;);</span><br><span class="line">	console.log(newArr);&#x2F;&#x2F;[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用lastIndexOf</span><br><span class="line">	var arr &#x3D; [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	var newArr &#x3D; [];</span><br><span class="line">	arr.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">  		newArr.lastIndexOf(item) &#x3D;&#x3D;&#x3D; -1 ? newArr.push(item) : &quot;&quot;;</span><br><span class="line">	&#125;);</span><br><span class="line">    console.log(newArr);&#x2F;&#x2F;[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用双重for循环加splice方法</span><br><span class="line">	var arr &#x3D; [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"> 		for (var j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">    		if (arr[i] &#x3D;&#x3D; arr[j]) &#123;</span><br><span class="line">      			arr.splice(j,1);</span><br><span class="line">      			j--;</span><br><span class="line">    		&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(arr);&#x2F;&#x2F;[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用forEach和includes方法</span><br><span class="line">	var arr &#x3D; [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	var newArr &#x3D; [];</span><br><span class="line">	arr.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">  		newArr.includes(item) ? &quot;&quot; : newArr.push(item);</span><br><span class="line">	&#125;);</span><br><span class="line">	console.log(newArr);&#x2F;&#x2F;[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用fliter和includes方法</span><br><span class="line">	var arr &#x3D; [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	var newArr &#x3D; [];</span><br><span class="line">	arr.filter((item) &#x3D;&gt; &#123;</span><br><span class="line">  		newArr.includes(item) ? &quot;&quot; : newArr.push(item);</span><br><span class="line">	&#125;);</span><br><span class="line">	console.log(newArr);&#x2F;&#x2F;[1, 4, 2, 3, 6]</span><br></pre></td></tr></table></figure>

<h3 id="for…of-原理"><a href="#for…of-原理" class="headerlink" title="for…of 原理"></a>for…of 原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for...of 是ES6引入用来遍历所有数据结构的统一方法。</span><br><span class="line"></span><br><span class="line">这里的所有数据结构只指具有iterator接口的数据。</span><br><span class="line">一个数据只要部署了 Symbol.iterator，就具有了 iterator接口，就可以使用 for...of 循环遍历它的成员。</span><br><span class="line">也就是说，for...of循环内部调用的数据结构为Symbol.iterator方法。</span><br><span class="line">部署在 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就认为是&quot;可遍历的&quot;。</span><br><span class="line"></span><br><span class="line">Iterator(伊特瑞特):</span><br><span class="line">	遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。</span><br><span class="line">	任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</span><br><span class="line">	通俗点理解就是为了解决不同数据结构遍历的问题，引入了Iterator.</span><br><span class="line"></span><br><span class="line">Iterator的特点:</span><br><span class="line">	各种数据结构，提供一个统一的、简便的访问接口</span><br><span class="line">	使得数据结构的成员能够按某种次序排列</span><br><span class="line">	ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费</span><br><span class="line">	</span><br><span class="line">原生具备 Iterator 接口的数据结构如下。</span><br><span class="line">	Array</span><br><span class="line">	Map</span><br><span class="line">	Set</span><br><span class="line">	String：字符串是一个类似数组的对象，也原生具有 Iterator 接口。</span><br><span class="line">	TypedArray：</span><br><span class="line">		通俗理解：ArrayBuffer是一片内存空间，不能直接引用里面的数据，可以通过TypedArray类型引用，</span><br><span class="line">				用户只能通过TypedArray使用这片内存，不能直接通过ArrayBuffer使用这片内存</span><br><span class="line">	函数的 arguments 对象</span><br><span class="line">	NodeList 对象</span><br><span class="line">	</span><br><span class="line">除了原生具备Iterator 接口的数据之外，其他数据结构（主要是对象）的 Iterator 接口，</span><br><span class="line">都需要自己在Symbol.iterator属性上面部署，这样才会被for...of循环遍历。</span><br><span class="line"></span><br><span class="line">对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</span><br><span class="line"></span><br><span class="line">一个对象如果要具备可被for...of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</span><br></pre></td></tr></table></figure>

<h3 id="遍历对象的方式"><a href="#遍历对象的方式" class="headerlink" title="遍历对象的方式"></a>遍历对象的方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种： </span><br><span class="line">for...in</span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">1）Object.keys（obj）</span><br><span class="line">2）Object.values（obj）</span><br><span class="line">参数：</span><br><span class="line">	obj：要返回其枚举自身属性的对象</span><br><span class="line">返回值：</span><br><span class="line">	一个表示给定对象的所有可枚举属性的字符串数组。</span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line">使用Object.getOwnPropertyNames(obj)</span><br><span class="line">返回一个数组，包含对象自身的所有属性（包含不可枚举属性）</span><br><span class="line">遍历可以获取key和value</span><br></pre></td></tr></table></figure>

<h3 id="map与filter和forEach的区别"><a href="#map与filter和forEach的区别" class="headerlink" title="map与filter和forEach的区别"></a>map与filter和forEach的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map 与 filter 区别:</span><br><span class="line">	相同点：filter 和 map 都是对数组的操作，均返回一个新的数组</span><br><span class="line">	不同点：filter是满足条件的留下，是对原数组的过滤；map则是对原数组的加工，映射成一对一映射的新数组</span><br><span class="line"></span><br><span class="line">map 与 forEach 区别:</span><br><span class="line">	map()会分配内存空间存储新数组并返回，forEach()不会返回数据(undefined)。</span><br><span class="line">	forEach()允许callback更改原始数组的元素。map()返回新的数组。</span><br></pre></td></tr></table></figure>

<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">面向对象编程:</span><br><span class="line">将所需要做的功能抽象成一个“对象”，然后一遍遍地调用这个对象来完成你想要的功能。</span><br><span class="line"></span><br><span class="line">面向对象的三大特征:</span><br><span class="line">1.封装</span><br><span class="line">我们平时所用的方法和类都是一种封装，当我们在项目开发中，遇到一段功能的代码在好多地方重复使用的时候，我们可以把他单独封装成一个功能的方法，这样在我们需要使用的地方直接调用就可以了。</span><br><span class="line"></span><br><span class="line">2.继承</span><br><span class="line">继承在我们的项目开发中主要使用为子类继承父类，继承会继承父类的实例属性和实例方法，并不会继承静态属性和静态方法，并且静态方法只能通过类名去调用。</span><br><span class="line"></span><br><span class="line">3.多态</span><br><span class="line">多态的具体表现为方法重载和方法重写：</span><br><span class="line">方法重载：</span><br><span class="line">重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数</span><br><span class="line">方法重写：</span><br><span class="line">重写（也叫覆盖）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样</span><br><span class="line"></span><br><span class="line">三大特征的优点：</span><br><span class="line">封装：</span><br><span class="line">封装的优势在于定义只可以在类内部进行对属性的操作，外部无法对这些属性指手画脚，要想修改，也只能通过你定义的封装方法；</span><br><span class="line"></span><br><span class="line">继承：</span><br><span class="line">继承减少了代码的冗余，省略了很多重复代码，开发者可以从父类底层定义所有子类必须有的属性和方法，以达到耦合的目的；</span><br><span class="line"></span><br><span class="line">多态：</span><br><span class="line">多态实现了方法的个性化，不同的子类根据具体状况可以实现不同的方法，光有父类定义的方法不够灵活，遇见特殊状况就捉襟见肘了</span><br></pre></td></tr></table></figure>

<h3 id="window-onload与document-ready的区别"><a href="#window-onload与document-ready的区别" class="headerlink" title="window.onload与document.ready的区别"></a>window.onload与document.ready的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.执行时间</span><br><span class="line">	window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 </span><br><span class="line">	$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。</span><br><span class="line"></span><br><span class="line">2.编写个数不同</span><br><span class="line">	window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个 </span><br><span class="line">	$(document).ready()可以同时编写多个，并且都可以得到执行</span><br><span class="line"></span><br><span class="line">3.简化写法</span><br><span class="line">	window.onload没有简化写法 </span><br><span class="line">	$(document).ready(function()&#123;&#125;)可以简写成$(function()&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this代表函数运行时，自动生成的一个内部对象，只能在函数内部使用，</span><br><span class="line">随着函数使用场合的不同，this的值会发生变化。</span><br><span class="line"></span><br><span class="line">指向:</span><br><span class="line">1.在方法中，this 表示该方法所属的对象。</span><br><span class="line">2.如果单独使用，this 表示全局对象。</span><br><span class="line">3.函数中，this 表示全局对象。</span><br><span class="line">4.严格模式下，this 是未定义的(undefined)。</span><br><span class="line">5.在事件中，this 表示接收事件的元素。</span><br><span class="line">6.类似 call() 和 apply() 方法可以将 this 引用到任何对象。</span><br><span class="line">7.箭头函数本身是没有this和arguments的，引用的this实际上是调用的是定义时的上一层作用域的this。</span><br></pre></td></tr></table></figure>

<h3 id="lt-DOCTYPE-gt"><a href="#lt-DOCTYPE-gt" class="headerlink" title="&lt;!DOCTYPE&gt;"></a>&lt;!DOCTYPE&gt;</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 &lt;html&gt; 标签之前。</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE&gt; 声明不是一个 HTML 标签；它是用来告知 Web 浏览器页面使用了哪种 HTML 版本。</span><br><span class="line"></span><br><span class="line">在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明需引用 DTD （文档类型声明），</span><br><span class="line">因为 HTML 4.01 是基于 SGML （Standard Generalized Markup Language 标准通用标记语言）。</span><br><span class="line">DTD 指定了标记语言的规则，确保了浏览器能够正确的渲染内容。</span><br><span class="line"></span><br><span class="line">HTML5 不是基于 SGML，因此不要求引用 DTD。</span><br><span class="line"></span><br><span class="line">给您 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，确保浏览器能够预先知道文档类型。</span><br></pre></td></tr></table></figure>

<h3 id="CSS-position属性"><a href="#CSS-position属性" class="headerlink" title="CSS position属性"></a>CSS position属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">absolute:生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</span><br><span class="line">fixed	:生成固定定位的元素，相对于浏览器窗口进行定位。</span><br><span class="line">relative:生成相对定位的元素，相对于其正常位置进行定位。</span><br><span class="line">static	:默认值。没有定位。</span><br><span class="line">sticky	:粘性定位，该定位基于用户滚动的位置。</span><br><span class="line">inherit	:规定应该从父元素继承 position 属性的值。</span><br></pre></td></tr></table></figure>

<h3 id="js的解构"><a href="#js的解构" class="headerlink" title="js的解构"></a>js的解构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解构定义：允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</span><br><span class="line">解构必须满足的条件：（模式匹配），只要等号两边的模式相同，左边的变量就会被赋予对应的值。</span><br><span class="line">主要介绍2种解构常用的类型：数组解构和对象解构。</span><br><span class="line"></span><br><span class="line">数组解构：</span><br><span class="line">	1.数组中的变量个数比赋值的数组中个数少的解构：</span><br><span class="line">	2.数组中的变量个数比赋值的数组中个数多的解构：</span><br><span class="line">	3.数组中的变量中有空字符的解构：上面的3种数组解构，赋值的数组的数值按位赋值给另外一方数组中的变量</span><br><span class="line">	4.数组中的变量中有不定参数(有些时候也叫扩展运算符)的解构：需要注意的是不定参数必须放最后。</span><br><span class="line">	5.数组中的变量中有默认值的解构：如果赋值的数组个数没有另外一方数组变量个数多，并且变量数组有默认，</span><br><span class="line">								没有进行赋值用默认，进行赋值用赋值的</span><br><span class="line"></span><br><span class="line">对象的解构：两方也需要相同类型的括号，对象结构使用大括号&#123;&#125;</span><br><span class="line">普通对象解构：</span><br><span class="line">	对象跟数值解构不同的一点，对象解构不是按位去赋值，是根据键名(属性名) 来进行赋值</span><br><span class="line">有默认值的对象解构</span><br><span class="line">	跟数组的默认值差不多，有赋值就用赋值的，没有就用默认值</span><br><span class="line">有不定参数的对象解构</span><br><span class="line">	跟数组的不定参数差不多，不定参数放在最后，不定参数创建一个对象接受的剩下的键名键值(属性名属性值)</span><br><span class="line">有嵌套的对象解构</span><br><span class="line">	主要注意嵌套层次是不是赋值一方对象的嵌套层次相同。</span><br></pre></td></tr></table></figure>

<h3 id="js实现轮播图思路"><a href="#js实现轮播图思路" class="headerlink" title="js实现轮播图思路"></a>js实现轮播图思路</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.图片移动实现原理：</span><br><span class="line">利用浮动将所有所有照片依次排成一行，给这一长串图片添加一个父级的遮罩，每次只显示一张图，其余的都隐藏起来。对图片添加绝对定位，通过控制left属性，实现照片的移动。</span><br><span class="line"></span><br><span class="line">2.图片移动动画原理：</span><br><span class="line">从a位置移动到b位置，需要先计算两点之间的差值，通过差值和时间间隔，计算出每次移动的步长，通过添加定时器，每次移动相同的步长，实现动画效果。</span><br><span class="line"></span><br><span class="line">3.图片定位停止原理：</span><br><span class="line">每一张照片都有相同的宽度，每张照片都有一个绝对的定位数值，通过检测定每次移动后，照片当前位置和需要到达位置之间的距离是否小于步长，如果小于，说明已经移动到位，可以将定时器清除，来停止动画。</span><br><span class="line"></span><br><span class="line">4图片切换原理：</span><br><span class="line">在全局设置一个变量，记录当前图片的位置，每次切换或跳转时，只需要将数值修改，并调用图片页数转像素位置函数，再调用像素运动函数即可。</span><br><span class="line"></span><br><span class="line">5.自动轮播原理：</span><br><span class="line">设置定时器，一定时间间隔后，将照片标记加1，然后开始切换。</span><br><span class="line"></span><br><span class="line">6.左右点击切换原理：</span><br><span class="line">修改当前位置标记，开始切换。这里需要注意与自动轮播之间的冲突。当点击事件触发之后，停止自动轮播计时器，开始切换。当动画结束后再次添加自动轮播计时器。</span><br><span class="line"></span><br><span class="line">7.无缝衔接原理：</span><br><span class="line">需要无缝衔接，难度在于最后一页向后翻到第一页，和第一页向前翻到最后一页。由于图片的基本移动原理。要想实现无缝衔接，两张图片就必须紧贴在一起。所以在第一张的前面需要添加最后一张，最后一张的后面需要添加第一张。</span><br><span class="line"></span><br><span class="line">首先判断图片的位置，是否移动到位。当满足当前位置，与预定位置之间的距离小于一步时，认定为移动到位，并把图片直接定位到预定位置。然后判断，图片的位置是否需要跳转。</span><br><span class="line">ps：这里一定要在图片运动函数结束后，在进行跳转。</span><br><span class="line"></span><br><span class="line">8.预防鬼畜原理：</span><br><span class="line">始终保证轮播图的运动动画只有一个，从底层杜绝鬼畜。需要在每次动画开始之前，尝试停止动画定时器，然后开始为新的动画添加定时器。</span><br><span class="line"></span><br><span class="line">轮播图鬼畜的本质原因就是，同一时间多个定时器添加在图片上，这些定时器直接相互冲突，造成图片的抖动。</span><br><span class="line">解决方法：每次执行运动函数之前，先尝试清除一下，上一个轮播图的定时器。确保同时触发运动函数时，只有一个定时器在工作。</span><br><span class="line"></span><br><span class="line">9.预防暴力点击原理：</span><br><span class="line">如果用户快速点击触发事件，会在短时间内多次调用切换函数，虽然动画函数可以保证，不会发生鬼畜，但在照片从最后一张到第一张的切换过程，不会按照正常的轮播，而是实现了跳转。所以需要通过添加口令的方式来，限制用户的点击。当用户点击完成后，口令销毁，动画结束后恢复口令。</span><br><span class="line"></span><br><span class="line">10.小圆点的位置显示原理：</span><br><span class="line">每次触发动画时，通过全局变量标记，获取当前页数，操作清除所有小圆点，然后指定一页添加样式。</span><br><span class="line"></span><br><span class="line">11.点击触发跳转的原理：</span><br><span class="line">类似于左右点击触发，只是这是将全局页面标记，直接修改，后执行动画。需要避免与自动轮播定时器的冲突。</span><br></pre></td></tr></table></figure>

<h3 id="js数组和对象的扩展"><a href="#js数组和对象的扩展" class="headerlink" title="js数组和对象的扩展"></a>js数组和对象的扩展</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Array.from()方法用于将对象转为真正的数组(类数组转数组)</span><br><span class="line">2.Array.of()方法用于将一组值，转换为数组。</span><br><span class="line">  console.log(Array.of(1,2,3,4,4,50));&#x2F;&#x2F;[1, 2, 3, 4, 4, 50]</span><br><span class="line">3.Object.assign(目标对象,对象1,对象2)用于对象的合并,将源对象的所有可枚举属性，复制到目标对象。(浅拷贝)</span><br></pre></td></tr></table></figure>

<h3 id="js提升"><a href="#js提升" class="headerlink" title="js提升"></a>js提升</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、提升（Hosting）</span><br><span class="line">简单说就是在js代码执行前引擎会先进行预编译，预编译期间会将变量声明与函数声明提升至其对应作用域的最顶端。</span><br><span class="line"></span><br><span class="line">二、变量提升</span><br><span class="line">在ES6之前，JavaScript没有块级作用域(一对花括号&#123;&#125;即为一个块级作用域)，只有全局作用域和函数作用域。</span><br><span class="line">变量提升即将变量声明提升到它所在作用域的最开始的部分。</span><br><span class="line">变量声明的提升是以变量所处的第一层词法作用域为“单位”的，即全局作用域中声明的变量会提升至全局最顶层，函数内声明的</span><br><span class="line"></span><br><span class="line">三、函数提升</span><br><span class="line">即函数提升只会提升函数声明，而不会提升函数表达式。</span><br><span class="line"></span><br><span class="line">四、为什么会有提升？</span><br><span class="line">函数提升就是为了解决相互递归的问题，大体上可以解决像ML语言这样自下而上的顺序问题。</span><br><span class="line">大概是说，变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。</span><br></pre></td></tr></table></figure>

<h3 id="比较redux和vuex的区别"><a href="#比较redux和vuex的区别" class="headerlink" title="比较redux和vuex的区别"></a>比较redux和vuex的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redux和vuex的区别</span><br><span class="line">	1）vuex是redux的基础上进行改变，对仓库的管理更加明确</span><br><span class="line">	2）使用mutation来替换redux中的reducer</span><br><span class="line">	3)vuex有自动渲染的功能，所以不需要更新</span><br><span class="line">	</span><br><span class="line">redux和flux的区别</span><br><span class="line">　　1）redux是flux中的一个实现</span><br><span class="line">　　2））在redux中我们只能定义一个store，在flux中我们可以定义多个</span><br><span class="line">　　3）在redux中，store和dispatch都放到了store，结构更加清晰</span><br><span class="line">　　4）在redux中本身就内置State对象，对仓库的管理更加明确</span><br></pre></td></tr></table></figure>

<h3 id="CSS-display-属性"><a href="#CSS-display-属性" class="headerlink" title="CSS display 属性"></a>CSS display 属性</h3><table>
<thead>
<tr>
<th>none</th>
<th>此元素不会被显示。</th>
</tr>
</thead>
<tbody><tr>
<td>block</td>
<td>此元素将显示为块级元素，此元素前后会带有换行符。</td>
</tr>
<tr>
<td>inline</td>
<td>默认。此元素会被显示为内联元素，元素前后没有换行符。</td>
</tr>
<tr>
<td>inline-block</td>
<td>行内块元素。（CSS2.1 新增的值）</td>
</tr>
<tr>
<td>list-item</td>
<td>此元素会作为列表显示。</td>
</tr>
<tr>
<td>run-in</td>
<td>此元素会根据上下文作为块级元素或内联元素显示。</td>
</tr>
<tr>
<td>compact</td>
<td>CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td>
</tr>
<tr>
<td>marker</td>
<td>CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示（类似 table），表格前后带有换行符。</td>
</tr>
<tr>
<td>inline-table</td>
<td>此元素会作为内联表格来显示（类似 table），表格前后没有换行符。</td>
</tr>
<tr>
<td>table-row-group</td>
<td>此元素会作为一个或多个行的分组来显示（类似 tbody）。</td>
</tr>
<tr>
<td>table-header-group</td>
<td>此元素会作为一个或多个行的分组来显示（类似 thead）。</td>
</tr>
<tr>
<td>table-footer-group</td>
<td>此元素会作为一个或多个行的分组来显示（类似 tfoot）。</td>
</tr>
<tr>
<td>table-row</td>
<td>此元素会作为一个表格行显示（类似 tr）。</td>
</tr>
<tr>
<td>table-column-group</td>
<td>此元素会作为一个或多个列的分组来显示（类似 colgroup）。</td>
</tr>
<tr>
<td>table-column</td>
<td>此元素会作为一个单元格列显示（类似 col）</td>
</tr>
<tr>
<td>table-cell</td>
<td>此元素会作为一个表格单元格显示（类似 td 和 th）</td>
</tr>
<tr>
<td>table-caption</td>
<td>此元素会作为一个表格标题显示（类似 caption）</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 display 属性的值。</td>
</tr>
</tbody></table>
<h3 id="CSS选择符"><a href="#CSS选择符" class="headerlink" title="CSS选择符"></a>CSS选择符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CSS选择符</span><br><span class="line">	id选择器（#myid）</span><br><span class="line">	类选择器（.myclassname）</span><br><span class="line">	标签选择器（div）</span><br><span class="line">	相邻选择器（h1+p）</span><br><span class="line">	子选择器（ul&gt;li）</span><br><span class="line">	后代选择器（li a）</span><br><span class="line">	群组选择器（div，p&#123;&#125;）</span><br><span class="line">	通配符选择器（*）</span><br><span class="line">	属性选择器（a[title&#x3D;&quot;&quot;]）</span><br><span class="line">	伪类选择器（a:hover&#123;&#125;或者li:nth-child&#123;&#125;）</span><br></pre></td></tr></table></figure>

<h3 id="CSS中link和-import的区别"><a href="#CSS中link和-import的区别" class="headerlink" title="CSS中link和@import的区别"></a>CSS中link和@import的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link属于HTML标签，@import是CSS提供的</span><br><span class="line"></span><br><span class="line">页面被加载时，link引用的css文件会同时被加载，而@import引用的css文件要等到页面被加载完毕再加载</span><br><span class="line"></span><br><span class="line">import只在IE5以上才能识别，link是HTML标签，无兼容问题</span><br><span class="line"></span><br><span class="line">link 引入样式的权重大于@import 的引用</span><br></pre></td></tr></table></figure>

<h3 id="CSS中display-none、visibility-hidden和opacity-0-的区别"><a href="#CSS中display-none、visibility-hidden和opacity-0-的区别" class="headerlink" title="CSS中display:none、visibility:hidden和opacity:0;的区别"></a>CSS中display:none、visibility:hidden和opacity:0;的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display:none;隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢。</span><br><span class="line"></span><br><span class="line">visibility:hidden;隐藏对应的元素，但在文档布局中仍保留原来的空间。</span><br><span class="line"></span><br><span class="line">opacity:0;内容不可见，占据空间。</span><br></pre></td></tr></table></figure>

<h3 id="CSS中rgba-和opacity的透明效果区别"><a href="#CSS中rgba-和opacity的透明效果区别" class="headerlink" title="CSS中rgba()和opacity的透明效果区别"></a>CSS中rgba()和opacity的透明效果区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度；</span><br><span class="line"></span><br><span class="line">rgba()只作用于元素的颜色或其背景色（设置 rgba 透明的元素的子元素不会继承透明效果）。</span><br></pre></td></tr></table></figure>

<h3 id="CSS的外边距重叠"><a href="#CSS的外边距重叠" class="headerlink" title="CSS的外边距重叠"></a>CSS的外边距重叠</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</span><br><span class="line"></span><br><span class="line">折叠结果遵循下列计算规则如下</span><br><span class="line"></span><br><span class="line">两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</span><br><span class="line"></span><br><span class="line">两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</span><br><span class="line"></span><br><span class="line">两个外边距一正一负时，折叠结果是两者之和。</span><br></pre></td></tr></table></figure>

<h3 id="CSS清除浮动"><a href="#CSS清除浮动" class="headerlink" title="CSS清除浮动"></a>CSS清除浮动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">清除浮动主要是为了解决父元素因为子元素浮动引起的内部高度为0的问题。</span><br><span class="line">常见清除浮动的方法</span><br><span class="line">	额外标签法。在最后浮动元素后加一个标签，设置clear:both；</span><br><span class="line">	给父级元素设置高度</span><br><span class="line">	给父级元素添加浮动</span><br><span class="line">	给父级元素设置overflow属性为hidden或者auto</span><br><span class="line">	使用after伪元素清除</span><br><span class="line">		.clearfix:after &#123;</span><br><span class="line">    		&#x2F;*伪元素是行内元素 正常浏览器清除浮动方法*&#x2F;</span><br><span class="line">    		content: &quot;&quot;;</span><br><span class="line">    		display: block;</span><br><span class="line">    		height: 0;</span><br><span class="line">    		clear: both;</span><br><span class="line">   		 	visibility: hidden;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*&#x2F;</span><br><span class="line">		.clearfix &#123;</span><br><span class="line">  			*zoom: 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	使用after和before双伪元素清除</span><br><span class="line">		.clearfix:before,.clearfix:after &#123;</span><br><span class="line">    		content: &quot;&quot;;</span><br><span class="line">    		display: block;</span><br><span class="line">    		clear: both;</span><br><span class="line">		&#125;</span><br><span class="line">		.clearfix &#123;</span><br><span class="line">    		zoom: 1;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS3transition过渡和animation动画的区别"><a href="#CSS3transition过渡和animation动画的区别" class="headerlink" title="CSS3transition过渡和animation动画的区别"></a>CSS3transition过渡和animation动画的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animation属性类似于transition，他们都是随着时间改变元素的属性值，</span><br><span class="line"> </span><br><span class="line">其主要区别在于：</span><br><span class="line">transition需要触发一个事件才会随着时间改变其CSS属性；</span><br><span class="line">animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果</span><br><span class="line"> </span><br><span class="line">1）动画不需要事件触发，过渡需要。</span><br><span class="line">2）过渡只有一组（两个：开始-结束） 关键帧，动画可以设置多个。</span><br></pre></td></tr></table></figure>

<h3 id="前后端开发中数据是怎么交互的"><a href="#前后端开发中数据是怎么交互的" class="headerlink" title="前后端开发中数据是怎么交互的"></a>前后端开发中数据是怎么交互的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">web后端和前端是怎么连接的？</span><br><span class="line"></span><br><span class="line">网站数据处理主要分为三层。</span><br><span class="line">第一层，表示层，这部分可以用HTML代码，CSS&#x2F;Javascript代码来实现等。</span><br><span class="line">	通过前端代码可以实现网页的布局和设计。这层又可以称为显示层。也就是你用浏览器打开能看到的网页。</span><br><span class="line">第二层，是业务层，这层是负责处理数据的。常用的代码语言有PHP,JSP，Java等。</span><br><span class="line">	通过这些后台处理语言的算法来处理前台传回的数据。必要的时候进行操作数据库，然后把结果返回给前端网页。</span><br><span class="line">第三层，是数据层，这个就是数据库，用来存储数据的。</span><br><span class="line">	通过业务层的操作可以实现增删改数据库的操作。</span><br><span class="line">	</span><br><span class="line">在网页上填一个表格然后提交会有以下几种数据传输经过：</span><br><span class="line">①你接触到的是这个网页是属于表示层，这个网页一般由HTML标签结合CSS&#x2F;JAVASCRIPT来实现的。这时候你要先填入数据。</span><br><span class="line">②然后你按提交触发后台处理机制，这时候数据会传到后台的代码进行处理。这部分代码根据不同网站可以使PHP,JSP，JAVA等。代码根据程序员预设的算法将收到的数据进行处理之后会相应的对数据库进行操作，存储数据等。</span><br><span class="line">③成功操作完数据库之后，业务层的代码会再向表示层也就是显示器端传回一个指令通知你表格填写成功</span><br><span class="line"></span><br><span class="line">从前端向后台传递参数方法</span><br><span class="line"></span><br><span class="line">一、通过表单传递参数</span><br><span class="line">1.前端部分，在前端jsp页面设置form表单，确定需要传递的参数name让用户输入，</span><br><span class="line">  通过点击按钮后submit()提交到后台</span><br><span class="line">2.后台对前端请求的反应，接收数据，处理数据以及返回数据。</span><br><span class="line"></span><br><span class="line">二．通过ajax传递参数（有post和get写法）</span><br><span class="line">1.ajax是如何将前端数据传到后台的</span><br><span class="line">	type: &quot;POST&quot;,&#x2F;&#x2F;type是ajax的方法</span><br><span class="line">	url : &quot;&lt;%&#x3D;path%&gt;&#x2F;resource&#x2F;usermenus&quot;,&#x2F;&#x2F;参数url,要把参数传到什么地方</span><br><span class="line">	data : &#123;parentid:parentid,parentpath:parentpath&#125;,&#x2F;&#x2F;传递什么数据</span><br><span class="line">	success : function(data)&#123;&#x2F;&#x2F;sucess表示，当数据返回成功后要怎么做，返回的数据存储在data</span><br><span class="line">2.后台对前端请求的反应，接收数据</span><br><span class="line">3.前端接收到后端返回的数据进行处理的</span><br></pre></td></tr></table></figure>

<h3 id="cookie的理解"><a href="#cookie的理解" class="headerlink" title="cookie的理解"></a>cookie的理解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cookie又叫会话跟踪技术，是由web服务器保存在用户浏览器上的小文本文件，它可以记录用户ID、密码、浏览过的网页、停留的时间等信息。当用户再次来到该网站时，网站通过读取cookie，得知用户相关信息，就可以做出相应的动作，如在页面显示欢迎用户标语，或者让用户不用输入ID、密码就直接登录等等。如果用户清理了cookie，那么用户曾登录过的网站信息就没有了。</span><br><span class="line"></span><br><span class="line">优点</span><br><span class="line">	极高的扩展性和可用性</span><br><span class="line">	通过良好的编程，可以控制保存在cookie中的session对象的大小</span><br><span class="line">	通过加密技术和安全传输技术，减少cookie被破解的可能</span><br><span class="line">	只在cookie中存放不敏感数据，即使被盗也不会有重大的损失</span><br><span class="line">	控制cookie的生命周期，使之不会永久有效。偷盗者可能拿到一个过期的cookie</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">	cookie有数量和长度的限制。每个domain最多有20条cookie，长度不能超过4KB，否则会被裁掉。</span><br><span class="line">	安全性问题。如果cookie被人拦截了，那个人就可以取得所有的session信息。即使加密也于事无补，因为拦截者不需要知道cookie的意义，他只需要原样转发就能达到目的。</span><br><span class="line">	有些状态不可能保存在客户端。</span><br></pre></td></tr></table></figure>

<h3 id="输入网址到呈现网页发生的过程"><a href="#输入网址到呈现网页发生的过程" class="headerlink" title="输入网址到呈现网页发生的过程"></a>输入网址到呈现网页发生的过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.域名解析</span><br><span class="line">	DNS解析，每一台连上网计算机都有一个唯一标识即它的IP地址，DNS解析就将输入的网址解析成IP地址。</span><br><span class="line">DNS解析是一个递归查询的过程，例如要解析“www.baidu.com”时，过程如下：</span><br><span class="line">	在本地域名服务器中查询IP地址，未找到域名；</span><br><span class="line">	本地域名服务器会向根域名服务器发送请求，未找到域名；</span><br><span class="line">	本地域名服务器向.com顶级域名服务器发送请求，未找到域名；</span><br><span class="line">	本地域名服务器向.baidu.com域名服务器发送请求，找到该域名，将相应的IP返回给本地域名服务器；</span><br><span class="line"></span><br><span class="line">b.发起TCP连接的三次握手</span><br><span class="line">	HTTP协议是使用TCP协议作为其传输层协议的，在拿到服务器的IP地址后，客户端浏览器会与服务器建立TCP连接，该过程包括三次握手：</span><br><span class="line">	第一次握手：建立连接时，客户端向服务端发送请求报文（SYN）</span><br><span class="line">	第二次握手：服务器收到请求报文后，如同意连接，则向客户端发送确认报文（SYN&#x2F;ACK）</span><br><span class="line">	第三次握手：客户端收到服务器的确认后，再次向服务器发送确认报文，完成连接（ACK）</span><br><span class="line">三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。</span><br><span class="line"></span><br><span class="line">c.建立TCP连接后浏览器发起HTTP请求</span><br><span class="line">	浏览器构建HTTP请求报文，并通过TCP协议传送到服务器的指定端口。HTTP请求报文一共有三个部分：</span><br><span class="line">		报文首部（请求行+各种首部字段+其他）</span><br><span class="line">		空行（它的作用是通过一个空行，告诉服务器请求头部到此为止。）</span><br><span class="line">		报文主体（应被发送的数据）通常并不一定要有报文主体</span><br><span class="line">		</span><br><span class="line">d.服务端响应http请求，返回响应报文</span><br><span class="line">HTTP响应报文由四部分组成：响应行、响应头、空行、响应体</span><br><span class="line">响应行</span><br><span class="line">	响应行一般由协议版本、状态码及其描述组成</span><br><span class="line"></span><br><span class="line">响应头</span><br><span class="line">	响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。</span><br><span class="line">常见的响应头字段含义：</span><br><span class="line">	Allow：服务器支持哪些请求方法(如GET、POST等)。</span><br><span class="line">	Content-Encoding：文档的编码(Encode)方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE4、IE5才支持它。因此，Servlet应该通过查看Accept-Encoding头(即request.getHeader(“Accept- Encoding”))检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</span><br><span class="line">	Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</span><br><span class="line">	Content- Type：表示后面的文档属于什么MIME类型。Servlet默认为text&#x2F;plain，但通常需要显式地指定为text&#x2F;html。由于经常要设置 Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</span><br><span class="line">	Date：当前的GMT时间，例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</span><br><span class="line">	Expires：告诉浏览器把回送的资源缓存多长时间，-1或0则是不缓存。</span><br><span class="line">	Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态。Last-Modified也可用setDateHeader方法来设置。</span><br><span class="line">	Location：这个头配合302状态码使用，用于重定向接收者到一个新URI地址。表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</span><br><span class="line">	Refresh：告诉浏览器隔多久刷新一次，以秒计。</span><br><span class="line">	Server：服务器通过这个头告诉浏览器服务器的类型。Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。Servlet一般不设置这个值，而是由Web服务器自己设置。</span><br><span class="line">	Set-Cookie：设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。</span><br><span class="line">	Transfer-Encoding：告诉浏览器数据的传送格式。</span><br><span class="line">	WWW-Authenticate：客户应该在Authorization头中提供什么类型的授权信息?在包含401(Unauthorized)状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm&#x3D;\”executives\”“)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问。</span><br><span class="line">	注：设置应答头最常用的方法是HttpServletResponse的setHeader，该方法有两个参数，分别表示应答头的名字和值。和设置状态代码相似，设置应答头应该在发送任何文档内容之前进行。</span><br><span class="line">	setDateHeader方法和setIntHeader方法专门用来设置包含日期和整数值的应答头，前者避免了把Java时间转换为GMT时间字符串的麻烦，后者则避免了把整数转换为字符串的麻烦。</span><br><span class="line">	HttpServletResponse还提供了许多设置</span><br><span class="line">	setContentType：设置Content-Type头。大多数Servlet都要用到这个方法。</span><br><span class="line">	setContentLength：设置Content-Length头。对于支持持久HTTP连接的浏览器来说，这个函数是很有用的。</span><br><span class="line">	addCookie：设置一个Cookie(Servlet API中没有setCookie方法，因为应答往往包含多个Set-Cookie头)。</span><br><span class="line"></span><br><span class="line">响应体</span><br><span class="line">响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。</span><br><span class="line"></span><br><span class="line">e.浏览器页面渲染</span><br><span class="line">　　解析文档构建DOM树</span><br><span class="line">　　构建渲染树</span><br><span class="line">　　布局和绘制渲染树</span><br><span class="line">　　</span><br><span class="line">f.断开TCP连接</span><br><span class="line">	第一次挥手：客户端想分手，发送消息（FIN）给服务器</span><br><span class="line">	第二次挥手：服务器通知客户端已经接受的挥手请求，返回确认消息（ACK），但还没做好分手准备</span><br><span class="line">	第三次挥手：服务器已经做好分手准备，通知客户端（FIN）</span><br><span class="line">	第四次挥手：客户端发送消息给服务器（ACK），确认分手，服务器关闭连接。</span><br></pre></td></tr></table></figure>

<h3 id="浏览器渲染原理及流程"><a href="#浏览器渲染原理及流程" class="headerlink" title="浏览器渲染原理及流程"></a>浏览器渲染原理及流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：</span><br><span class="line">   当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</span><br><span class="line"></span><br><span class="line">2. 将CSS解析成 CSS Rule Tree 。</span><br><span class="line"></span><br><span class="line">3. 根据DOM树和CSSOM来构造 Rendering Tree。</span><br><span class="line">   注意：Rendering Tree 渲染树并不等同于 DOM 树，</span><br><span class="line">        因为一些像Header或display:none的东西就没必要放在渲染树中了。</span><br><span class="line"></span><br><span class="line">4. 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。</span><br><span class="line">   下一步操作称之为layout，顾名思义就是计算出每个节点在屏幕中的位置。</span><br><span class="line"></span><br><span class="line">5. 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。</span><br></pre></td></tr></table></figure>

<h3 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTML5中的Web Storage包含了两种存储方式，sessionStorage和localStorage。</span><br><span class="line"></span><br><span class="line">sessionStorage用于本地存储一个会话中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此，sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</span><br><span class="line"></span><br><span class="line">localStorage用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期</span><br><span class="line"></span><br><span class="line">首先总的来说，三者都是用于持久化数据存储的手段，都是存储在浏览器端，且同源.</span><br><span class="line"></span><br><span class="line">localStorage和sessionStorage都是Web存储，大小5M左右，完全存储在客户端，它们是因为本地存储数据而存在.</span><br><span class="line"></span><br><span class="line">cookies也是存储在浏览器端的，大小不超过4k，由服务器端存储在客户端。</span><br><span class="line"></span><br><span class="line">localStorage属于永久性存储,数据存储量大,而sessionStorage属于当会话结束的时候，存储的值会被清空，而cookie是通过设置过期时间来存储的。</span><br></pre></td></tr></table></figure>

<h3 id="cookie-localStorage-sessionStorage区别"><a href="#cookie-localStorage-sessionStorage区别" class="headerlink" title="cookie,localStorage,sessionStorage区别"></a>cookie,localStorage,sessionStorage区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">介绍</span><br><span class="line">1.cookie又叫会话跟踪技术，是由web服务器保存在用户浏览器上的小文本文件，它可以记录用户ID、密码、浏览过的网页、停留的时间等信息。当用户再次来到该网站时，网站通过读取cookie，得知用户相关信息,如果用户清理了cookie，那么用户曾登录过的网站信息就没有了。</span><br><span class="line">2.sessionStorage和localStorage是H5新增的本地存储</span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line">1.存储大小的不同</span><br><span class="line">	localStorage的大小一般为5M</span><br><span class="line">	sessionStorage的大小一般为5M</span><br><span class="line">	cookies的大小一般为4K</span><br><span class="line">2.有效期不同：</span><br><span class="line">    localStorage的有效期为永久有效，除非你进行手动删除。</span><br><span class="line">    sessionStorage在当前会话下有效，关闭页面或者浏览器时会被清空。</span><br><span class="line">    cookies在设置的有效之前有效，当超过有效期便会失效。</span><br><span class="line">3.与服务器端的通信</span><br><span class="line">	localStorage不参与服务器端的通信。</span><br><span class="line">	sessionStorage不参与服务器端的通信。</span><br><span class="line">	cookies参与服务器端通信，每次都会携带http的头信息中。（如果使用cookie保存过多数据会带来性能问题）</span><br><span class="line"></span><br><span class="line">应用场景</span><br><span class="line">1.因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，现在基本更加方便</span><br><span class="line">2.sessionStorage:</span><br><span class="line">	可以用来统计当前页面元素的点击次数。</span><br><span class="line">3.localStoragese：</span><br><span class="line">	常用于长期登录(判断用户是否已登录),适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；</span><br><span class="line"></span><br><span class="line">登陆信息用cookie好还是localStorage好？</span><br><span class="line">	1.建议登陆信息用 cookie。即设置过期时间的cookie,看法是 cookie 默认会发送回到后端，</span><br><span class="line">	  这样方便后端读取,而使用localStorage，你需要在每次请求的时候，都手动带上这个信息，</span><br><span class="line">	  这大大增加了开发过程中带来的困难，非常麻烦，而且还要手动维护过期时间。</span><br><span class="line">	2.cookie有时效，而localStorage如果不手动清理则永久保存。</span><br><span class="line">	3.如果要设置关闭网页&#x2F;标签就失效,请用SessionStorage。 这个类似你设置“不带时间的cookie”。</span><br></pre></td></tr></table></figure>

<h3 id="hash值获取方式"><a href="#hash值获取方式" class="headerlink" title="hash值获取方式"></a>hash值获取方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以通过window.location.hash获取hash值</span><br></pre></td></tr></table></figure>

<h3 id="document-write和innerHTML的区别"><a href="#document-write和innerHTML的区别" class="headerlink" title="document.write和innerHTML的区别"></a>document.write和innerHTML的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.write会重绘整个页面</span><br><span class="line"></span><br><span class="line">innerHTML重绘页面的一部分</span><br></pre></td></tr></table></figure>

<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个程序至少有一个进程，一个进程至少有一个线程</span><br><span class="line"></span><br><span class="line">线程的划分尺度小于进程，使得多线程程序的并发性高</span><br><span class="line"></span><br><span class="line">进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大提高了程序的运行效率</span><br><span class="line"></span><br><span class="line">每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 </span><br><span class="line"></span><br><span class="line">从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别</span><br></pre></td></tr></table></figure>

<h3 id="babel原理"><a href="#babel原理" class="headerlink" title="babel原理"></a>babel原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Babel 是一个通用的多功能 JavaScript 编译器，但与一般编译器不同的是它只是把同种语言的高版本规则转换为低版本规则，而不是输出另一种低级机器可识别的代码，并且在依赖不同的拓展插件下可用于不同形式的静态分析。（静态分析：指在不需要执行代码的前提下对代码进行分析以及相应处理的一个过程，主要应用于语法检查、编译、代码高亮、代码转换、优化、压缩等等）</span><br><span class="line"></span><br><span class="line">babel 做了什么</span><br><span class="line">和编译器类似，babel 的转译过程也分为三个阶段，这三步具体是：</span><br><span class="line"></span><br><span class="line">1.解析 Parse</span><br><span class="line">将代码解析生成抽象语法树( 即AST )，也就是计算机理解我们代码的方式(扩展：一般来说每个 js 引擎都有自己的 AST，比如熟知的 v8，chrome 浏览器会把 js 源码转换为抽象语法树，再进一步转换为字节码或机器代码)，而 babel 则是通过 babylon 实现的 。简单来说就是一个对于 JS 代码的一个编译过程，进行了词法分析与语法分析的过程。</span><br><span class="line">2.转换 Transform</span><br><span class="line">对于 AST 进行变换一系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进行遍历，在此过程中进行添加、更新及移除等操作。</span><br><span class="line">3.生成 Generate</span><br><span class="line">将变换后的 AST 再转换为 JS 代码, 使用到的模块是 babel-generator。</span><br><span class="line"></span><br><span class="line">而 babel-core 模块则是将三者结合使得对外提供的API做了一个简化。</span><br><span class="line"></span><br><span class="line">此外需要注意的是，babel 只是转译新标准引入的语法，比如ES6箭头函数：而新标准引入的新的原生对象，部分原生对象新增的原型方法，新增的 API 等（Proxy、Set 等）, 这些事不会转译的，需要引入对应的 polyfill 来解决。</span><br></pre></td></tr></table></figure>

<h3 id="DVA工作流程"><a href="#DVA工作流程" class="headerlink" title="DVA工作流程"></a>DVA工作流程</h3>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
